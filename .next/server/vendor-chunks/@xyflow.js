"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   MiniMapNode: () => (/* binding */ MiniMapNode),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,MiniMapNode,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error001']();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig['node.a11yDescription.default'] : ariaLabelConfig['node.a11yDescription.keyboardDisabled']\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig['edge.a11yDescription.default']\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = 'top-left', children, className, style, ...rest }, ref)=>{\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: style,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = 'Panel';\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'autoPanOnNodeFocus',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'connectionDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance',\n    'ariaLabelConfig'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'ariaLabelConfig') store.setState({\n                    ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n                });\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewQueued: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOptions: fieldValue\n                });\n                else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"])/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.replace('+', '\\n').replace('\\n\\n', '\\n+').split('\\n')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target ?? defaultDoc;\n            const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            const target = event.composedPath?.()?.[0] || event.target;\n                            const isInteractiveElement = target?.nodeName === 'BUTTON' || target?.nodeName === 'A';\n                            if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                                event.preventDefault();\n                            }\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, options);\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        return store.getState().setCenter(x, y, options);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration,\n                            ease: options?.ease,\n                            interpolate: options?.interpolate\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {})=>{\n                        const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        const _snapGrid = options.snapGrid ?? snapGrid;\n                        const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === 'width') {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === 'height') {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setSerial({\n                        \"useQueue.useState\": (n)=>n + BigInt(1)\n                    }[\"useQueue.useState\"])\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();\n            /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            const changes = getElementsDiffChanges({\n                items: next,\n                lookup: nodeLookup\n            });\n            if (hasDefaultNodes) {\n                setNodes(next);\n            }\n            // We only want to fire onNodesChange if there are changes to the nodes\n            if (changes.length > 0) {\n                onNodesChange?.(changes);\n            } else if (fitViewQueued) {\n                // If there are no changes to the nodes, we still need to call setNodes\n                // to trigger a re-render and fitView.\n                window.requestAnimationFrame({\n                    \"BatchProvider.useCallback[nodeQueueHandler]\": ()=>{\n                        const { fitViewQueued, nodes, setNodes } = store.getState();\n                        if (fitViewQueued) {\n                            setNodes(nodes);\n                        }\n                    }\n                }[\"BatchProvider.useCallback[nodeQueueHandler]\"]);\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        ...nodeToUse,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodeConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                fitView: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async (options)=>{\n                        // We either create a new Promise or reuse the existing one\n                        // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                        const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                        // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                        store.setState({\n                            fitViewQueued: true,\n                            fitViewOptions: options,\n                            fitViewResolver\n                        });\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                        return fitViewResolver.promise;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                handleDomNode: event.currentTarget,\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed,\n                dragThreshold: currentStore.connectionDragThreshold\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = nodeTypes?.['default'] || builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig['node.a11yDescription.ariaLiveMessage']({\n                    direction: event.key.replace('Arrow', '').toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(':focus-visible')) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? 'group' : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, it’s designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when you’re dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs – and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once – instead of once per node.\n             * - Any operations that you’d normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized – so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrow\",\n        style: style,\n        strokeLinecap: \"round\",\n        fill: \"none\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color,\n            fill: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrowclosed\",\n        style: style,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    'react-flow__edge-path',\n                    props.className\n                ])\n            }),\n            interactionWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }) : null,\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset,\n            stepPosition: pathOptions?.stepPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        const _onConnectStart = (_event, params)=>{\n            setReconnecting(true);\n            onReconnectStart?.(event, edge, oppositeHandle.type);\n            onConnectStart?.(_event, params);\n        };\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart: _onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle,\n            dragThreshold: store.getState().connectionDragThreshold,\n            handleDomNode: event.currentTarget\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = edgeTypes?.['default'] || builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? 'group' : 'img'),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: 0,\n        height: 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        connectionDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                minZoom,\n                maxZoom,\n                fitViewOptions,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, onScroll, ariaLabelConfig, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ReactFlow.useCallback[wrapperOnScroll]\": (e)=>{\n            e.currentTarget.scrollTo({\n                top: 0,\n                left: 0,\n                behavior: 'instant'\n            });\n            onScroll?.(e);\n        }\n    }[\"ReactFlow.useCallback[wrapperOnScroll]\"], [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    connectionDragThreshold: connectionDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn('[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections');\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : ''}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error014']();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useNodeConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ''}`)\n    }[\"useNodeConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeConnections.useEffect\": ()=>{\n            // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useNodeConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useNodeConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useNodeConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components it’s important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ✨')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig['controls.ariaLabel'],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig['controls.zoomIn.ariaLabel'],\n                        \"aria-label\": ariaLabelConfig['controls.zoomIn.ariaLabel'],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig['controls.zoomOut.ariaLabel'],\n                        \"aria-label\": ariaLabelConfig['controls.zoomOut.ariaLabel'],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig['controls.fitView.ariaLabel'],\n                \"aria-label\": ariaLabelConfig['controls.fitView.ariaLabel'],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig['controls.interactive.ariaLabel'],\n                \"aria-label\": ariaLabelConfig['controls.interactive.ariaLabel'],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, it’s designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const { internals } = s.nodeLookup.get(id);\n            const node = internals.userNode;\n            const { x, y } = internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 1, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig['minimap.ariaLabel'];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'number' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: 'right',\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: 'bottom-right'\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin,\n                                paneDomNode: domNode\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width ?? 0;\n                                const height = change.height ?? node.measured.height ?? 0;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const setAttributes = !resizeDirection ? true : resizeDirection === 'horizontal' ? 'width' : 'height';\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ({ width, height })=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false,\n                                dimensions: {\n                                    width,\n                                    height\n                                }\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                resizeDirection,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? 'backgroundColor' : 'borderColor']: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZzhCQUN3RDtBQUNnRjtBQUM5RztBQUNrc0M7QUFDMTRCO0FBQy9QO0FBQ3pDO0FBQ0Q7QUFFekMsTUFBTTZGLDZCQUFlMUYsb0RBQWFBLENBQUM7QUFDbkMsTUFBTTJGLGFBQWFELGFBQWFFLFFBQVE7QUFFeEMsTUFBTUMsc0JBQXNCbEYseURBQWEsQ0FBQyxXQUFXO0FBQ3JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU21GLFNBQVNDLFFBQVEsRUFBRUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRaEcsaURBQVVBLENBQUN5RjtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU9QLDJFQUFzQkEsQ0FBQ1csT0FBT0YsVUFBVUM7QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRztJQUNMLE1BQU1GLFFBQVFoRyxpREFBVUEsQ0FBQ3lGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBTzNGLDhDQUFPQTsrQkFBQyxJQUFPO2dCQUNsQmtHLFVBQVVILE1BQU1HLFFBQVE7Z0JBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO2dCQUN4QkMsV0FBV0wsTUFBTUssU0FBUztZQUM5Qjs4QkFBSTtRQUFDTDtLQUFNO0FBQ2Y7QUFFQSxNQUFNTSxRQUFRO0lBQUVDLFNBQVM7QUFBTztBQUNoQyxNQUFNQyxnQkFBZ0I7SUFDbEJDLFVBQVU7SUFDVkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVEsQ0FBQztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxN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QU9BO0lBQzFFLDBHQUEwRztJQUMxRyxNQUFNcWEsV0FBVyxPQUFPeXZCLGNBQWMsWUFDaENBLFlBQ0FwbEMsTUFBTXdHLElBQUksS0FBSyxLQUFLeEcsTUFBTTZSLE1BQU0sR0FBRzdFLElBQUksR0FBR1EsS0FBSyxFQUFFdk8sWUFBWTZtQyx1QkFBdUI7SUFDMUYsSUFBSSxDQUFDbndCLFlBQVksQ0FBQzNWLE1BQU13RyxJQUFJLEVBQUU7UUFDMUIsT0FBTztJQUNYO0lBQ0EsTUFBTW1LLFdBQVdsWSxzRUFBc0JBLENBQUN1SDtJQUN4QyxNQUFNa21DLGFBQWE1aEMsTUFBTXFOLElBQUksQ0FBQzNSLE1BQU02UixNQUFNO0lBQzFDLE1BQU1zVSxTQUFTNU4sS0FBS29lLEdBQUcsSUFBSXVQLFdBQVd0bUMsR0FBRyxDQUFDLENBQUNiLE9BQVNBLEtBQUtJLFNBQVMsQ0FBQ2luQixDQUFDLEdBQUc7SUFDdkUsTUFBTThSLGVBQWU7UUFDakIxN0IsVUFBVTtRQUNWbUwsV0FBVzdNLHVFQUF1QkEsQ0FBQzZWLFVBQVU7WUFBRWpRO1lBQUdDO1lBQUdDO1FBQUssR0FBR3BFLFVBQVV3d0IsUUFBUWdaO1FBQy9FN2Y7UUFDQSxHQUFHOXBCLEtBQUs7SUFDWjtJQUNBLE9BQVF4RyxzREFBR0EsQ0FBQzR2QyxtQkFBbUI7UUFBRTduQyxVQUFVL0gsc0RBQUdBLENBQUMsT0FBTztZQUFFd0csT0FBTzY3QjtZQUFjbDZCLFdBQVd4SCxvREFBRUEsQ0FBQztnQkFBQztnQkFBNEJ3SDthQUFVO1lBQUcsR0FBR0MsSUFBSTtZQUFFLFdBQVdpb0MsV0FBV3JoQyxNQUFNLENBQUMsQ0FBQ3NoQyxLQUFLcG5DLE9BQVMsR0FBR29uQyxNQUFNcG5DLEtBQUtwQixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSXlvQyxJQUFJO1lBQUl4b0MsVUFBVUE7UUFBUztJQUFHO0FBQ3JQO0FBRTZxQiIsInNvdXJjZXMiOlsiL2hvbWUva25vd21hZGljL3JlcG8gR2l0aHViL3Byb21wdGxlYXJuX2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5pbXBvcnQgeyBqc3hzLCBGcmFnbWVudCwganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgZm9yd2FyZFJlZiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUNhbGxiYWNrLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IGVycm9yTWVzc2FnZXMsIG1lcmdlQXJpYUxhYmVsQ29uZmlnLCBpbmZpbml0ZUV4dGVudCwgaXNJbnB1dERPTU5vZGUsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBwb2ludFRvUmVuZGVyZXJQb2ludCwgcmVuZGVyZXJQb2ludFRvUG9pbnQsIGlzTm9kZUJhc2UsIGlzRWRnZUJhc2UsIGdldEVsZW1lbnRzVG9SZW1vdmUsIGlzUmVjdE9iamVjdCwgbm9kZVRvUmVjdCwgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXROb2Rlc0JvdW5kcywgd2l0aFJlc29sdmVycywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBnZXREaW1lbnNpb25zLCBYWVBhblpvb20sIFBhbk9uU2Nyb2xsTW9kZSwgU2VsZWN0aW9uTW9kZSwgZ2V0RXZlbnRQb3NpdGlvbiwgZ2V0Tm9kZXNJbnNpZGUsIGFyZVNldHNFcXVhbCwgWFlEcmFnLCBzbmFwUG9zaXRpb24sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgUG9zaXRpb24sIENvbm5lY3Rpb25Nb2RlLCBpc01vdXNlRXZlbnQsIFhZSGFuZGxlLCBnZXRIb3N0Rm9yRWxlbWVudCwgYWRkRWRnZSwgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgaXNOdW1lcmljLCBub2RlSGFzRGltZW5zaW9ucywgZ2V0Tm9kZURpbWVuc2lvbnMsIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBpc0VkZ2VWaXNpYmxlLCBNYXJrZXJUeXBlLCBjcmVhdGVNYXJrZXJJZHMsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldEJlemllclBhdGgsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRNYXJrZXJJZCwgZ2V0Q29ubmVjdGlvblN0YXR1cywgQ29ubmVjdGlvbkxpbmVUeXBlLCB1cGRhdGVDb25uZWN0aW9uTG9va3VwLCBhZG9wdFVzZXJOb2RlcywgaW5pdGlhbENvbm5lY3Rpb24sIGRldldhcm4sIGRlZmF1bHRBcmlhTGFiZWxDb25maWcsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zLCBoYW5kbGVFeHBhbmRQYXJlbnQsIHBhbkJ5LCBmaXRWaWV3cG9ydCwgaXNNYWNPcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgc2hhbGxvd05vZGVEYXRhLCBYWU1pbmltYXAsIGdldEJvdW5kc09mUmVjdHMsIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBYWVJlc2l6ZXIsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUywgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0gfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgYWRkRWRnZSwgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldEVkZ2VDZW50ZXIsIGdldEluY29tZXJzLCBnZXROb2Rlc0JvdW5kcywgZ2V0T3V0Z29lcnMsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCByZWNvbm5lY3RFZGdlIH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuaW1wb3J0IHsgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiwgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3NoYWxsb3cnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyJDEgPSBTdG9yZUNvbnRleHQuUHJvdmlkZXI7XG5cbmNvbnN0IHp1c3RhbmRFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMSddKCk7XG4vKipcbiAqIFRoaXMgaG9vayBjYW4gYmUgdXNlZCB0byBzdWJzY3JpYmUgdG8gaW50ZXJuYWwgc3RhdGUgY2hhbmdlcyBvZiB0aGUgUmVhY3QgRmxvd1xuICogY29tcG9uZW50LiBUaGUgYHVzZVN0b3JlYCBob29rIGlzIHJlLWV4cG9ydGVkIGZyb20gdGhlIFtadXN0YW5kXShodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3p1c3RhbmQpXG4gKiBzdGF0ZSBtYW5hZ2VtZW50IGxpYnJhcnksIHNvIHlvdSBzaG91bGQgY2hlY2sgb3V0IHRoZWlyIGRvY3MgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBBIHNlbGVjdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNsaWNlIG9mIHRoZSBmbG93J3MgaW50ZXJuYWwgc3RhdGUuXG4gKiBFeHRyYWN0aW5nIG9yIHRyYW5zZm9ybWluZyBqdXN0IHRoZSBzdGF0ZSB5b3UgbmVlZCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gYXZvaWQgdW5uZWNlc3NhcnlcbiAqIHJlLXJlbmRlcnMuXG4gKiBAcGFyYW0gZXF1YWxpdHlGbiAtIEEgZnVuY3Rpb24gdG8gY29tcGFyZSB0aGUgcHJldmlvdXMgYW5kIG5leHQgdmFsdWUuIFRoaXMgaXMgaW5jcmVkaWJseSB1c2VmdWxcbiAqIGZvciBwcmV2ZW50aW5nIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMuIEdvb2Qgc2Vuc2libGUgZGVmYXVsdHMgYXJlIHVzaW5nIGBPYmplY3QuaXNgIG9yIGltcG9ydGluZ1xuICogYHp1c3RhbmQvc2hhbGxvd2AsIGJ1dCB5b3UgY2FuIGJlIGFzIGdyYW51bGFyIGFzIHlvdSBsaWtlLlxuICogQHJldHVybnMgVGhlIHNlbGVjdGVkIHN0YXRlIHNsaWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgbm9kZXMgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLm5vZGVzKTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGlmIHRoZXJlIGlzIG5vIG90aGVyIHdheSB0byBhY2Nlc3MgdGhlIGludGVybmFsXG4gKiBzdGF0ZS4gRm9yIG1hbnkgb2YgdGhlIGNvbW1vbiB1c2UgY2FzZXMsIHRoZXJlIGFyZSBkZWRpY2F0ZWQgaG9va3MgYXZhaWxhYmxlXG4gKiBzdWNoIGFzIHtAbGluayB1c2VSZWFjdEZsb3d9LCB7QGxpbmsgdXNlVmlld3BvcnR9LCBldGMuXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oc3RvcmUsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cbi8qKlxuICogSW4gc29tZSBjYXNlcywgeW91IG1pZ2h0IG5lZWQgdG8gYWNjZXNzIHRoZSBzdG9yZSBkaXJlY3RseS4gVGhpcyBob29rIHJldHVybnMgdGhlIHN0b3JlIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCBvbiBkZW1hbmQgdG8gYWNjZXNzIHRoZSBzdGF0ZSBvciBkaXNwYXRjaCBhY3Rpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBzdG9yZSBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGlmIHRoZXJlIGlzIG5vIG90aGVyIHdheSB0byBhY2Nlc3MgdGhlIGludGVybmFsXG4gKiBzdGF0ZS4gRm9yIG1hbnkgb2YgdGhlIGNvbW1vbiB1c2UgY2FzZXMsIHRoZXJlIGFyZSBkZWRpY2F0ZWQgaG9va3MgYXZhaWxhYmxlXG4gKiBzdWNoIGFzIHtAbGluayB1c2VSZWFjdEZsb3d9LCB7QGxpbmsgdXNlVmlld3BvcnR9LCBldGMuXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlQXBpKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICB9KSwgW3N0b3JlXSk7XG59XG5cbmNvbnN0IHN0eWxlID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbmNvbnN0IGFyaWFMaXZlU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIG1hcmdpbjogLTEsXG4gICAgYm9yZGVyOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGNsaXA6ICdyZWN0KDBweCwgMHB4LCAwcHgsIDBweCknLFxuICAgIGNsaXBQYXRoOiAnaW5zZXQoMTAwJSknLFxufTtcbmNvbnN0IEFSSUFfTk9ERV9ERVNDX0tFWSA9ICdyZWFjdC1mbG93X19ub2RlLWRlc2MnO1xuY29uc3QgQVJJQV9FREdFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX2VkZ2UtZGVzYyc7XG5jb25zdCBBUklBX0xJVkVfTUVTU0FHRSA9ICdyZWFjdC1mbG93X19hcmlhLWxpdmUnO1xuY29uc3QgYXJpYUxpdmVTZWxlY3RvciA9IChzKSA9PiBzLmFyaWFMaXZlTWVzc2FnZTtcbmNvbnN0IGFyaWFMYWJlbENvbmZpZ1NlbGVjdG9yID0gKHMpID0+IHMuYXJpYUxhYmVsQ29uZmlnO1xuZnVuY3Rpb24gQXJpYUxpdmVNZXNzYWdlKHsgcmZJZCB9KSB7XG4gICAgY29uc3QgYXJpYUxpdmVNZXNzYWdlID0gdXNlU3RvcmUoYXJpYUxpdmVTZWxlY3Rvcik7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9MSVZFX01FU1NBR0V9LSR7cmZJZH1gLCBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLCBcImFyaWEtYXRvbWljXCI6IFwidHJ1ZVwiLCBzdHlsZTogYXJpYUxpdmVTdHlsZSwgY2hpbGRyZW46IGFyaWFMaXZlTWVzc2FnZSB9KSk7XG59XG5mdW5jdGlvbiBBMTF5RGVzY3JpcHRpb25zKHsgcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeSB9KSB7XG4gICAgY29uc3QgYXJpYUxhYmVsQ29uZmlnID0gdXNlU3RvcmUoYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IpO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBkaXNhYmxlS2V5Ym9hcmRBMTF5XG4gICAgICAgICAgICAgICAgICAgID8gYXJpYUxhYmVsQ29uZmlnWydub2RlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0J11cbiAgICAgICAgICAgICAgICAgICAgOiBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmtleWJvYXJkRGlzYWJsZWQnXSB9KSwganN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGFyaWFMYWJlbENvbmZpZ1snZWRnZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCddIH0pLCAhZGlzYWJsZUtleWJvYXJkQTExeSAmJiBqc3goQXJpYUxpdmVNZXNzYWdlLCB7IHJmSWQ6IHJmSWQgfSldIH0pKTtcbn1cblxuLyoqXG4gKiBUaGUgYDxQYW5lbCAvPmAgY29tcG9uZW50IGhlbHBzIHlvdSBwb3NpdGlvbiBjb250ZW50IGFib3ZlIHRoZSB2aWV3cG9ydC5cbiAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW2A8TWluaU1hcCAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvbWluaW1hcClcbiAqIGFuZCBbYDxDb250cm9scyAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbHMpIGNvbXBvbmVudHMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBQYW5lbCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17W119IGZpdFZpZXc+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1sZWZ0XCI+dG9wLWxlZnQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtY2VudGVyXCI+dG9wLWNlbnRlcjwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1yaWdodFwiPnRvcC1yaWdodDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1sZWZ0XCI+Ym90dG9tLWxlZnQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tY2VudGVyXCI+Ym90dG9tLWNlbnRlcjwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1yaWdodFwiPmJvdHRvbS1yaWdodDwvUGFuZWw+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHsgcG9zaXRpb24gPSAndG9wLWxlZnQnLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbkNsYXNzZXMgPSBgJHtwb3NpdGlvbn1gLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZWwnLCBjbGFzc05hbWUsIC4uLnBvc2l0aW9uQ2xhc3Nlc10pLCBzdHlsZTogc3R5bGUsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufSk7XG5QYW5lbC5kaXNwbGF5TmFtZSA9ICdQYW5lbCc7XG5cbmZ1bmN0aW9uIEF0dHJpYnV0aW9uKHsgcHJvT3B0aW9ucywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0JyB9KSB7XG4gICAgaWYgKHByb09wdGlvbnM/LmhpZGVBdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXR0cmlidXRpb25cIiwgXCJkYXRhLW1lc3NhZ2VcIjogXCJQbGVhc2Ugb25seSBoaWRlIHRoaXMgYXR0cmlidXRpb24gd2hlbiB5b3UgYXJlIHN1YnNjcmliZWQgdG8gUmVhY3QgRmxvdyBQcm86IGh0dHBzOi8vcHJvLnJlYWN0Zmxvdy5kZXZcIiwgY2hpbGRyZW46IGpzeChcImFcIiwgeyBocmVmOiBcImh0dHBzOi8vcmVhY3RmbG93LmRldlwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEZsb3cgYXR0cmlidXRpb25cIiwgY2hpbGRyZW46IFwiUmVhY3QgRmxvd1wiIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkbSA9IChzKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNlbGVjdGVkRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAobm9kZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5wdXNoKG5vZGUuaW50ZXJuYWxzLnVzZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIGVkZ2VdIG9mIHMuZWRnZUxvb2t1cCkge1xuICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfTtcbn07XG5jb25zdCBzZWxlY3RJZCA9IChvYmopID0+IG9iai5pZDtcbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKHNoYWxsb3coYS5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpKSAmJlxuICAgICAgICBzaGFsbG93KGEuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSkpO1xufVxuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXJJbm5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbSwgYXJlRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgbm9kZXM6IHNlbGVjdGVkTm9kZXMsIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzIH07XG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlPy4ocGFyYW1zKTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLmZvckVhY2goKGZuKSA9PiBmbihwYXJhbXMpKTtcbiAgICB9LCBbc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcywgb25TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGNoYW5nZVNlbGVjdG9yID0gKHMpID0+ICEhcy5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzO1xuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXIoeyBvblNlbGVjdGlvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSB1c2VTdG9yZShjaGFuZ2VTZWxlY3Rvcik7XG4gICAgaWYgKG9uU2VsZWN0aW9uQ2hhbmdlIHx8IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIGpzeChTZWxlY3Rpb25MaXN0ZW5lcklubmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGRlZmF1bHROb2RlT3JpZ2luID0gWzAsIDBdO1xuY29uc3QgZGVmYXVsdFZpZXdwb3J0ID0geyB4OiAwLCB5OiAwLCB6b29tOiAxIH07XG5cbi8qXG4gKiBUaGlzIGNvbXBvbmVudCBoZWxwcyB1cyB0byB1cGRhdGUgdGhlIHN0b3JlIHdpdGggdGhlIHZhbHVlcyBjb21pbmcgZnJvbSB0aGUgdXNlci5cbiAqIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gdmFsdWVzIHdlIGNhbiB1cGRhdGUgZGlyZWN0bHkgd2l0aCBgdXNlRGlyZWN0U3RvcmVVcGRhdGVyYCAobGlrZSBgc25hcEdyaWRgKVxuICogYW5kIHZhbHVlcyB0aGF0IGhhdmUgYSBkZWRpY2F0ZWQgc2V0dGVyIGZ1bmN0aW9uIGluIHRoZSBzdG9yZSAobGlrZSBgc2V0Tm9kZXNgKS5cbiAqL1xuLy8gVGhlc2UgZmllbGRzIGV4aXN0IGluIHRoZSBnbG9iYWwgc3RvcmUsIGFuZCB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1cCB0byBkYXRlXG5jb25zdCByZWFjdEZsb3dGaWVsZHNUb1RyYWNrID0gW1xuICAgICdub2RlcycsXG4gICAgJ2VkZ2VzJyxcbiAgICAnZGVmYXVsdE5vZGVzJyxcbiAgICAnZGVmYXVsdEVkZ2VzJyxcbiAgICAnb25Db25uZWN0JyxcbiAgICAnb25Db25uZWN0U3RhcnQnLFxuICAgICdvbkNvbm5lY3RFbmQnLFxuICAgICdvbkNsaWNrQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25DbGlja0Nvbm5lY3RFbmQnLFxuICAgICdub2Rlc0RyYWdnYWJsZScsXG4gICAgJ2F1dG9QYW5Pbk5vZGVGb2N1cycsXG4gICAgJ25vZGVzQ29ubmVjdGFibGUnLFxuICAgICdub2Rlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNSZWNvbm5lY3RhYmxlJyxcbiAgICAnZWxldmF0ZU5vZGVzT25TZWxlY3QnLFxuICAgICdlbGV2YXRlRWRnZXNPblNlbGVjdCcsXG4gICAgJ21pblpvb20nLFxuICAgICdtYXhab29tJyxcbiAgICAnbm9kZUV4dGVudCcsXG4gICAgJ29uTm9kZXNDaGFuZ2UnLFxuICAgICdvbkVkZ2VzQ2hhbmdlJyxcbiAgICAnZWxlbWVudHNTZWxlY3RhYmxlJyxcbiAgICAnY29ubmVjdGlvbk1vZGUnLFxuICAgICdzbmFwR3JpZCcsXG4gICAgJ3NuYXBUb0dyaWQnLFxuICAgICd0cmFuc2xhdGVFeHRlbnQnLFxuICAgICdjb25uZWN0T25DbGljaycsXG4gICAgJ2RlZmF1bHRFZGdlT3B0aW9ucycsXG4gICAgJ2ZpdFZpZXcnLFxuICAgICdmaXRWaWV3T3B0aW9ucycsXG4gICAgJ29uTm9kZXNEZWxldGUnLFxuICAgICdvbkVkZ2VzRGVsZXRlJyxcbiAgICAnb25EZWxldGUnLFxuICAgICdvbk5vZGVEcmFnJyxcbiAgICAnb25Ob2RlRHJhZ1N0YXJ0JyxcbiAgICAnb25Ob2RlRHJhZ1N0b3AnLFxuICAgICdvblNlbGVjdGlvbkRyYWcnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdGFydCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0b3AnLFxuICAgICdvbk1vdmVTdGFydCcsXG4gICAgJ29uTW92ZScsXG4gICAgJ29uTW92ZUVuZCcsXG4gICAgJ25vUGFuQ2xhc3NOYW1lJyxcbiAgICAnbm9kZU9yaWdpbicsXG4gICAgJ2F1dG9QYW5PbkNvbm5lY3QnLFxuICAgICdhdXRvUGFuT25Ob2RlRHJhZycsXG4gICAgJ29uRXJyb3InLFxuICAgICdjb25uZWN0aW9uUmFkaXVzJyxcbiAgICAnaXNWYWxpZENvbm5lY3Rpb24nLFxuICAgICdzZWxlY3ROb2Rlc09uRHJhZycsXG4gICAgJ25vZGVEcmFnVGhyZXNob2xkJyxcbiAgICAnY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQnLFxuICAgICdvbkJlZm9yZURlbGV0ZScsXG4gICAgJ2RlYnVnJyxcbiAgICAnYXV0b1BhblNwZWVkJyxcbiAgICAncGFuZUNsaWNrRGlzdGFuY2UnLFxuICAgICdhcmlhTGFiZWxDb25maWcnLFxuXTtcbi8vIHJmSWQgZG9lc24ndCBleGlzdCBpbiBSZWFjdEZsb3dQcm9wcywgYnV0IGl0J3Mgb25lIG9mIHRoZSBmaWVsZHMgd2Ugd2FudCB0byB1cGRhdGVcbmNvbnN0IGZpZWxkc1RvVHJhY2sgPSBbLi4ucmVhY3RGbG93RmllbGRzVG9UcmFjaywgJ3JmSWQnXTtcbmNvbnN0IHNlbGVjdG9yJGwgPSAocykgPT4gKHtcbiAgICBzZXROb2Rlczogcy5zZXROb2RlcyxcbiAgICBzZXRFZGdlczogcy5zZXRFZGdlcyxcbiAgICBzZXRNaW5ab29tOiBzLnNldE1pblpvb20sXG4gICAgc2V0TWF4Wm9vbTogcy5zZXRNYXhab29tLFxuICAgIHNldFRyYW5zbGF0ZUV4dGVudDogcy5zZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgc2V0Tm9kZUV4dGVudDogcy5zZXROb2RlRXh0ZW50LFxuICAgIHJlc2V0OiBzLnJlc2V0LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiBzLnNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLFxuICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlOiBzLnNldFBhbmVDbGlja0Rpc3RhbmNlLFxufSk7XG5jb25zdCBpbml0UHJldlZhbHVlcyA9IHtcbiAgICAvKlxuICAgICAqIHRoZXNlIGFyZSB2YWx1ZXMgdGhhdCBhcmUgYWxzbyBwYXNzZWQgZGlyZWN0bHkgdG8gb3RoZXIgY29tcG9uZW50c1xuICAgICAqIHRoYW4gdGhlIFN0b3JlVXBkYXRlci4gV2UgY2FuIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNldFN0b3JlIGNhbGxzXG4gICAgICogYnkgc2V0dGluZyB0aGUgc2FtZSB2YWx1ZXMgaGVyZSBhcyBwcmV2IGZpZWxkcy5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVFeHRlbnQ6IGluZmluaXRlRXh0ZW50LFxuICAgIG5vZGVPcmlnaW46IGRlZmF1bHROb2RlT3JpZ2luLFxuICAgIG1pblpvb206IDAuNSxcbiAgICBtYXhab29tOiAyLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICByZklkOiAnMScsXG4gICAgcGFuZUNsaWNrRGlzdGFuY2U6IDAsXG59O1xuZnVuY3Rpb24gU3RvcmVVcGRhdGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBzZXROb2Rlcywgc2V0RWRnZXMsIHNldE1pblpvb20sIHNldE1heFpvb20sIHNldFRyYW5zbGF0ZUV4dGVudCwgc2V0Tm9kZUV4dGVudCwgcmVzZXQsIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLCBzZXRQYW5lQ2xpY2tEaXN0YW5jZSwgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGwsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyhwcm9wcy5kZWZhdWx0Tm9kZXMsIHByb3BzLmRlZmF1bHRFZGdlcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIHJlc2V0IHRoZSBzdG9yZSB3ZSBhbHNvIG5lZWQgdG8gcmVzZXQgdGhlIHByZXZpb3VzIGZpZWxkc1xuICAgICAgICAgICAgcHJldmlvdXNGaWVsZHMuY3VycmVudCA9IGluaXRQcmV2VmFsdWVzO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgcHJldmlvdXNGaWVsZHMgPSB1c2VSZWYoaW5pdFByZXZWYWx1ZXMpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIGZpZWxkc1RvVHJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBwcm9wc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGaWVsZFZhbHVlID0gcHJldmlvdXNGaWVsZHMuY3VycmVudFtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IHByZXZpb3VzRmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHNbZmllbGROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBDdXN0b20gaGFuZGxpbmcgd2l0aCBkZWRpY2F0ZWQgc2V0dGVycyBmb3Igc29tZSBmaWVsZHNcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdub2RlcycpXG4gICAgICAgICAgICAgICAgc2V0Tm9kZXMoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdlZGdlcycpXG4gICAgICAgICAgICAgICAgc2V0RWRnZXMoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtaW5ab29tJylcbiAgICAgICAgICAgICAgICBzZXRNaW5ab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbWF4Wm9vbScpXG4gICAgICAgICAgICAgICAgc2V0TWF4Wm9vbShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ3RyYW5zbGF0ZUV4dGVudCcpXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbm9kZUV4dGVudCcpXG4gICAgICAgICAgICAgICAgc2V0Tm9kZUV4dGVudChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ3BhbmVDbGlja0Rpc3RhbmNlJylcbiAgICAgICAgICAgICAgICBzZXRQYW5lQ2xpY2tEaXN0YW5jZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2FyaWFMYWJlbENvbmZpZycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBhcmlhTGFiZWxDb25maWc6IG1lcmdlQXJpYUxhYmVsQ29uZmlnKGZpZWxkVmFsdWUpIH0pO1xuICAgICAgICAgICAgLy8gUmVuYW1lZCBmaWVsZHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXcnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXdPcHRpb25zJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGZpdFZpZXdPcHRpb25zOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBjYXNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgXG4gICAgLy8gT25seSByZS1ydW4gdGhlIGVmZmVjdCBpZiBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB0cmFjayBjaGFuZ2VzXG4gICAgZmllbGRzVG9UcmFjay5tYXAoKGZpZWxkTmFtZSkgPT4gcHJvcHNbZmllbGROYW1lXSkpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNZWRpYVF1ZXJ5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xufVxuLyoqXG4gKiBIb29rIGZvciByZWNlaXZpbmcgdGhlIGN1cnJlbnQgY29sb3IgbW9kZSBjbGFzcyAnZGFyaycgb3IgJ2xpZ2h0Jy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb2xvck1vZGUgLSBUaGUgY29sb3IgbW9kZSB0byB1c2UgKCdkYXJrJywgJ2xpZ2h0JyBvciAnc3lzdGVtJylcbiAqL1xuZnVuY3Rpb24gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKSB7XG4gICAgY29uc3QgW2NvbG9yTW9kZUNsYXNzLCBzZXRDb2xvck1vZGVDbGFzc10gPSB1c2VTdGF0ZShjb2xvck1vZGUgPT09ICdzeXN0ZW0nID8gbnVsbCA6IGNvbG9yTW9kZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yTW9kZSAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHNldENvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IGdldE1lZGlhUXVlcnkoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29sb3JNb2RlQ2xhc3MgPSAoKSA9PiBzZXRDb2xvck1vZGVDbGFzcyhtZWRpYVF1ZXJ5Py5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG4gICAgICAgIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKCk7XG4gICAgICAgIG1lZGlhUXVlcnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29sb3JNb2RlXSk7XG4gICAgcmV0dXJuIGNvbG9yTW9kZUNsYXNzICE9PSBudWxsID8gY29sb3JNb2RlQ2xhc3MgOiBnZXRNZWRpYVF1ZXJ5KCk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnO1xufVxuXG5jb25zdCBkZWZhdWx0RG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbi8qKlxuICogVGhpcyBob29rIGxldHMgeW91IGxpc3RlbiBmb3Igc3BlY2lmaWMga2V5IGNvZGVzIGFuZCB0ZWxscyB5b3Ugd2hldGhlciB0aGV5IGFyZVxuICogY3VycmVudGx5IHByZXNzZWQgb3Igbm90LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlS2V5UHJlc3MgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBzcGFjZVByZXNzZWQgPSB1c2VLZXlQcmVzcygnU3BhY2UnKTtcbiAqICBjb25zdCBjbWRBbmRTUHJlc3NlZCA9IHVzZUtleVByZXNzKFsnTWV0YStzJywgJ1N0cmcrcyddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAge3NwYWNlUHJlc3NlZCAmJiA8cD5TcGFjZSBwcmVzc2VkITwvcD59XG4gKiAgICAge2NtZEFuZFNQcmVzc2VkICYmIDxwPkNtZCArIFMgcHJlc3NlZCE8L3A+fVxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlS2V5UHJlc3MoXG4vKipcbiAqIFRoZSBrZXkgY29kZSAoc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MpIHNwZWNpZmllcyB3aGljaCBrZXkocykgc2hvdWxkIHRyaWdnZXJcbiAqIGFuIGFjdGlvbi5cbiAqXG4gKiBBICoqc3RyaW5nKiogY2FuIHJlcHJlc2VudDpcbiAqIC0gQSAqKnNpbmdsZSBrZXkqKiwgZS5nLiBgJ2EnYFxuICogLSBBICoqa2V5IGNvbWJpbmF0aW9uKiosIHVzaW5nIGAnKydgIHRvIHNlcGFyYXRlIGtleXMsIGUuZy4gYCdhK2QnYFxuICpcbiAqIEFuICAqKmFycmF5IG9mIHN0cmluZ3MqKiByZXByZXNlbnRzICoqbXVsdGlwbGUgcG9zc2libGUga2V5IGlucHV0cyoqLiBGb3IgZXhhbXBsZSwgYFsnYScsICdkK3MnXWBcbiAqIG1lYW5zIHRoZSB1c2VyIGNhbiBwcmVzcyBlaXRoZXIgdGhlIHNpbmdsZSBrZXkgYCdhJ2Agb3IgdGhlIGNvbWJpbmF0aW9uIG9mIGAnZCdgIGFuZCBgJ3MnYC5cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xua2V5Q29kZSA9IG51bGwsIG9wdGlvbnMgPSB7IHRhcmdldDogZGVmYXVsdERvYywgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IHRydWUgfSkge1xuICAgIGNvbnN0IFtrZXlQcmVzc2VkLCBzZXRLZXlQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGlmIGEgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgaW4gb3JkZXIgdG8gdHJhY2sgaXRcbiAgICBjb25zdCBtb2RpZmllclByZXNzZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHByZXNzZWQga2V5cyBpbiBvcmRlciB0byBzdXBwb3J0IGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHByZXNzZWRLZXlzID0gdXNlUmVmKG5ldyBTZXQoW10pKTtcbiAgICAvKlxuICAgICAqIGtleUNvZGVzID0gYXJyYXkgd2l0aCBzaW5nbGUga2V5cyBbWydhJ11dIG9yIGtleSBjb21iaW5hdGlvbnMgW1snYScsICdzJ11dXG4gICAgICoga2V5c1RvV2F0Y2ggPSBhcnJheSB3aXRoIGFsbCBrZXlzIGZsYXR0ZW5lZCBbJ2EnLCAnZCcsICdTaGlmdExlZnQnXVxuICAgICAqIHVzZWQgdG8gY2hlY2sgaWYgd2Ugc3RvcmUgZXZlbnQuY29kZSBvciBldmVudC5rZXkuIFdoZW4gdGhlIGNvZGUgaXMgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2hcbiAgICAgKiB3ZSB1c2UgdGhlIGNvZGUgb3RoZXJ3aXNlIHRoZSBrZXkuIEV4cGxhaW5lcjogV2hlbiB5b3UgcHJlc3MgdGhlIGxlZnQgXCJjb21tYW5kXCIga2V5LCB0aGUgY29kZSBpcyBcIk1ldGFMZWZ0XCJcbiAgICAgKiBhbmQgdGhlIGtleSBpcyBcIk1ldGFcIi4gV2Ugd2FudCB1c2VycyB0byBiZSBhYmxlIHRvIHBhc3Mga2V5cyBhbmQgY29kZXMgc28gd2UgYXNzdW1lIHRoYXQgdGhlIGtleSBpcyBtZWFudCB3aGVuXG4gICAgICogd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaC5cbiAgICAgKi9cbiAgICBjb25zdCBba2V5Q29kZXMsIGtleXNUb1dhdGNoXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qga2V5Q29kZUFyciA9IEFycmF5LmlzQXJyYXkoa2V5Q29kZSkgPyBrZXlDb2RlIDogW2tleUNvZGVdO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGtleUNvZGVBcnJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrYykgPT4gdHlwZW9mIGtjID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHdlIGZpcnN0IHJlcGxhY2UgYWxsICcrJyB3aXRoICdcXG4nICB3aGljaCB3ZSB3aWxsIHVzZSB0byBzcGxpdCB0aGUga2V5cyBvblxuICAgICAgICAgICAgICAgICAqIHRoZW4gd2UgcmVwbGFjZSAnXFxuXFxuJyB3aXRoICdcXG4rJywgdGhpcyB3YXkgd2UgY2FuIGFsc28gc3VwcG9ydCB0aGUgY29tYmluYXRpb24gJ2tleSsrJ1xuICAgICAgICAgICAgICAgICAqIGluIHRoZSBlbmQgd2Ugc2ltcGx5IHNwbGl0IG9uICdcXG4nIHRvIGdldCB0aGUga2V5IGFycmF5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLm1hcCgoa2MpID0+IGtjLnJlcGxhY2UoJysnLCAnXFxuJykucmVwbGFjZSgnXFxuXFxuJywgJ1xcbisnKS5zcGxpdCgnXFxuJykpO1xuICAgICAgICAgICAgY29uc3Qga2V5c0ZsYXQgPSBrZXlzLnJlZHVjZSgocmVzLCBpdGVtKSA9PiByZXMuY29uY2F0KC4uLml0ZW0pLCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleXMsIGtleXNGbGF0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgfSwgW2tleUNvZGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zPy50YXJnZXQgPz8gZGVmYXVsdERvYztcbiAgICAgICAgY29uc3QgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIgPSBvcHRpb25zPy5hY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA/PyB0cnVlO1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcikpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5wdXRET01Ob2RlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleU9yQ29kZSA9IHVzZUtleU9yQ29kZShldmVudC5jb2RlLCBrZXlzVG9XYXRjaCk7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5hZGQoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLmN1cnJlbnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWRQYXRoPy4oKT8uWzBdIHx8IGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Py5ub2RlTmFtZSA9PT0gJ0JVVFRPTicgfHwgdGFyZ2V0Py5ub2RlTmFtZSA9PT0gJ0EnO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAhPT0gZmFsc2UgJiYgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50IHx8ICFpc0ludGVyYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuZGVsZXRlKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIE1hYzogd2hlbiBjbWQga2V5IGlzIHByZXNzZWQsIGtleXVwIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIGFueSBvdGhlciBrZXksIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjczODAwMTgvd2hlbi1jbWQta2V5LWlzLWtlcHQtcHJlc3NlZC1rZXl1cC1pcy1ub3QtdHJpZ2dlcmVkLWZvci1hbnktb3RoZXIta2V5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ01ldGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNldEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRhcmdldD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtrZXlDb2RlLCBzZXRLZXlQcmVzc2VkXSk7XG4gICAgcmV0dXJuIGtleVByZXNzZWQ7XG59XG4vLyB1dGlsc1xuZnVuY3Rpb24gaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMsIGlzVXApIHtcbiAgICByZXR1cm4gKGtleUNvZGVzXG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIG9ubHkgd2FudCB0byBjb21wYXJlIHNhbWUgc2l6ZXMgb2Yga2V5Q29kZSBkZWZpbml0aW9uc1xuICAgICAgICAgKiBhbmQgcHJlc3NlZCBrZXlzLiBXaGVuIHRoZSB1c2VyIHNwZWNpZmllZCAnTWV0YScgYXMgYSBrZXkgc29tZXdoZXJlXG4gICAgICAgICAqIHRoaXMgd291bGQgYWxzbyBiZSB0cnV0aHkgd2l0aG91dCB0aGlzIGZpbHRlciB3aGVuIHVzZXIgcHJlc3NlcyAnTWV0YScgKyAncidcbiAgICAgICAgICovXG4gICAgICAgIC5maWx0ZXIoKGtleXMpID0+IGlzVXAgfHwga2V5cy5sZW5ndGggPT09IHByZXNzZWRLZXlzLnNpemUpXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNpbmNlIHdlIHdhbnQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzIG9ubHkgb25lIG9mIHRoZVxuICAgICAgICAgKiBjb21iaW5hdGlvbnMgbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBwcmVzc2VkIGtleXNcbiAgICAgICAgICovXG4gICAgICAgIC5zb21lKChrZXlzKSA9PiBrZXlzLmV2ZXJ5KChrKSA9PiBwcmVzc2VkS2V5cy5oYXMoaykpKSk7XG59XG5mdW5jdGlvbiB1c2VLZXlPckNvZGUoZXZlbnRDb2RlLCBrZXlzVG9XYXRjaCkge1xuICAgIHJldHVybiBrZXlzVG9XYXRjaC5pbmNsdWRlcyhldmVudENvZGUpID8gJ2NvZGUnIDogJ2tleSc7XG59XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdmlld3BvcnQgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgem9vbUluOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tT3V0OiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxIC8gMS4yLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZVRvKHpvb21MZXZlbCwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFpvb206ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgc2V0Vmlld3BvcnQ6IGFzeW5jICh2aWV3cG9ydCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtOiBbdFgsIHRZLCB0Wm9vbV0sIHBhblpvb20sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHZpZXdwb3J0LnggPz8gdFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHZpZXdwb3J0LnkgPz8gdFksXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHZpZXdwb3J0Lnpvb20gPz8gdFpvb20sXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRWaWV3cG9ydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHksIHpvb20gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDZW50ZXI6IGFzeW5jICh4LCB5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkuc2V0Q2VudGVyKHgsIHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEJvdW5kczogYXN5bmMgKGJvdW5kcywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh2aWV3cG9ydCwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IG9wdGlvbnM/LmVhc2UsXG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcmVlblRvRmxvd1Bvc2l0aW9uOiAoY2xpZW50UG9zaXRpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNsaWVudFBvc2l0aW9uLnggLSBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiBjbGllbnRQb3NpdGlvbi55IC0gZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IF9zbmFwR3JpZCA9IG9wdGlvbnMuc25hcEdyaWQgPz8gc25hcEdyaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBUb0dyaWQgPSBvcHRpb25zLnNuYXBUb0dyaWQgPz8gc25hcFRvR3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRUb1JlbmRlcmVyUG9pbnQoY29ycmVjdGVkUG9zaXRpb24sIHRyYW5zZm9ybSwgX3NuYXBUb0dyaWQsIF9zbmFwR3JpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxvd1RvU2NyZWVuUG9zaXRpb246IChmbG93UG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb3dQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUG9zaXRpb24gPSByZW5kZXJlclBvaW50VG9Qb2ludChmbG93UG9zaXRpb24sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcmVuZGVyZXJQb3NpdGlvbi54ICsgZG9tWCxcbiAgICAgICAgICAgICAgICAgICAgeTogcmVuZGVyZXJQb3NpdGlvbi55ICsgZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59O1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGNoYW5nZXMgdG8gbm9kZXMgb3IgZWRnZXMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IFJlYWN0IEZsb3cgaW50ZXJuYWxseS5cbiAqIFdoZW4geW91IGRyYWcgYSBub2RlIGZvciBleGFtcGxlLCBSZWFjdCBGbG93IHdpbGwgc2VuZCBhIHBvc2l0aW9uIGNoYW5nZSB1cGRhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIHRoZW4gYXBwbGllcyB0aGUgY2hhbmdlcyBhbmQgcmV0dXJucyB0aGUgdXBkYXRlZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVsZW1lbnRzKSB7XG4gICAgY29uc3QgdXBkYXRlZEVsZW1lbnRzID0gW107XG4gICAgLypcbiAgICAgKiBCeSBzdG9yaW5nIGEgbWFwIG9mIGNoYW5nZXMgZm9yIGVhY2ggZWxlbWVudCwgd2UgY2FuIGEgcXVpY2sgbG9va3VwIGFzIHdlXG4gICAgICogaXRlcmF0ZSBvdmVyIHRoZSBlbGVtZW50cyBhcnJheSFcbiAgICAgKi9cbiAgICBjb25zdCBjaGFuZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZEl0ZW1DaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBhZGRJdGVtQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gJ3JlbW92ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEZvciBhICdyZW1vdmUnIGNoYW5nZSB3ZSBjYW4gc2FmZWx5IGlnbm9yZSBhbnkgb3RoZXIgY2hhbmdlcyBxdWV1ZWQgZm9yXG4gICAgICAgICAgICAgKiB0aGUgc2FtZSBlbGVtZW50LCBpdCdzIGdvaW5nIHRvIGJlIHJlbW92ZWQgYW55d2F5IVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGFuZ2VzTWFwLnNldChjaGFuZ2UuaWQsIFtjaGFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRDaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoY2hhbmdlLmlkKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBzb21lIGNoYW5nZXMgcXVldWVkIGFscmVhZHksIHdlIGNhbiBkbyBhIG11dGFibGUgdXBkYXRlIG9mXG4gICAgICAgICAgICAgICAgICogdGhhdCBhcnJheSBhbmQgc2F2ZSBvdXJzZWx2ZXMgc29tZSBjb3B5aW5nLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGVsZW1lbnRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoZWxlbWVudC5pZCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdoZW4gdGhlcmUgYXJlIG5vIGNoYW5nZXMgZm9yIGFuIGVsZW1lbnQgd2UgY2FuIGp1c3QgcHVzaCBpdCB1bm1vZGlmaWVkLFxuICAgICAgICAgKiBubyBuZWVkIHRvIGNvcHkgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhICdyZW1vdmUnIGNoYW5nZSBxdWV1ZWQsIGl0J2xsIGJlIHRoZSBvbmx5IGNoYW5nZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWzBdLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2VzWzBdLml0ZW0gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIG90aGVyIHR5cGVzIG9mIGNoYW5nZXMsIHdlIHdhbnQgdG8gc3RhcnQgd2l0aCBhIHNoYWxsb3cgY29weSBvZiB0aGVcbiAgICAgICAgICogb2JqZWN0IHNvIFJlYWN0IGtub3dzIHRoaXMgZWxlbWVudCBoYXMgY2hhbmdlZC4gU2VxdWVudGlhbCBjaGFuZ2VzIHdpbGxcbiAgICAgICAgICogZWFjaCBfbXV0YXRlXyB0aGlzIG9iamVjdCwgc28gdGhlcmUncyBvbmx5IGV2ZXIgb25lIGNvcHkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB1cGRhdGVkRWxlbWVudCA9IHsgLi4uZWxlbWVudCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBhcHBseUNoYW5nZShjaGFuZ2UsIHVwZGF0ZWRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh1cGRhdGVkRWxlbWVudCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogd2UgbmVlZCB0byB3YWl0IGZvciBhbGwgY2hhbmdlcyB0byBiZSBhcHBsaWVkIGJlZm9yZSBhZGRpbmcgbmV3IGl0ZW1zXG4gICAgICogdG8gYmUgYWJsZSB0byBhZGQgdGhlbSBhdCB0aGUgY29ycmVjdCBpbmRleFxuICAgICAqL1xuICAgIGlmIChhZGRJdGVtQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgYWRkSXRlbUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMuc3BsaWNlKGNoYW5nZS5pbmRleCwgMCwgeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHsgLi4uY2hhbmdlLml0ZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEVsZW1lbnRzO1xufVxuLy8gQXBwbGllcyBhIHNpbmdsZSBjaGFuZ2UgdG8gYW4gZWxlbWVudC4gVGhpcyBpcyBhICptdXRhYmxlKiB1cGRhdGUuXG5mdW5jdGlvbiBhcHBseUNoYW5nZShjaGFuZ2UsIGVsZW1lbnQpIHtcbiAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWQgPSBjaGFuZ2Uuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwb3NpdGlvbic6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24gPSBjaGFuZ2UucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5kcmFnZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRyYWdnaW5nID0gY2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGltZW5zaW9ucyc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZCA/Pz0ge307XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubWVhc3VyZWQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09IHRydWUgfHwgY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQud2lkdGggPSBjaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09IHRydWUgfHwgY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IGNoYW5nZS5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnJlc2l6aW5nID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6aW5nID0gY2hhbmdlLnJlc2l6aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIG5vZGUgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjaGFuZ2VzIC0gQXJyYXkgb2YgY2hhbmdlcyB0byBhcHBseS5cbiAqIEBwYXJhbSBub2RlcyAtIEFycmF5IG9mIG5vZGVzIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBub2Rlcy5cbiAqIEBleGFtcGxlXG4gKmBgYHRzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgYXBwbHlOb2RlQ2hhbmdlcywgdHlwZSBOb2RlLCB0eXBlIEVkZ2UsIHR5cGUgT25Ob2Rlc0NoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlPE5vZGVbXT4oW10pO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGU8RWRnZVtdPihbXSk7XG4gKiAgY29uc3Qgb25Ob2Rlc0NoYW5nZTogT25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0Tm9kZXMoKG9sZE5vZGVzKSA9PiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG9sZE5vZGVzKSk7XG4gKiAgICB9LFxuICogICAgW3NldE5vZGVzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBOb2RlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgZWRnZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIGVkZ2VzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIGVkZ2VzIC0gQXJyYXkgb2YgZWRnZSB0byBhcHBseSB0aGUgY2hhbmdlcyB0by5cbiAqIEByZXR1cm5zIEFycmF5IG9mIHVwZGF0ZWQgZWRnZXMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseUVkZ2VDaGFuZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAqICAgIChjaGFuZ2VzKSA9PiB7XG4gKiAgICAgIHNldEVkZ2VzKChvbGRFZGdlcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBvbGRFZGdlcykpO1xuICogICAgfSxcbiAqICAgIFtzZXRFZGdlc10sXG4gKiAgKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9IC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgRWRnZUNoYW5nZX1cbiAqIHRoYXQgZGVzY3JpYmVzIGhvdyB0byB1cGRhdGUgdGhlIGVkZ2VzIG9mIHlvdXIgZmxvdyBpbiBzb21lIHdheS5cbiAqIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheVxuICogb2YgdGhlc2UgY2hhbmdlcyBhbmQgYXBwbHkgdGhlbSB0byB5b3VyIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaWQsIHNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhpdGVtcywgc2VsZWN0ZWRJZHMgPSBuZXcgU2V0KCksIG11dGF0ZUl0ZW0gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgaXRlbXMpIHtcbiAgICAgICAgY29uc3Qgd2lsbEJlU2VsZWN0ZWQgPSBzZWxlY3RlZElkcy5oYXMoaWQpO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHNldCBhbGwgaXRlbXMgdG8gc2VsZWN0ZWQ9ZmFsc2Ugb24gdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICBpZiAoIShpdGVtLnNlbGVjdGVkID09PSB1bmRlZmluZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSAmJiBpdGVtLnNlbGVjdGVkICE9PSB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKG11dGF0ZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHRoaXMgaGFjayBpcyBuZWVkZWQgZm9yIG5vZGVzLiBXaGVuIHRoZSB1c2VyIGRyYWdnZWQgYSBub2RlLCBpdCdzIHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgICAqIFdoZW4gYW5vdGhlciBub2RlIGdldHMgZHJhZ2dlZCwgd2UgbmVlZCB0byBkZXNlbGVjdCB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgICAgICAgICAqIGluIG9yZGVyIHRvIGhhdmUgb25seSBvbmUgc2VsZWN0ZWQgbm9kZSBhdCBhIHRpbWUgLSB0aGUgb25Ob2Rlc0NoYW5nZSBjYWxsYmFjayBjb21lcyB0b28gbGF0ZSBoZXJlIDovXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHdpbGxCZVNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpdGVtLmlkLCB3aWxsQmVTZWxlY3RlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7IGl0ZW1zID0gW10sIGxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBpdGVtc0xvb2t1cCA9IG5ldyBNYXAoaXRlbXMubWFwKChpdGVtKSA9PiBbaXRlbS5pZCwgaXRlbV0pKTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgaXRlbV0gb2YgaXRlbXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cEl0ZW0gPSBsb29rdXAuZ2V0KGl0ZW0uaWQpO1xuICAgICAgICBjb25zdCBzdG9yZUl0ZW0gPSBsb29rdXBJdGVtPy5pbnRlcm5hbHM/LnVzZXJOb2RlID8/IGxvb2t1cEl0ZW07XG4gICAgICAgIGlmIChzdG9yZUl0ZW0gIT09IHVuZGVmaW5lZCAmJiBzdG9yZUl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkOiBpdGVtLmlkLCBpdGVtOiBpdGVtLCB0eXBlOiAncmVwbGFjZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3JlSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpdGVtOiBpdGVtLCB0eXBlOiAnYWRkJywgaW5kZXggfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWRdIG9mIGxvb2t1cCkge1xuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IGl0ZW1zTG9va3VwLmdldChpZCk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpZCwgdHlwZTogJ3JlbW92ZScgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBlbGVtZW50VG9SZW1vdmVDaGFuZ2UoaXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICB9O1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpLlxuICogSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvXG4gKiBbYE5vZGVgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9ub2RlKSBpZiBpdCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGEgYE5vZGVgLiBJZiB5b3UncmUgdXNpbmcgVHlwZVNjcmlwdCxcbiAqIHRoaXMgZnVuY3Rpb24gYWN0cyBhcyBhIHR5cGUgZ3VhcmQgYW5kIHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBgTm9kZWAgaWYgaXQgcmV0dXJuc1xuICogYHRydWVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBpc05vZGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmlmIChpc05vZGUobm9kZSkpIHtcbiAqIC8vIC4uLlxuICp9XG4gKmBgYFxuICovXG5jb25zdCBpc05vZGUgPSAoZWxlbWVudCkgPT4gaXNOb2RlQmFzZShlbGVtZW50KTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgRWRnZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBUZXN0cyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBgRWRnZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBFZGdlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzRWRnZShlZGdlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzRWRnZSA9IChlbGVtZW50KSA9PiBpc0VkZ2VCYXNlKGVsZW1lbnQpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1vYmplY3QtdHlwZVxuZnVuY3Rpb24gZml4ZWRGb3J3YXJkUmVmKHJlbmRlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZvcndhcmRSZWYocmVuZGVyKTtcbn1cblxuLy8gd2UgbmVlZCB0aGlzIGhvb2sgdG8gcHJldmVudCBhIHdhcm5pbmcgd2hlbiB1c2luZyByZWFjdC1mbG93IGluIFNTUlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGEgcXVldWUgdGhhdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSBydW5RdWV1ZSAtIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBxdWV1ZSBpcyBmbHVzaGVkXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcmV0dXJucyBhIFF1ZXVlIG9iamVjdFxuICovXG5mdW5jdGlvbiB1c2VRdWV1ZShydW5RdWV1ZSkge1xuICAgIC8qXG4gICAgICogQmVjYXVzZSB3ZSdyZSB1c2luZyBhIHJlZiBhYm92ZSwgd2UgbmVlZCBzb21lIHdheSB0byBsZXQgUmVhY3Qga25vdyB3aGVuIHRvXG4gICAgICogYWN0dWFsbHkgcHJvY2VzcyB0aGUgcXVldWUuIFdlIGluY3JlbWVudCB0aGlzIG51bWJlciBhbnkgdGltZSB3ZSBtdXRhdGUgdGhlXG4gICAgICogcXVldWUsIGNyZWF0aW5nIGEgbmV3IHN0YXRlIHRvIHRyaWdnZXIgdGhlIGxheW91dCBlZmZlY3QgYmVsb3cuXG4gICAgICogVXNpbmcgYSBib29sZWFuIGRpcnR5IGZsYWcgaGVyZSBpbnN0ZWFkIHdvdWxkIGxlYWQgdG8gaXNzdWVzIHJlbGF0ZWQgdG9cbiAgICAgKiBhdXRvbWF0aWMgYmF0Y2hpbmcuIChodHRwczovL2dpdGh1Yi5jb20veHlmbG93L3h5Zmxvdy9pc3N1ZXMvNDc3OSlcbiAgICAgKi9cbiAgICBjb25zdCBbc2VyaWFsLCBzZXRTZXJpYWxdID0gdXNlU3RhdGUoQmlnSW50KDApKTtcbiAgICAvKlxuICAgICAqIEEgcmVmZXJlbmNlIG9mIGFsbCB0aGUgYmF0Y2hlZCB1cGRhdGVzIHRvIHByb2Nlc3MgYmVmb3JlIHRoZSBuZXh0IHJlbmRlci4gV2VcbiAgICAgKiB3YW50IGEgcmVmZXJlbmNlIGhlcmUgc28gbXVsdGlwbGUgc3luY2hyb25vdXMgY2FsbHMgdG8gYHNldE5vZGVzYCBldGMgY2FuIGJlXG4gICAgICogYmF0Y2hlZCB0b2dldGhlci5cbiAgICAgKi9cbiAgICBjb25zdCBbcXVldWVdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlUXVldWUoKCkgPT4gc2V0U2VyaWFsKG4gPT4gbiArIEJpZ0ludCgxKSkpKTtcbiAgICAvKlxuICAgICAqIExheW91dCBlZmZlY3RzIGFyZSBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIHdoaWNoIG1lYW5zIHdlXG4gICAgICogc2hvdWxkbid0IHJ1biBpbnRvIGFueSBpc3N1ZXMgd2l0aCBzdGFsZSBzdGF0ZSBvciB3ZWlyZCBpc3N1ZXMgdGhhdCBjb21lIGZyb21cbiAgICAgKiByZW5kZXJpbmcgdGhpbmdzIG9uZSBmcmFtZSBsYXRlciB0aGFuIGV4cGVjdGVkICh3ZSB1c2VkIHRvIHVzZSBgc2V0VGltZW91dGApLlxuICAgICAqL1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZUl0ZW1zID0gcXVldWUuZ2V0KCk7XG4gICAgICAgIGlmIChxdWV1ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuUXVldWUocXVldWVJdGVtcyk7XG4gICAgICAgICAgICBxdWV1ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwgW3NlcmlhbF0pO1xuICAgIHJldHVybiBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXVlKGNiKSB7XG4gICAgbGV0IHF1ZXVlID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBxdWV1ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBCYXRjaENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBUaGlzIGlzIGEgY29udGV4dCBwcm92aWRlciB0aGF0IGhvbGRzIGFuZCBwcm9jZXNzZXMgdGhlIG5vZGUgYW5kIGVkZ2UgdXBkYXRlIHF1ZXVlc1xuICogdGhhdCBhcmUgbmVlZGVkIHRvIGhhbmRsZSBzZXROb2RlcywgYWRkTm9kZXMsIHNldEVkZ2VzIGFuZCBhZGRFZGdlcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQmF0Y2hQcm92aWRlcih7IGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIHNldE5vZGVzLCBoYXNEZWZhdWx0Tm9kZXMsIG9uTm9kZXNDaGFuZ2UsIG5vZGVMb29rdXAsIGZpdFZpZXdRdWV1ZWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYW4gYEFycmF5LnJlZHVjZWAgaW4gaW1wZXJhdGl2ZSBjbG90aGluZy4gUHJvY2Vzc2luZ1xuICAgICAgICAgKiB0aGlzIHF1ZXVlIGlzIGEgcmVsYXRpdmVseSBob3QgcGF0aCBzbyB3ZSdkIGxpa2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mXG4gICAgICAgICAqIGFycmF5IG1ldGhvZHMgd2hlcmUgd2UgY2FuLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG5leHQgPSBub2RlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHtcbiAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgbG9va3VwOiBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0Tm9kZXMobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGZpcmUgb25Ob2Rlc0NoYW5nZSBpZiB0aGVyZSBhcmUgY2hhbmdlcyB0byB0aGUgbm9kZXNcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjaGFuZ2VzIHRvIHRoZSBub2Rlcywgd2Ugc3RpbGwgbmVlZCB0byBjYWxsIHNldE5vZGVzXG4gICAgICAgICAgICAvLyB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyIGFuZCBmaXRWaWV3LlxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmaXRWaWV3UXVldWVkLCBub2Rlcywgc2V0Tm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHVzZVF1ZXVlKG5vZGVRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UsIGVkZ2VMb29rdXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGxldCBuZXh0ID0gZWRnZXM7XG4gICAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBxdWV1ZUl0ZW1zKSB7XG4gICAgICAgICAgICBuZXh0ID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKG5leHQpIDogcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBzZXRFZGdlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbkVkZ2VzQ2hhbmdlKSB7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cDogZWRnZUxvb2t1cCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBlZGdlUXVldWUgPSB1c2VRdWV1ZShlZGdlUXVldWVIYW5kbGVyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgbm9kZVF1ZXVlLCBlZGdlUXVldWUgfSksIFtdKTtcbiAgICByZXR1cm4ganN4KEJhdGNoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUJhdGNoQ29udGV4dCgpIHtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VDb250ZXh0KEJhdGNoQ29udGV4dCk7XG4gICAgaWYgKCFiYXRjaENvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VCYXRjaENvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJhdGNoUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhdGNoQ29udGV4dDtcbn1cblxuY29uc3Qgc2VsZWN0b3IkayA9IChzKSA9PiAhIXMucGFuWm9vbTtcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBSZWFjdEZsb3dJbnN0YW5jZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSBub2RlcyBhbmQgZWRnZXMsIG1hbmlwdWxhdGUgdGhlIHZpZXdwb3J0LCBvciBxdWVyeSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlUmVhY3RGbG93IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gTm9kZUNvdW50ZXIoKSB7XG4gKiAgY29uc3QgcmVhY3RGbG93ID0gdXNlUmVhY3RGbG93KCk7XG4gKiAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCBjb3VudE5vZGVzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICogICAgc2V0Q291bnQocmVhY3RGbG93LmdldE5vZGVzKCkubGVuZ3RoKTtcbiAqICAgIC8vIHlvdSBuZWVkIHRvIHBhc3MgaXQgYXMgYSBkZXBlbmRlbmN5IGlmIHlvdSBhcmUgdXNpbmcgaXQgd2l0aCB1c2VFZmZlY3Qgb3IgdXNlQ2FsbGJhY2tcbiAqICAgIC8vIGJlY2F1c2UgYXQgdGhlIGZpcnN0IHJlbmRlciwgaXQncyBub3QgaW5pdGlhbGl6ZWQgeWV0IGFuZCBzb21lIGZ1bmN0aW9ucyBtaWdodCBub3Qgd29yay5cbiAqICB9LCBbcmVhY3RGbG93XSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8YnV0dG9uIG9uQ2xpY2s9e2NvdW50Tm9kZXN9PlVwZGF0ZSBjb3VudDwvYnV0dG9uPlxuICogICAgICA8cD5UaGVyZSBhcmUge2NvdW50fSBub2RlcyBpbiB0aGUgZmxvdy48L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VSZWFjdEZsb3coKSB7XG4gICAgY29uc3Qgdmlld3BvcnRIZWxwZXIgPSB1c2VWaWV3cG9ydEhlbHBlcigpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VCYXRjaENvbnRleHQoKTtcbiAgICBjb25zdCB2aWV3cG9ydEluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3Ikayk7XG4gICAgY29uc3QgZ2VuZXJhbEhlbHBlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRJbnRlcm5hbE5vZGUgPSAoaWQpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBzZXROb2RlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldEVkZ2VzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVRvVXNlID0gaXNOb2RlKG5vZGUpID8gbm9kZSA6IG5vZGVMb29rdXAuZ2V0KG5vZGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBub2RlVG9Vc2UucGFyZW50SWRcbiAgICAgICAgICAgICAgICA/IGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihub2RlVG9Vc2UucG9zaXRpb24sIG5vZGVUb1VzZS5tZWFzdXJlZCwgbm9kZVRvVXNlLnBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKVxuICAgICAgICAgICAgICAgIDogbm9kZVRvVXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVdpdGhQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlVG9Vc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGVUb1VzZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZVRvVXNlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZVRvVXNlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZVRvVXNlLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZVRvUmVjdChub2RlV2l0aFBvc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlTm9kZSA9IChpZCwgbm9kZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0Tm9kZXMoKHByZXZOb2RlcykgPT4gcHJldk5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHR5cGVvZiBub2RlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gbm9kZVVwZGF0ZShub2RlKSA6IG5vZGVVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNOb2RlKG5leHROb2RlKSA/IG5leHROb2RlIDogeyAuLi5ub2RlLCAuLi5uZXh0Tm9kZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlRWRnZSA9IChpZCwgZWRnZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0RWRnZXMoKHByZXZFZGdlcykgPT4gcHJldkVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWRnZSA9IHR5cGVvZiBlZGdlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZWRnZVVwZGF0ZShlZGdlKSA6IGVkZ2VVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNFZGdlKG5leHRFZGdlKSA/IG5leHRFZGdlIDogeyAuLi5lZGdlLCAuLi5uZXh0RWRnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5vZGVzOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICBnZXROb2RlOiAoaWQpID0+IGdldEludGVybmFsTm9kZShpZCk/LmludGVybmFscy51c2VyTm9kZSxcbiAgICAgICAgICAgIGdldEludGVybmFsTm9kZSxcbiAgICAgICAgICAgIGdldEVkZ2VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlZGdlcyA9IFtdIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVkZ2U6IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5lZGdlTG9va3VwLmdldChpZCksXG4gICAgICAgICAgICBzZXROb2RlcyxcbiAgICAgICAgICAgIHNldEVkZ2VzLFxuICAgICAgICAgICAgYWRkTm9kZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXMsIC4uLm5ld05vZGVzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRWRnZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQuZWRnZVF1ZXVlLnB1c2goKGVkZ2VzKSA9PiBbLi4uZWRnZXMsIC4uLm5ld0VkZ2VzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9PYmplY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHM6IGFzeW5jICh7IG5vZGVzOiBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzOiBlZGdlc1RvUmVtb3ZlID0gW10gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIGVkZ2VzLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgb25EZWxldGUsIG9uQmVmb3JlRGVsZXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzOiBtYXRjaGluZ05vZGVzLCBlZGdlczogbWF0Y2hpbmdFZGdlcyB9ID0gYXdhaXQgZ2V0RWxlbWVudHNUb1JlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVEZWxldGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTWF0Y2hpbmdFZGdlcyA9IG1hdGNoaW5nRWRnZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ05vZGVzID0gbWF0Y2hpbmdOb2Rlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gbWF0Y2hpbmdFZGdlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0RlbGV0ZT8uKG1hdGNoaW5nRWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG1hdGNoaW5nTm9kZXMubWFwKGVsZW1lbnRUb1JlbW92ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/LihtYXRjaGluZ05vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nTm9kZXMgfHwgaGFzTWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT8uKHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxldGVkTm9kZXM6IG1hdGNoaW5nTm9kZXMsIGRlbGV0ZWRFZGdlczogbWF0Y2hpbmdFZGdlcyB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzOiAobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTm9kZXNPcHRpb24gPSBub2RlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkubm9kZXMpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlICYmICFpc1JlY3QgJiYgKG4uaWQgPT09IG5vZGVPclJlY3QuaWQgfHwgIWludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyTm9kZVJlY3QgPSBub2RlVG9SZWN0KGhhc05vZGVzT3B0aW9uID8gbiA6IGludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShjdXJyTm9kZVJlY3QsIG5vZGVSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnRpYWxseVZpc2libGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBjdXJyTm9kZVJlY3Qud2lkdGggKiBjdXJyTm9kZVJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTm9kZUludGVyc2VjdGluZzogKG5vZGVPclJlY3QsIGFyZWEsIHBhcnRpYWxseSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShub2RlUmVjdCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOb2RlLFxuICAgICAgICAgICAgdXBkYXRlTm9kZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGUoaWQsIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKG5vZGUpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4ubm9kZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4ubm9kZSwgZGF0YTogeyAuLi5ub2RlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVFZGdlLFxuICAgICAgICAgICAgdXBkYXRlRWRnZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2UoaWQsIChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKGVkZ2UpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4uZWRnZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4uZWRnZSwgZGF0YTogeyAuLi5lZGdlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROb2Rlc0JvdW5kczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2Rlc0JvdW5kcyhub2RlcywgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEhhbmRsZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBpZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICAgICAgZ2V0Tm9kZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBoYW5kbGVJZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9JHt0eXBlID8gKGhhbmRsZUlkID8gYC0ke3R5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHt0eXBlfWApIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGZpdFZpZXc6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGNyZWF0ZSBhIG5ldyBQcm9taXNlIG9yIHJldXNlIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICAvLyBFdmVuIGlmIGZpdFZpZXcgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGEgcm93LCB3ZSBvbmx5IGVuZCB1cCB3aXRoIGEgc2luZ2xlIFByb21pc2VcbiAgICAgICAgICAgICAgICBjb25zdCBmaXRWaWV3UmVzb2x2ZXIgPSBzdG9yZS5nZXRTdGF0ZSgpLmZpdFZpZXdSZXNvbHZlciA/PyB3aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2NoZWR1bGUgYSBmaXRWaWV3IGJ5IHNldHRpbmcgZml0Vmlld1F1ZXVlZCBhbmQgdHJpZ2dlcmluZyBhIHNldE5vZGVzXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3UXVldWVkOiB0cnVlLCBmaXRWaWV3T3B0aW9uczogb3B0aW9ucywgZml0Vmlld1Jlc29sdmVyIH0pO1xuICAgICAgICAgICAgICAgIGJhdGNoQ29udGV4dC5ub2RlUXVldWUucHVzaCgobm9kZXMpID0+IFsuLi5ub2Rlc10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRWaWV3UmVzb2x2ZXIucHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmdlbmVyYWxIZWxwZXIsXG4gICAgICAgICAgICAuLi52aWV3cG9ydEhlbHBlcixcbiAgICAgICAgICAgIHZpZXdwb3J0SW5pdGlhbGl6ZWQsXG4gICAgICAgIH07XG4gICAgfSwgW3ZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0ZWQgPSAoaXRlbSkgPT4gaXRlbS5zZWxlY3RlZDtcbmNvbnN0IHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIGdsb2JhbCBrZXkgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCB7IGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiBmYWxzZSB9KTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4kMSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBub2Rlcy5maWx0ZXIoc2VsZWN0ZWQpLCBlZGdlczogZWRnZXMuZmlsdGVyKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc2l6ZUhhbmRsZXIoZG9tTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0RGltZW5zaW9ucyhkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ID09PSAwIHx8IHNpemUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA0JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDQnXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgd2lkdGg6IHNpemUud2lkdGggfHwgNTAwLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IHx8IDUwMCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdXBkYXRlRGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlciAmJiBkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGogPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgbGliOiBzLmxpYixcbn0pO1xuZnVuY3Rpb24gWm9vbVBhbmUoeyBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBsaWIgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGosIHNoYWxsb3cpO1xuICAgIGNvbnN0IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHpvb21BY3RpdmF0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuWm9vbSA9IHVzZVJlZigpO1xuICAgIHVzZVJlc2l6ZUhhbmRsZXIoem9vbVBhbmUpO1xuICAgIGNvbnN0IG9uVHJhbnNmb3JtQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4oeyB4OiB0cmFuc2Zvcm1bMF0sIHk6IHRyYW5zZm9ybVsxXSwgem9vbTogdHJhbnNmb3JtWzJdIH0pO1xuICAgICAgICBpZiAoIWlzQ29udHJvbGxlZFZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh6b29tUGFuZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQgPSBYWVBhblpvb20oe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIHBhbmVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2U6IChwYW5lRHJhZ2dpbmcpID0+IHN0b3JlLnNldFN0YXRlKHsgcGFuZURyYWdnaW5nIH0pLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0OiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0LCBvbk1vdmVTdGFydCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3ZlU3RhcnQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb206IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlLCBvbk1vdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZT8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ6IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlRW5kLCBvbk1vdmVFbmQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZUVuZD8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VFbmQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBwYW5ab29tLmN1cnJlbnQuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwYW5ab29tOiBwYW5ab29tLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbeCwgeSwgem9vbV0sXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogem9vbVBhbmUuY3VycmVudC5jbG9zZXN0KCcucmVhY3QtZmxvdycpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhblpvb20uY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBsaWIsXG4gICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgIF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3JlbmRlcmVyXCIsIHJlZjogem9vbVBhbmUsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkaSA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICB1c2VyU2VsZWN0aW9uUmVjdDogcy51c2VyU2VsZWN0aW9uUmVjdCxcbn0pO1xuZnVuY3Rpb24gVXNlclNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25SZWN0IH0gPSB1c2VTdG9yZShzZWxlY3RvciRpLCBzaGFsbG93KTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgdXNlclNlbGVjdGlvblJlY3Q7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmNvbnN0IHdyYXBIYW5kbGVyID0gKGhhbmRsZXIsIGNvbnRhaW5lclJlZikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyPy4oZXZlbnQpO1xuICAgIH07XG59O1xuY29uc3Qgc2VsZWN0b3IkaCA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25JblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbiAgICBkcmFnZ2luZzogcy5wYW5lRHJhZ2dpbmcsXG59KTtcbmZ1bmN0aW9uIFBhbmUoeyBpc1NlbGVjdGluZywgc2VsZWN0aW9uS2V5UHJlc3NlZCwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuT25EcmFnLCBzZWxlY3Rpb25PbkRyYWcsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljaywgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZHJhZ2dpbmcsIGNvbm5lY3Rpb25JblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRoLCBzaGFsbG93KTtcbiAgICBjb25zdCBoYXNBY3RpdmVTZWxlY3Rpb24gPSBlbGVtZW50c1NlbGVjdGFibGUgJiYgKGlzU2VsZWN0aW5nIHx8IHVzZXJTZWxlY3Rpb25BY3RpdmUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVJZHMgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgICBjb25zdCBzZWxlY3RlZEVkZ2VJZHMgPSB1c2VSZWYobmV3IFNldCgpKTtcbiAgICAvLyBVc2VkIHRvIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0cyBnbyBvZiB0aGUgc2VsZWN0aW9uS2V5IGR1cmluZyBhIHNlbGVjdGlvblxuICAgIGNvbnN0IHNlbGVjdGlvbkluUHJvZ3Jlc3MgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gV2UgcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXQgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICAgICAgLy8gV2UgYWxzbyBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIGEgY29ubmVjdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAoc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50IHx8IGNvbm5lY3Rpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblBhbmVDbGljaz8uKGV2ZW50KTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5yZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnPy5pbmNsdWRlcygyKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblBhbmVDb250ZXh0TWVudT8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uV2hlZWwgPSBvblBhbmVTY3JvbGwgPyAoZXZlbnQpID0+IG9uUGFuZVNjcm9sbChldmVudCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlc2V0U2VsZWN0ZWRFbGVtZW50cywgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29udGFpbmVyQm91bmRzLmN1cnJlbnQgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFlbGVtZW50c1NlbGVjdGFibGUgfHxcbiAgICAgICAgICAgICFpc1NlbGVjdGluZyB8fFxuICAgICAgICAgICAgZXZlbnQuYnV0dG9uICE9PSAwIHx8XG4gICAgICAgICAgICBldmVudC50YXJnZXQgIT09IGNvbnRhaW5lci5jdXJyZW50IHx8XG4gICAgICAgICAgICAhY29udGFpbmVyQm91bmRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQ/LnNldFBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogeSxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgb25TZWxlY3Rpb25TdGFydD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlck1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCwgdHJhbnNmb3JtLCBub2RlTG9va3VwLCBlZGdlTG9va3VwLCBjb25uZWN0aW9uTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZGVmYXVsdEVkZ2VPcHRpb25zLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fCAhdXNlclNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHg6IG1vdXNlWCwgeTogbW91c2VZIH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50Lm5hdGl2ZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRYLCBzdGFydFkgfSA9IHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgICAgICBjb25zdCBuZXh0VXNlclNlbGVjdFJlY3QgPSB7XG4gICAgICAgICAgICBzdGFydFgsXG4gICAgICAgICAgICBzdGFydFksXG4gICAgICAgICAgICB4OiBtb3VzZVggPCBzdGFydFggPyBtb3VzZVggOiBzdGFydFgsXG4gICAgICAgICAgICB5OiBtb3VzZVkgPCBzdGFydFkgPyBtb3VzZVkgOiBzdGFydFksXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5hYnMobW91c2VYIC0gc3RhcnRYKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMobW91c2VZIC0gc3RhcnRZKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkTm9kZUlkcyA9IHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50O1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWRFZGdlSWRzID0gc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQ7XG4gICAgICAgIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50ID0gbmV3IFNldChnZXROb2Rlc0luc2lkZShub2RlTG9va3VwLCBuZXh0VXNlclNlbGVjdFJlY3QsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QYXJ0aWFsLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGVkZ2VzU2VsZWN0YWJsZSA9IGRlZmF1bHRFZGdlT3B0aW9ucz8uc2VsZWN0YWJsZSA/PyB0cnVlO1xuICAgICAgICAvLyBXZSBsb29rIGZvciBhbGwgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzZWxlY3RlZCBub2Rlc1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBjb25uZWN0aW9uTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9ucylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBlZGdlSWQgfSBvZiBjb25uZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBlZGdlTG9va3VwLmdldChlZGdlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlICYmIChlZGdlLnNlbGVjdGFibGUgPz8gZWRnZXNTZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudC5hZGQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmVTZXRzRXF1YWwocHJldlNlbGVjdGVkTm9kZUlkcywgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmVTZXRzRXF1YWwocHJldlNlbGVjdGVkRWRnZUlkcywgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwLCBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudCk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG5leHRVc2VyU2VsZWN0UmVjdCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5yZWxlYXNlUG9pbnRlckNhcHR1cmU/LihldmVudC5wb2ludGVySWQpO1xuICAgICAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25SZWN0IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBvbmx5IHdhbnQgdG8gdHJpZ2dlciBjbGljayBmdW5jdGlvbnMgd2hlbiBpbiBzZWxlY3Rpb24gbW9kZSBpZlxuICAgICAgICAgKiB0aGUgdXNlciBkaWQgbm90IG1vdmUgdGhlIG1vdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0ICYmIGV2ZW50LnRhcmdldCA9PT0gY29udGFpbmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uQ2xpY2s/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBzZWxlY3RlZE5vZGVJZHMuY3VycmVudC5zaXplID4gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uRW5kPy4oZXZlbnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgdXNlciBrZXB0IGhvbGRpbmcgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgdGhlIHNlbGVjdGlvbixcbiAgICAgICAgICogd2UgbmVlZCB0byByZXNldCB0aGUgc2VsZWN0aW9uSW5Qcm9ncmVzcywgc28gdGhlIG5leHQgY2xpY2sgZXZlbnQgaXMgbm90IHByZXZlbnRlZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHNlbGVjdGlvbktleVByZXNzZWQgfHwgc2VsZWN0aW9uT25EcmFnKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IHBhbk9uRHJhZyA9PT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygwKSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmUnLCB7IGRyYWdnYWJsZSwgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvblBvaW50ZXJFbnRlcjogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogb25QYW5lTW91c2VFbnRlciwgb25Qb2ludGVyRG93bjogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyRG93biA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyTW92ZTogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyTW92ZSA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlclVwIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgcmVmOiBjb250YWluZXIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtjaGlsZHJlbiwganN4KFVzZXJTZWxlY3Rpb24sIHt9KV0gfSkpO1xufVxuXG4vKlxuICogdGhpcyBoYW5kbGVyIGlzIGNhbGxlZCBieVxuICogMS4gdGhlIGNsaWNrIGhhbmRsZXIgd2hlbiBub2RlIGlzIG5vdCBkcmFnZ2FibGUgb3Igc2VsZWN0Tm9kZXNPbkRyYWcgPSBmYWxzZVxuICogb3JcbiAqIDIuIHRoZSBvbiBkcmFnIHN0YXJ0IGhhbmRsZXIgd2hlbiBub2RlIGlzIGRyYWdnYWJsZSBhbmQgc2VsZWN0Tm9kZXNPbkRyYWcgPSB0cnVlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vZGVDbGljayh7IGlkLCBzdG9yZSwgdW5zZWxlY3QgPSBmYWxzZSwgbm9kZVJlZiwgfSkge1xuICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWROb2RlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZUxvb2t1cCwgb25FcnJvciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEyJ10oaWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICBpZiAoIW5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlcyhbaWRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5zZWxlY3QgfHwgKG5vZGUuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpKSB7XG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbbm9kZV0sIGVkZ2VzOiBbXSB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IG5vZGVSZWY/LmN1cnJlbnQ/LmJsdXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgWFlEcmFnIGhlbHBlciBmcm9tIEB4eWZsb3cvc3lzdGVtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHh5RHJhZyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHh5RHJhZy5jdXJyZW50ID0gWFlEcmFnKHtcbiAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICBvbk5vZGVNb3VzZURvd246IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0b3A6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IG5vZGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW25vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRpc2FibGVkLCBpc1NlbGVjdGFibGUsIG5vZGVSZWYsIG5vZGVJZF0pO1xuICAgIHJldHVybiBkcmFnZ2luZztcbn1cblxuY29uc3Qgc2VsZWN0ZWRBbmREcmFnZ2FibGUgPSAobm9kZXNEcmFnZ2FibGUpID0+IChuKSA9PiBuLnNlbGVjdGVkICYmIChuLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG4uZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuLyoqXG4gKiBIb29rIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9ucyBieSBwYXNzaW5nIGEgZGlyZWN0aW9uIGFuZCBmYWN0b3JcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VDYWxsYmFjaygocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUV4dGVudCwgc25hcFRvR3JpZCwgc25hcEdyaWQsIG5vZGVzRHJhZ2dhYmxlLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkQW5kRHJhZ2dhYmxlKG5vZGVzRHJhZ2dhYmxlKTtcbiAgICAgICAgLypcbiAgICAgICAgICogYnkgZGVmYXVsdCBhIG5vZGUgbW92ZXMgNXB4IG9uIGVhY2gga2V5IHByZXNzXG4gICAgICAgICAqIGlmIHNuYXAgZ3JpZCBpcyBlbmFibGVkLCB3ZSB1c2UgdGhhdCBmb3IgdGhlIHZlbG9jaXR5XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB4VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFswXSA6IDU7XG4gICAgICAgIGNvbnN0IHlWZWxvID0gc25hcFRvR3JpZCA/IHNuYXBHcmlkWzFdIDogNTtcbiAgICAgICAgY29uc3QgeERpZmYgPSBwYXJhbXMuZGlyZWN0aW9uLnggKiB4VmVsbyAqIHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGNvbnN0IHlEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi55ICogeVZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgICAgIGlmICghaXNTZWxlY3RlZChub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggKyB4RGlmZixcbiAgICAgICAgICAgICAgICB5OiBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgKyB5RGlmZixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHNuYXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIHNuYXBHcmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIG5vZGVVcGRhdGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKG5vZGVVcGRhdGVzKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG1vdmVTZWxlY3RlZE5vZGVzO1xufVxuXG5jb25zdCBOb2RlSWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyID0gTm9kZUlkQ29udGV4dC5Qcm92aWRlcjtcbk5vZGVJZENvbnRleHQuQ29uc3VtZXI7XG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoaXMgaG9vayB0byBnZXQgdGhlIGlkIG9mIHRoZSBub2RlIGl0IGlzIHVzZWQgaW5zaWRlLiBJdCBpcyB1c2VmdWxcbiAqIGlmIHlvdSBuZWVkIHRoZSBub2RlJ3MgaWQgZGVlcGVyIGluIHRoZSByZW5kZXIgdHJlZSBidXQgZG9uJ3Qgd2FudCB0byBtYW51YWxseVxuICogZHJpbGwgZG93biB0aGUgaWQgYXMgYSBwcm9wLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFRoZSBpZCBmb3IgYSBub2RlIGluIHRoZSBmbG93LlxuICpcbiAqIEBleGFtcGxlXG4gKmBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlSWQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEN1c3RvbU5vZGUoKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxzcGFuPlRoaXMgbm9kZSBoYXMgYW4gaWQgb2YgPC9zcGFuPlxuICogICAgICA8Tm9kZUlkRGlzcGxheSAvPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpcbiAqZnVuY3Rpb24gTm9kZUlkRGlzcGxheSgpIHtcbiAqICBjb25zdCBub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAqXG4gKiAgcmV0dXJuIDxzcGFuPntub2RlSWR9PC9zcGFuPjtcbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgdXNlTm9kZUlkID0gKCkgPT4ge1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZUNvbnRleHQoTm9kZUlkQ29udGV4dCk7XG4gICAgcmV0dXJuIG5vZGVJZDtcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGcgPSAocykgPT4gKHtcbiAgICBjb25uZWN0T25DbGljazogcy5jb25uZWN0T25DbGljayxcbiAgICBub1BhbkNsYXNzTmFtZTogcy5ub1BhbkNsYXNzTmFtZSxcbiAgICByZklkOiBzLnJmSWQsXG59KTtcbmNvbnN0IGNvbm5lY3RpbmdTZWxlY3RvciA9IChub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSA9PiAoc3RhdGUpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBjbGlja0hhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb24gfSA9IHN0YXRlO1xuICAgIGNvbnN0IHsgZnJvbUhhbmRsZSwgdG9IYW5kbGUsIGlzVmFsaWQgfSA9IGNvbm5lY3Rpb247XG4gICAgY29uc3QgY29ubmVjdGluZ1RvID0gdG9IYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIHRvSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgdG9IYW5kbGU/LnR5cGUgPT09IHR5cGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGluZ0Zyb206IGZyb21IYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIGZyb21IYW5kbGU/LmlkID09PSBoYW5kbGVJZCAmJiBmcm9tSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBjb25uZWN0aW5nVG8sXG4gICAgICAgIGNsaWNrQ29ubmVjdGluZzogY2xpY2tIYW5kbGU/Lm5vZGVJZCA9PT0gbm9kZUlkICYmIGNsaWNrSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgY2xpY2tIYW5kbGU/LnR5cGUgPT09IHR5cGUsXG4gICAgICAgIGlzUG9zc2libGVFbmRIYW5kbGU6IGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgID8gZnJvbUhhbmRsZT8udHlwZSAhPT0gdHlwZVxuICAgICAgICAgICAgOiBub2RlSWQgIT09IGZyb21IYW5kbGU/Lm5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZT8uaWQsXG4gICAgICAgIGNvbm5lY3Rpb25JblByb2Nlc3M6ICEhZnJvbUhhbmRsZSxcbiAgICAgICAgY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWNsaWNrSGFuZGxlLFxuICAgICAgICB2YWxpZDogY29ubmVjdGluZ1RvICYmIGlzVmFsaWQsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBIYW5kbGVDb21wb25lbnQoeyB0eXBlID0gJ3NvdXJjZScsIHBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBpc1ZhbGlkQ29ubmVjdGlvbiwgaXNDb25uZWN0YWJsZSA9IHRydWUsIGlzQ29ubmVjdGFibGVTdGFydCA9IHRydWUsIGlzQ29ubmVjdGFibGVFbmQgPSB0cnVlLCBpZCwgb25Db25uZWN0LCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBvbk1vdXNlRG93biwgb25Ub3VjaFN0YXJ0LCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IGhhbmRsZUlkID0gaWQgfHwgbnVsbDtcbiAgICBjb25zdCBpc1RhcmdldCA9IHR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCB7IGNvbm5lY3RPbkNsaWNrLCBub1BhbkNsYXNzTmFtZSwgcmZJZCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZywgc2hhbGxvdyk7XG4gICAgY29uc3QgeyBjb25uZWN0aW5nRnJvbSwgY29ubmVjdGluZ1RvLCBjbGlja0Nvbm5lY3RpbmcsIGlzUG9zc2libGVFbmRIYW5kbGUsIGNvbm5lY3Rpb25JblByb2Nlc3MsIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzcywgdmFsaWQsIH0gPSB1c2VTdG9yZShjb25uZWN0aW5nU2VsZWN0b3Iobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSksIHNoYWxsb3cpO1xuICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTAnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMCddKCkpO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbm5lY3RFeHRlbmRlZCA9IChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0RWRnZU9wdGlvbnMsIG9uQ29ubmVjdDogb25Db25uZWN0QWN0aW9uLCBoYXNEZWZhdWx0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGVkZ2VQYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0RWRnZU9wdGlvbnMsXG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIHNldEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc2V0RWRnZXMoYWRkRWRnZShlZGdlUGFyYW1zLCBlZGdlcykpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ29ubmVjdEFjdGlvbj8uKGVkZ2VQYXJhbXMpO1xuICAgICAgICBvbkNvbm5lY3Q/LihlZGdlUGFyYW1zKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc01vdXNlVHJpZ2dlcmVkID0gaXNNb3VzZUV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgaWYgKGlzQ29ubmVjdGFibGVTdGFydCAmJlxuICAgICAgICAgICAgKChpc01vdXNlVHJpZ2dlcmVkICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkgfHwgIWlzTW91c2VUcmlnZ2VyZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RvcmUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgWFlIYW5kbGUub25Qb2ludGVyRG93bihldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgICAgIGhhbmRsZURvbU5vZGU6IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogY3VycmVudFN0b3JlLmF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBjdXJyZW50U3RvcmUuZG9tTm9kZSxcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwOiBjdXJyZW50U3RvcmUubm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBsaWI6IGN1cnJlbnRTdG9yZS5saWIsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGZsb3dJZDogY3VycmVudFN0b3JlLnJmSWQsXG4gICAgICAgICAgICAgICAgcGFuQnk6IGN1cnJlbnRTdG9yZS5wYW5CeSxcbiAgICAgICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUuY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogY3VycmVudFN0b3JlLm9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdEVuZDogY3VycmVudFN0b3JlLm9uQ29ubmVjdEVuZCxcbiAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUudXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEV4dGVuZGVkLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBjdXJyZW50U3RvcmUuaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3BlZWQ6IGN1cnJlbnRTdG9yZS5hdXRvUGFuU3BlZWQsXG4gICAgICAgICAgICAgICAgZHJhZ1RocmVzaG9sZDogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25EcmFnVGhyZXNob2xkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW91c2VUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIG9uTW91c2VEb3duPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0Py4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uU3RvcmUsIGxpYiwgcmZJZDogZmxvd0lkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uOiBjb25uZWN0aW9uU3RhdGUsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIW5vZGVJZCB8fCAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlICYmICFpc0Nvbm5lY3RhYmxlU3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSkge1xuICAgICAgICAgICAgb25DbGlja0Nvbm5lY3RTdGFydD8uKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7IG5vZGVJZCwgaGFuZGxlSWQsIGhhbmRsZVR5cGU6IHR5cGUgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiB7IG5vZGVJZCwgdHlwZSwgaWQ6IGhhbmRsZUlkIH0gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gZ2V0SG9zdEZvckVsZW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyID0gaXNWYWxpZENvbm5lY3Rpb24gfHwgaXNWYWxpZENvbm5lY3Rpb25TdG9yZTtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uLCBpc1ZhbGlkIH0gPSBYWUhhbmRsZS5pc1ZhbGlkKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICBoYW5kbGU6IHtcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgaWQ6IGhhbmRsZUlkLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBmcm9tTm9kZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBmcm9tSGFuZGxlSWQ6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLmlkIHx8IG51bGwsXG4gICAgICAgICAgICBmcm9tVHlwZTogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUudHlwZSxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzVmFsaWQgJiYgY29ubmVjdGlvbikge1xuICAgICAgICAgICAgb25Db25uZWN0RXh0ZW5kZWQoY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbkNsb25lID0gc3RydWN0dXJlZENsb25lKGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGRlbGV0ZSBjb25uZWN0aW9uQ2xvbmUuaW5Qcm9ncmVzcztcbiAgICAgICAgY29ubmVjdGlvbkNsb25lLnRvUG9zaXRpb24gPSBjb25uZWN0aW9uQ2xvbmUudG9IYW5kbGUgPyBjb25uZWN0aW9uQ2xvbmUudG9IYW5kbGUucG9zaXRpb24gOiBudWxsO1xuICAgICAgICBvbkNsaWNrQ29ubmVjdEVuZD8uKGV2ZW50LCBjb25uZWN0aW9uQ2xvbmUpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlOiBudWxsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtaGFuZGxlaWRcIjogaGFuZGxlSWQsIFwiZGF0YS1ub2RlaWRcIjogbm9kZUlkLCBcImRhdGEtaGFuZGxlcG9zXCI6IHBvc2l0aW9uLCBcImRhdGEtaWRcIjogYCR7cmZJZH0tJHtub2RlSWR9LSR7aGFuZGxlSWR9LSR7dHlwZX1gLCBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICdyZWFjdC1mbG93X19oYW5kbGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2hhbmRsZS0ke3Bvc2l0aW9ufWAsXG4gICAgICAgICAgICAnbm9kcmFnJyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogIWlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIHRhcmdldDogaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVzdGFydDogaXNDb25uZWN0YWJsZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlZW5kOiBpc0Nvbm5lY3RhYmxlRW5kLFxuICAgICAgICAgICAgICAgIGNsaWNrY29ubmVjdGluZzogY2xpY2tDb25uZWN0aW5nLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmdmcm9tOiBjb25uZWN0aW5nRnJvbSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5ndG86IGNvbm5lY3RpbmdUbyxcbiAgICAgICAgICAgICAgICB2YWxpZCxcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHNob3dzIHdoZXJlIHlvdSBjYW4gc3RhcnQgYSBjb25uZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAgKiBhbmQgd2hlcmUgeW91IGNhbiBlbmQgaXQgd2hpbGUgY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25pbmRpY2F0b3I6IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFjb25uZWN0aW9uSW5Qcm9jZXNzIHx8IGlzUG9zc2libGVFbmRIYW5kbGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChjb25uZWN0aW9uSW5Qcm9jZXNzIHx8IGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzcyA/IGlzQ29ubmVjdGFibGVFbmQgOiBpc0Nvbm5lY3RhYmxlU3RhcnQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIG9uTW91c2VEb3duOiBvblBvaW50ZXJEb3duLCBvblRvdWNoU3RhcnQ6IG9uUG9pbnRlckRvd24sIG9uQ2xpY2s6IGNvbm5lY3RPbkNsaWNrID8gb25DbGljayA6IHVuZGVmaW5lZCwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIFRoZSBgPEhhbmRsZSAvPmAgY29tcG9uZW50IGlzIHVzZWQgaW4geW91ciBbY3VzdG9tIG5vZGVzXSgvbGVhcm4vY3VzdG9taXphdGlvbi9jdXN0b20tbm9kZXMpXG4gKiB0byBkZWZpbmUgY29ubmVjdGlvbiBwb2ludHMuXG4gKlxuICpAcHVibGljXG4gKlxuICpAZXhhbXBsZVxuICpcbiAqYGBganN4XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24gfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21Ob2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogJzEwcHggMjBweCcgfX0+XG4gKiAgICAgICAge2RhdGEubGFiZWx9XG4gKiAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKmBgYFxuICovXG5jb25zdCBIYW5kbGUgPSBtZW1vKGZpeGVkRm9yd2FyZFJlZihIYW5kbGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gSW5wdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20gfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2RhdGE/LmxhYmVsLCBqc3goSGFuZGxlLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KV0gfSkpO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gR3JvdXBOb2RlKCkge1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBPdXRwdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbF0gfSkpO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbmNvbnN0IGJ1aWx0aW5Ob2RlVHlwZXMgPSB7XG4gICAgaW5wdXQ6IElucHV0Tm9kZSxcbiAgICBkZWZhdWx0OiBEZWZhdWx0Tm9kZSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUsXG4gICAgZ3JvdXA6IEdyb3VwTm9kZSxcbn07XG5mdW5jdGlvbiBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICBpZiAobm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IG5vZGUuc3R5bGU/LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLnN0eWxlPy5oZWlnaHQsXG4gICAgfTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkZiA9IChzKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwge1xuICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhIW5vZGUuc2VsZWN0ZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGlzTnVtZXJpYyh3aWR0aCkgPyB3aWR0aCA6IG51bGwsXG4gICAgICAgIGhlaWdodDogaXNOdW1lcmljKGhlaWdodCkgPyBoZWlnaHQgOiBudWxsLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgIHRyYW5zZm9ybVN0cmluZzogYHRyYW5zbGF0ZSgke3MudHJhbnNmb3JtWzBdfXB4LCR7cy50cmFuc2Zvcm1bMV19cHgpIHNjYWxlKCR7cy50cmFuc2Zvcm1bMl19KSB0cmFuc2xhdGUoJHt4fXB4LCR7eX1weClgLFxuICAgIH07XG59O1xuZnVuY3Rpb24gTm9kZXNTZWxlY3Rpb24oeyBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZiwgc2hhbGxvdyk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlLmdldFN0YXRlKCkubm9kZXMuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUoZXZlbnQsIHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uJywgJ3JlYWN0LWZsb3dfX2NvbnRhaW5lcicsIG5vUGFuQ2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0cmluZyxcbiAgICAgICAgfSwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHJlZjogbm9kZVJlZiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uLXJlY3RcIiwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudSwgdGFiSW5kZXg6IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiAtMSwgb25LZXlEb3duOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogb25LZXlEb3duLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIH0gfSkgfSkpO1xufVxuXG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbmNvbnN0IHNlbGVjdG9yJGUgPSAocykgPT4ge1xuICAgIHJldHVybiB7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBzLm5vZGVzU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUgfTtcbn07XG5mdW5jdGlvbiBGbG93UmVuZGVyZXJDb21wb25lbnQoeyBjaGlsZHJlbiwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogX3Bhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6IF9wYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIH0pIHtcbiAgICBjb25zdCB7IG5vZGVzU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uQWN0aXZlIH0gPSB1c2VTdG9yZShzZWxlY3RvciRlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moc2VsZWN0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHBhbkFjdGl2YXRpb25LZXlDb2RlLCB7IHRhcmdldDogd2luIH0pO1xuICAgIGNvbnN0IHBhbk9uRHJhZyA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PbkRyYWc7XG4gICAgY29uc3QgcGFuT25TY3JvbGwgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25TY3JvbGw7XG4gICAgY29uc3QgX3NlbGVjdGlvbk9uRHJhZyA9IHNlbGVjdGlvbk9uRHJhZyAmJiBwYW5PbkRyYWcgIT09IHRydWU7XG4gICAgY29uc3QgaXNTZWxlY3RpbmcgPSBzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHVzZXJTZWxlY3Rpb25BY3RpdmUgfHwgX3NlbGVjdGlvbk9uRHJhZztcbiAgICB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlIH0pO1xuICAgIHJldHVybiAoanN4KFpvb21QYW5lLCB7IG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiAhc2VsZWN0aW9uS2V5UHJlc3NlZCAmJiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZTogb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQ6IGlzQ29udHJvbGxlZFZpZXdwb3J0LCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGNoaWxkcmVuOiBqc3hzKFBhbmUsIHsgb25TZWxlY3Rpb25TdGFydDogb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQ6IG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgaXNTZWxlY3Rpbmc6ICEhaXNTZWxlY3RpbmcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIHNlbGVjdGlvbktleVByZXNzZWQ6IHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk9uRHJhZzogX3NlbGVjdGlvbk9uRHJhZywgY2hpbGRyZW46IFtjaGlsZHJlbiwgbm9kZXNTZWxlY3Rpb25BY3RpdmUgJiYgKGpzeChOb2Rlc1NlbGVjdGlvbiwgeyBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSkpXSB9KSB9KSk7XG59XG5GbG93UmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRmxvd1JlbmRlcmVyJztcbmNvbnN0IEZsb3dSZW5kZXJlciA9IG1lbW8oRmxvd1JlbmRlcmVyQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3IkZCA9IChvbmx5UmVuZGVyVmlzaWJsZSkgPT4gKHMpID0+IHtcbiAgICByZXR1cm4gb25seVJlbmRlclZpc2libGVcbiAgICAgICAgPyBnZXROb2Rlc0luc2lkZShzLm5vZGVMb29rdXAsIHsgeDogMCwgeTogMCwgd2lkdGg6IHMud2lkdGgsIGhlaWdodDogcy5oZWlnaHQgfSwgcy50cmFuc2Zvcm0sIHRydWUpLm1hcCgobm9kZSkgPT4gbm9kZS5pZClcbiAgICAgICAgOiBBcnJheS5mcm9tKHMubm9kZUxvb2t1cC5rZXlzKCkpO1xufTtcbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB0aGUgdmlzaWJsZSBub2RlIGlkcyBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvbmx5UmVuZGVyVmlzaWJsZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIG5vZGUgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZVZpc2libGVOb2RlSWRzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKHNlbGVjdG9yJGQob25seVJlbmRlclZpc2libGUpLCBbb25seVJlbmRlclZpc2libGVdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIG5vZGVJZHM7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGMgPSAocykgPT4gcy51cGRhdGVOb2RlSW50ZXJuYWxzO1xuZnVuY3Rpb24gdXNlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgY29uc3QgdXBkYXRlTm9kZUludGVybmFscyA9IHVzZVN0b3JlKHNlbGVjdG9yJGMpO1xuICAgIGNvbnN0IFtyZXNpemVPYnNlcnZlcl0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZW50cnkudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KGlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBub2RlRWxlbWVudDogZW50cnkudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW3Jlc2l6ZU9ic2VydmVyXSk7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gaGFuZGxlIHRoZSByZXNpemUgb2JzZXJ2YXRpb24gKyBpbnRlcm5hbCB1cGRhdGVzIGZvciB0aGUgcGFzc2VkIG5vZGUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBub2RlUmVmIC0gcmVmZXJlbmNlIHRvIHRoZSBub2RlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZU9ic2VydmVyKHsgbm9kZSwgbm9kZVR5cGUsIGhhc0RpbWVuc2lvbnMsIHJlc2l6ZU9ic2VydmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgb2JzZXJ2ZWROb2RlID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHByZXZTb3VyY2VQb3NpdGlvbiA9IHVzZVJlZihub2RlLnNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCBwcmV2VGFyZ2V0UG9zaXRpb24gPSB1c2VSZWYobm9kZS50YXJnZXRQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlR5cGUgPSB1c2VSZWYobm9kZVR5cGUpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSBoYXNEaW1lbnNpb25zICYmICEhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgIW5vZGUuaGlkZGVuICYmICghaXNJbml0aWFsaXplZCB8fCBvYnNlcnZlZE5vZGUuY3VycmVudCAhPT0gbm9kZVJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShvYnNlcnZlZE5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZShub2RlUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgPSBub2RlUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9LCBbaXNJbml0aWFsaXplZCwgbm9kZS5oaWRkZW5dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShvYnNlcnZlZE5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogd2hlbiB0aGUgdXNlciBwcm9ncmFtbWF0aWNhbGx5IGNoYW5nZXMgdGhlIHNvdXJjZSBvciBoYW5kbGUgcG9zaXRpb24sIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBpbnRlcm5hbHNcbiAgICAgICAgICAgICAqIHRvIG1ha2Ugc3VyZSB0aGUgZWRnZXMgYXJlIHVwZGF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHR5cGVDaGFuZ2VkID0gcHJldlR5cGUuY3VycmVudCAhPT0gbm9kZVR5cGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb3NDaGFuZ2VkID0gcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgIT09IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb3NDaGFuZ2VkID0gcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgIT09IG5vZGUudGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICBpZiAodHlwZUNoYW5nZWQgfHwgc291cmNlUG9zQ2hhbmdlZCB8fCB0YXJnZXRQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcHJldlR5cGUuY3VycmVudCA9IG5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ID0gbm9kZS5zb3VyY2VQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwcmV2VGFyZ2V0UG9zaXRpb24uY3VycmVudCA9IG5vZGUudGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZU5vZGVJbnRlcm5hbHMobmV3IE1hcChbW25vZGUuaWQsIHsgaWQ6IG5vZGUuaWQsIG5vZGVFbGVtZW50OiBub2RlUmVmLmN1cnJlbnQsIGZvcmNlOiB0cnVlIH1dXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW25vZGUuaWQsIG5vZGVUeXBlLCBub2RlLnNvdXJjZVBvc2l0aW9uLCBub2RlLnRhcmdldFBvc2l0aW9uXSk7XG4gICAgcmV0dXJuIG5vZGVSZWY7XG59XG5cbmZ1bmN0aW9uIE5vZGVXcmFwcGVyKHsgaWQsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudSwgb25Eb3VibGVDbGljaywgbm9kZXNEcmFnZ2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIHJlc2l6ZU9ic2VydmVyLCBub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkLCBub2RlVHlwZXMsIG5vZGVDbGlja0Rpc3RhbmNlLCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCBpbnRlcm5hbHMsIGlzUGFyZW50IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IGlzUGFyZW50ID0gcy5wYXJlbnRMb29rdXAuaGFzKGlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBpbnRlcm5hbHM6IG5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgaXNQYXJlbnQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgbGV0IG5vZGVUeXBlID0gbm9kZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICBsZXQgTm9kZUNvbXBvbmVudCA9IG5vZGVUeXBlcz8uW25vZGVUeXBlXSB8fCBidWlsdGluTm9kZVR5cGVzW25vZGVUeXBlXTtcbiAgICBpZiAoTm9kZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDAzJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDMnXShub2RlVHlwZSkpO1xuICAgICAgICBub2RlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgTm9kZUNvbXBvbmVudCA9IG5vZGVUeXBlcz8uWydkZWZhdWx0J10gfHwgYnVpbHRpbk5vZGVUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhKG5vZGUuZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbm9kZS5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEobm9kZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIG5vZGUuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gISEobm9kZS5jb25uZWN0YWJsZSB8fCAobm9kZXNDb25uZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5jb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKG5vZGUuZm9jdXNhYmxlIHx8IChub2Rlc0ZvY3VzYWJsZSAmJiB0eXBlb2Ygbm9kZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhc0RpbWVuc2lvbnMgPSBub2RlSGFzRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlTm9kZU9ic2VydmVyKHsgbm9kZSwgbm9kZVR5cGUsIGhhc0RpbWVuc2lvbnMsIHJlc2l6ZU9ic2VydmVyIH0pO1xuICAgIGNvbnN0IGRyYWdnaW5nID0gdXNlRHJhZyh7XG4gICAgICAgIG5vZGVSZWYsXG4gICAgICAgIGRpc2FibGVkOiBub2RlLmhpZGRlbiB8fCAhaXNEcmFnZ2FibGUsXG4gICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgaGFuZGxlU2VsZWN0b3I6IG5vZGUuZHJhZ0hhbmRsZSxcbiAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICB9KTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0ZWROb2RlcyA9IHVzZU1vdmVTZWxlY3RlZE5vZGVzKCk7XG4gICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IGlubGluZURpbWVuc2lvbnMgPSBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IGhhc1BvaW50ZXJFdmVudHMgPSBpc1NlbGVjdGFibGUgfHwgaXNEcmFnZ2FibGUgfHwgb25DbGljayB8fCBvbk1vdXNlRW50ZXIgfHwgb25Nb3VzZU1vdmUgfHwgb25Nb3VzZUxlYXZlO1xuICAgIGNvbnN0IG9uTW91c2VFbnRlckhhbmRsZXIgPSBvbk1vdXNlRW50ZXJcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VFbnRlcihldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmVIYW5kbGVyID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTGVhdmVIYW5kbGVyID0gb25Nb3VzZUxlYXZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTGVhdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnVIYW5kbGVyID0gb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4gb25Db250ZXh0TWVudShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Eb3VibGVDbGlja0hhbmRsZXIgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblNlbGVjdE5vZGVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmICghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzRHJhZ2dhYmxlIHx8IG5vZGVEcmFnVGhyZXNob2xkID4gMCkpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB0aGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgYnkgWFlEcmFnIG9uIGRyYWcgc3RhcnQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz10cnVlXG4gICAgICAgICAgICAgKiBoZXJlIHdlIG9ubHkgbmVlZCB0byBjYWxsIGl0IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzSW5wdXRET01Ob2RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSB8fCBkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIHVuc2VsZWN0LFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RyYWdnYWJsZSAmJiBub2RlLnNlbGVjdGVkICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRlZmF1bHQgc2Nyb2xsaW5nIGJlaGF2aW9yIG9uIGFycm93IGtleSBwcmVzcyB3aGVuIG5vZGUgaXMgbW92ZWRcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGFyaWFMYWJlbENvbmZpZyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2U6IGFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24uYXJpYUxpdmVNZXNzYWdlJ10oe1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGV2ZW50LmtleS5yZXBsYWNlKCdBcnJvdycsICcnKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICB4OiB+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IH5+aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkZvY3VzID0gKCkgPT4ge1xuICAgICAgICBpZiAoZGlzYWJsZUtleWJvYXJkQTExeSB8fCAhbm9kZVJlZi5jdXJyZW50Py5tYXRjaGVzKCc6Zm9jdXMtdmlzaWJsZScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIGF1dG9QYW5Pbk5vZGVGb2N1cywgc2V0Q2VudGVyIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWF1dG9QYW5Pbk5vZGVGb2N1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpdGhpblZpZXdwb3J0ID0gZ2V0Tm9kZXNJbnNpZGUobmV3IE1hcChbW2lkLCBub2RlXV0pLCB7IHg6IDAsIHk6IDAsIHdpZHRoLCBoZWlnaHQgfSwgdHJhbnNmb3JtLCB0cnVlKS5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoIXdpdGhpblZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzZXRDZW50ZXIobm9kZS5wb3NpdGlvbi54ICsgbm9kZURpbWVuc2lvbnMud2lkdGggLyAyLCBub2RlLnBvc2l0aW9uLnkgKyBub2RlRGltZW5zaW9ucy5oZWlnaHQgLyAyLCB7XG4gICAgICAgICAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19fbm9kZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19fbm9kZS0ke25vZGVUeXBlfWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvdmVyd3JpdGFibGUgYnkgcGFzc2luZyBgbm9wYW5gIGFzIGEgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgIFtub1BhbkNsYXNzTmFtZV06IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBub2RlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlzUGFyZW50LFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSwgcmVmOiBub2RlUmVmLCBzdHlsZToge1xuICAgICAgICAgICAgekluZGV4OiBpbnRlcm5hbHMueixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2ludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnh9cHgsJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55fXB4KWAsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBoYXNQb2ludGVyRXZlbnRzID8gJ2FsbCcgOiAnbm9uZScsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBoYXNEaW1lbnNpb25zID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAuLi5ub2RlLnN0eWxlLFxuICAgICAgICAgICAgLi4uaW5saW5lRGltZW5zaW9ucyxcbiAgICAgICAgfSwgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fbm9kZS0ke2lkfWAsIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVySGFuZGxlciwgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlSGFuZGxlciwgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVIYW5kbGVyLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51SGFuZGxlciwgb25DbGljazogb25TZWxlY3ROb2RlSGFuZGxlciwgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGlja0hhbmRsZXIsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIG9uRm9jdXM6IGlzRm9jdXNhYmxlID8gb25Gb2N1cyA6IHVuZGVmaW5lZCwgcm9sZTogbm9kZS5hcmlhUm9sZSA/PyAoaXNGb2N1c2FibGUgPyAnZ3JvdXAnIDogdW5kZWZpbmVkKSwgXCJhcmlhLXJvbGVkZXNjcmlwdGlvblwiOiBcIm5vZGVcIiwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBcImFyaWEtbGFiZWxcIjogbm9kZS5hcmlhTGFiZWwsIC4uLm5vZGUuZG9tQXR0cmlidXRlcywgY2hpbGRyZW46IGpzeChQcm92aWRlciwgeyB2YWx1ZTogaWQsIGNoaWxkcmVuOiBqc3goTm9kZUNvbXBvbmVudCwgeyBpZDogaWQsIGRhdGE6IG5vZGUuZGF0YSwgdHlwZTogbm9kZVR5cGUsIHBvc2l0aW9uQWJzb2x1dGVYOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LCBwb3NpdGlvbkFic29sdXRlWTogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSwgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQgPz8gZmFsc2UsIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSwgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSwgZGVsZXRhYmxlOiBub2RlLmRlbGV0YWJsZSA/PyB0cnVlLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLCBzb3VyY2VQb3NpdGlvbjogbm9kZS5zb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IG5vZGUudGFyZ2V0UG9zaXRpb24sIGRyYWdnaW5nOiBkcmFnZ2luZywgZHJhZ0hhbmRsZTogbm9kZS5kcmFnSGFuZGxlLCB6SW5kZXg6IGludGVybmFscy56LCBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCwgLi4ubm9kZURpbWVuc2lvbnMgfSkgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRiID0gKHMpID0+ICh7XG4gICAgbm9kZXNEcmFnZ2FibGU6IHMubm9kZXNEcmFnZ2FibGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiBzLm5vZGVzRm9jdXNhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBOb2RlUmVuZGVyZXJDb21wb25lbnQocHJvcHMpIHtcbiAgICBjb25zdCB7IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlVmlzaWJsZU5vZGVJZHMocHJvcHMub25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBOb2RlUmVuZGVyZXIgYW5kXG4gICAgICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiB5b3XigJlyZSBkcmFnZ2luZyBhIHNpbmdsZSBub2RlLCB0aGF0IG5vZGUgZ2V0c1xuICAgICAgICAgICAgICogdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBwZXIgc2Vjb25kLiBJZiBgTm9kZVJlbmRlcmVyYCB3ZXJlIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICogZXZlcnkgdGltZSwgaXQgd291bGQgaGF2ZSB0byByZS1ydW4gdGhlIGBub2Rlcy5tYXAoKWAgbG9vcCBldmVyeVxuICAgICAgICAgICAgICogdGltZS4gVGhpcyBnZXRzIHByaWNleSB3aXRoIGh1bmRyZWRzIG9mIG5vZGVzLCBlc3BlY2lhbGx5IGlmIGV2ZXJ5XG4gICAgICAgICAgICAgKiBsb29wIGN5Y2xlIGRvZXMgbW9yZSB0aGFuIGp1c3QgcmVuZGVyaW5nIGEgSlNYIGVsZW1lbnQhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQXMgYSByZXN1bHQgb2YgdGhpcyBjaG9pY2UsIHdlIHRvb2sgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICogZGVjaXNpb25zOlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgc3Vic2NyaWJlcyAqb25seSogdG8gbm9kZSBJRHMg4oCTIGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAqICAgcmVyZW5kZXIgKm9ubHkqIHdoZW4gdmlzaWJsZSBub2RlcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgICAgICAgICAqIC0gTm9kZVJlbmRlcmVyIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIHRoZSByZXN1bHQgb2Ygd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAgKiAgIHNoYXJlZCBiZXR3ZWVuIG5vZGVzIChzdWNoIGFzIGNyZWF0aW5nIHRoZSBgUmVzaXplT2JzZXJ2ZXJgXG4gICAgICAgICAgICAgKiAgIGluc3RhbmNlLCBvciBzdWJzY3JpYmluZyB0byBgc2VsZWN0b3JgKS4gVGhpcyBtZWFucyBleHRyYSBwcm9wXG4gICAgICAgICAgICAgKiAgIGRyaWxsaW5nIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYCwgYnV0IGl0IG1lYW5zIHdlIG5lZWQgdG8gcnVuXG4gICAgICAgICAgICAgKiAgIHRoZXNlIG9wZXJhdGlvbnMgb25seSBvbmNlIOKAkyBpbnN0ZWFkIG9mIG9uY2UgcGVyIG5vZGUuXG4gICAgICAgICAgICAgKiAtIEFueSBvcGVyYXRpb25zIHRoYXQgeW914oCZZCBub3JtYWxseSB3cml0ZSBpbnNpZGUgYG5vZGVzLm1hcGAgYXJlXG4gICAgICAgICAgICAgKiAgIG1vdmVkIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYC4gVGhpcyBlbnN1cmVzIHRoZXkgYXJlXG4gICAgICAgICAgICAgKiAgIG1lbW9yaXplZCDigJMgc28gaWYgYE5vZGVSZW5kZXJlcmAgKmhhcyogdG8gcmVyZW5kZXIsIGl0IG9ubHlcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gcmVnZW5lcmF0ZSB0aGUgbGlzdCBvZiBub2Rlcywgbm90aGluZyBlbHNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBqc3goTm9kZVdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZVR5cGVzOiBwcm9wcy5ub2RlVHlwZXMsIG5vZGVFeHRlbnQ6IHByb3BzLm5vZGVFeHRlbnQsIG9uQ2xpY2s6IHByb3BzLm9uTm9kZUNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTm9kZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBwcm9wcy5vbk5vZGVNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogcHJvcHMub25Ob2RlTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudTogcHJvcHMub25Ob2RlQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2s6IHByb3BzLm9uTm9kZURvdWJsZUNsaWNrLCBub0RyYWdDbGFzc05hbWU6IHByb3BzLm5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IHByb3BzLm5vUGFuQ2xhc3NOYW1lLCByZklkOiBwcm9wcy5yZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBwcm9wcy5kaXNhYmxlS2V5Ym9hcmRBMTF5LCByZXNpemVPYnNlcnZlcjogcmVzaXplT2JzZXJ2ZXIsIG5vZGVzRHJhZ2dhYmxlOiBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9kZUNsaWNrRGlzdGFuY2U6IHByb3BzLm5vZGVDbGlja0Rpc3RhbmNlLCBvbkVycm9yOiBvbkVycm9yIH0sIG5vZGVJZCkpO1xuICAgICAgICB9KSB9KSk7XG59XG5Ob2RlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTm9kZVJlbmRlcmVyJztcbmNvbnN0IE5vZGVSZW5kZXJlciA9IG1lbW8oTm9kZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIGVkZ2UgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgZWRnZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZUVkZ2VJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBlZGdlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgaWYgKCFvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHMuZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlRWRnZUlkcyA9IFtdO1xuICAgICAgICBpZiAocy53aWR0aCAmJiBzLmhlaWdodCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIHMuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNFZGdlVmlzaWJsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVFZGdlSWRzLnB1c2goZWRnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlRWRnZUlkcztcbiAgICB9LCBbb25seVJlbmRlclZpc2libGVdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VJZHM7XG59XG5cbmNvbnN0IEFycm93U3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAuLi4oY29sb3IgJiYgeyBzdHJva2U6IGNvbG9yIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IGNsYXNzTmFtZTogXCJhcnJvd1wiLCBzdHlsZTogc3R5bGUsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNFwiIH0pKTtcbn07XG5jb25zdCBBcnJvd0Nsb3NlZFN5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgLi4uKGNvbG9yICYmIHsgc3Ryb2tlOiBjb2xvciwgZmlsbDogY29sb3IgfSksXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcInBvbHlsaW5lXCIsIHsgY2xhc3NOYW1lOiBcImFycm93Y2xvc2VkXCIsIHN0eWxlOiBzdHlsZSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDQgLTUsLTRcIiB9KSk7XG59O1xuY29uc3QgTWFya2VyU3ltYm9scyA9IHtcbiAgICBbTWFya2VyVHlwZS5BcnJvd106IEFycm93U3ltYm9sLFxuICAgIFtNYXJrZXJUeXBlLkFycm93Q2xvc2VkXTogQXJyb3dDbG9zZWRTeW1ib2wsXG59O1xuZnVuY3Rpb24gdXNlTWFya2VyU3ltYm9sKHR5cGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ltYm9sID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bWJvbEV4aXN0cyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNYXJrZXJTeW1ib2xzLCB0eXBlKTtcbiAgICAgICAgaWYgKCFzeW1ib2xFeGlzdHMpIHtcbiAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMDknLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwOSddKHR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXJrZXJTeW1ib2xzW3R5cGVdO1xuICAgIH0sIFt0eXBlXSk7XG4gICAgcmV0dXJuIHN5bWJvbDtcbn1cblxuY29uc3QgTWFya2VyID0gKHsgaWQsIHR5cGUsIGNvbG9yLCB3aWR0aCA9IDEyLjUsIGhlaWdodCA9IDEyLjUsIG1hcmtlclVuaXRzID0gJ3N0cm9rZVdpZHRoJywgc3Ryb2tlV2lkdGgsIG9yaWVudCA9ICdhdXRvLXN0YXJ0LXJldmVyc2UnLCB9KSA9PiB7XG4gICAgY29uc3QgU3ltYm9sID0gdXNlTWFya2VyU3ltYm9sKHR5cGUpO1xuICAgIGlmICghU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcIm1hcmtlclwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hcnJvd2hlYWRcIiwgaWQ6IGlkLCBtYXJrZXJXaWR0aDogYCR7d2lkdGh9YCwgbWFya2VySGVpZ2h0OiBgJHtoZWlnaHR9YCwgdmlld0JveDogXCItMTAgLTEwIDIwIDIwXCIsIG1hcmtlclVuaXRzOiBtYXJrZXJVbml0cywgb3JpZW50OiBvcmllbnQsIHJlZlg6IFwiMFwiLCByZWZZOiBcIjBcIiwgY2hpbGRyZW46IGpzeChTeW1ib2wsIHsgY29sb3I6IGNvbG9yLCBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggfSkgfSkpO1xufTtcbi8qXG4gKiB3aGVuIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIGEgcGFnZSBhbmQgeW91IGhpZGUgdGhlIGZpcnN0IG9uZSwgdGhlIG90aGVyIG9uZXMgaGF2ZSBubyBtYXJrZXJzIGFueW1vcmVcbiAqIHdoZW4gdGhleSBkbyBoYXZlIG1hcmtlcnMgd2l0aCB0aGUgc2FtZSBpZHMuIFRvIHByZXZlbnQgdGhpcyB0aGUgdXNlciBjYW4gcGFzcyBhIHVuaXF1ZSBpZCB0byB0aGUgcmVhY3QgZmxvdyB3cmFwcGVyXG4gKiB0aGF0IHdlIGNhbiB0aGVuIHVzZSBmb3IgY3JlYXRpbmcgb3VyIHVuaXF1ZSBtYXJrZXIgaWRzXG4gKi9cbmNvbnN0IE1hcmtlckRlZmluaXRpb25zID0gKHsgZGVmYXVsdENvbG9yLCByZklkIH0pID0+IHtcbiAgICBjb25zdCBlZGdlcyA9IHVzZVN0b3JlKChzKSA9PiBzLmVkZ2VzKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGNvbnN0IG1hcmtlcnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IGNyZWF0ZU1hcmtlcklkcyhlZGdlcywge1xuICAgICAgICAgICAgaWQ6IHJmSWQsXG4gICAgICAgICAgICBkZWZhdWx0Q29sb3IsXG4gICAgICAgICAgICBkZWZhdWx0TWFya2VyU3RhcnQ6IGRlZmF1bHRFZGdlT3B0aW9ucz8ubWFya2VyU3RhcnQsXG4gICAgICAgICAgICBkZWZhdWx0TWFya2VyRW5kOiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlckVuZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtlZGdlcywgZGVmYXVsdEVkZ2VPcHRpb25zLCByZklkLCBkZWZhdWx0Q29sb3JdKTtcbiAgICBpZiAoIW1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19tYXJrZXJcIiwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2hpbGRyZW46IGpzeChcImRlZnNcIiwgeyBjaGlsZHJlbjogbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gKGpzeChNYXJrZXIsIHsgaWQ6IG1hcmtlci5pZCwgdHlwZTogbWFya2VyLnR5cGUsIGNvbG9yOiBtYXJrZXIuY29sb3IsIHdpZHRoOiBtYXJrZXIud2lkdGgsIGhlaWdodDogbWFya2VyLmhlaWdodCwgbWFya2VyVW5pdHM6IG1hcmtlci5tYXJrZXJVbml0cywgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCwgb3JpZW50OiBtYXJrZXIub3JpZW50IH0sIG1hcmtlci5pZCkpKSB9KSB9KSk7XG59O1xuTWFya2VyRGVmaW5pdGlvbnMuZGlzcGxheU5hbWUgPSAnTWFya2VyRGVmaW5pdGlvbnMnO1xudmFyIE1hcmtlckRlZmluaXRpb25zJDEgPSBtZW1vKE1hcmtlckRlZmluaXRpb25zKTtcblxuZnVuY3Rpb24gRWRnZVRleHRDb21wb25lbnQoeyB4LCB5LCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcgPSB0cnVlLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nID0gWzIsIDRdLCBsYWJlbEJnQm9yZGVyUmFkaXVzID0gMiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgW2VkZ2VUZXh0QmJveCwgc2V0RWRnZVRleHRCYm94XSA9IHVzZVN0YXRlKHsgeDogMSwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBjb25zdCBlZGdlVGV4dENsYXNzZXMgPSBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdGV4dHdyYXBwZXInLCBjbGFzc05hbWVdKTtcbiAgICBjb25zdCBlZGdlVGV4dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRnZVRleHRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEJib3ggPSBlZGdlVGV4dFJlZi5jdXJyZW50LmdldEJCb3goKTtcbiAgICAgICAgICAgIHNldEVkZ2VUZXh0QmJveCh7XG4gICAgICAgICAgICAgICAgeDogdGV4dEJib3gueCxcbiAgICAgICAgICAgICAgICB5OiB0ZXh0QmJveC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0QmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRCYm94LmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2xhYmVsXSk7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKFwiZ1wiLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3ggLSBlZGdlVGV4dEJib3gud2lkdGggLyAyfSAke3kgLSBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMn0pYCwgY2xhc3NOYW1lOiBlZGdlVGV4dENsYXNzZXMsIHZpc2liaWxpdHk6IGVkZ2VUZXh0QmJveC53aWR0aCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLCAuLi5yZXN0LCBjaGlsZHJlbjogW2xhYmVsU2hvd0JnICYmIChqc3goXCJyZWN0XCIsIHsgd2lkdGg6IGVkZ2VUZXh0QmJveC53aWR0aCArIDIgKiBsYWJlbEJnUGFkZGluZ1swXSwgeDogLWxhYmVsQmdQYWRkaW5nWzBdLCB5OiAtbGFiZWxCZ1BhZGRpbmdbMV0sIGhlaWdodDogZWRnZVRleHRCYm94LmhlaWdodCArIDIgKiBsYWJlbEJnUGFkZGluZ1sxXSwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dGJnXCIsIHN0eWxlOiBsYWJlbEJnU3R5bGUsIHJ4OiBsYWJlbEJnQm9yZGVyUmFkaXVzLCByeTogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSksIGpzeChcInRleHRcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS10ZXh0XCIsIHk6IGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyLCBkeTogXCIwLjNlbVwiLCByZWY6IGVkZ2VUZXh0UmVmLCBzdHlsZTogbGFiZWxTdHlsZSwgY2hpbGRyZW46IGxhYmVsIH0pLCBjaGlsZHJlbl0gfSkpO1xufVxuRWRnZVRleHRDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVRleHQnO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGUgYDxFZGdlVGV4dCAvPmAgY29tcG9uZW50IGFzIGEgaGVscGVyIGNvbXBvbmVudCB0byBkaXNwbGF5IHRleHRcbiAqIHdpdGhpbiB5b3VyIGN1c3RvbSBlZGdlcy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgRWRnZVRleHQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZUxhYmVsKHsgbGFiZWwgfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxFZGdlVGV4dFxuICogICAgICAgeD17MTAwfVxuICogICAgICAgeT17MTAwfVxuICogICAgICAgbGFiZWw9e2xhYmVsfVxuICogICAgICAgbGFiZWxTdHlsZT17eyBmaWxsOiAnd2hpdGUnIH19XG4gKiAgICAgICBsYWJlbFNob3dCZ1xuICogICAgICAgbGFiZWxCZ1N0eWxlPXt7IGZpbGw6ICdyZWQnIH19XG4gKiAgICAgICBsYWJlbEJnUGFkZGluZz17WzIsIDRdfVxuICogICAgICAgbGFiZWxCZ0JvcmRlclJhZGl1cz17Mn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICpgYGBcbiAqL1xuY29uc3QgRWRnZVRleHQgPSBtZW1vKEVkZ2VUZXh0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgYDxCYXNlRWRnZSAvPmAgY29tcG9uZW50IGdldHMgdXNlZCBpbnRlcm5hbGx5IGZvciBhbGwgdGhlIGVkZ2VzLiBJdCBjYW4gYmVcbiAqIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgYW5kIGhhbmRsZXMgdGhlIGludmlzaWJsZSBoZWxwZXIgZWRnZSBhbmQgdGhlIGVkZ2UgbGFiZWxcbiAqIGZvciB5b3UuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBCYXNlRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCAuLi5wcm9wcyB9KSB7XG4gKiAgY29uc3QgW2VkZ2VQYXRoXSA9IGdldFN0cmFpZ2h0UGF0aCh7XG4gKiAgICBzb3VyY2VYLFxuICogICAgc291cmNlWSxcbiAqICAgIHRhcmdldFgsXG4gKiAgICB0YXJnZXRZLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gPEJhc2VFZGdlIHBhdGg9e2VkZ2VQYXRofSB7Li4ucHJvcHN9IC8+O1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIElmIHlvdSB3YW50IHRvIHVzZSBhbiBlZGdlIG1hcmtlciB3aXRoIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQsXG4gKiB5b3UgY2FuIHBhc3MgdGhlIGBtYXJrZXJTdGFydGAgb3IgYG1hcmtlckVuZGAgcHJvcHMgcGFzc2VkIHRvIHlvdXIgY3VzdG9tIGVkZ2VcbiAqIHRocm91Z2ggdG8gdGhlIFtgPEJhc2VFZGdlIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9iYXNlLWVkZ2UpIGNvbXBvbmVudC5cbiAqIFlvdSBjYW4gc2VlIGFsbCB0aGUgcHJvcHMgcGFzc2VkIHRvIGEgY3VzdG9tIGVkZ2UgYnkgbG9va2luZyBhdCB0aGUgW2BFZGdlUHJvcHNgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlLXByb3BzKSB0eXBlLlxuICovXG5mdW5jdGlvbiBCYXNlRWRnZSh7IHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIGludGVyYWN0aW9uV2lkdGggPSAyMCwgLi4ucHJvcHMgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyAuLi5wcm9wcywgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXBhdGgnLCBwcm9wcy5jbGFzc05hbWVdKSB9KSwgaW50ZXJhY3Rpb25XaWR0aCA/IChqc3goXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIHN0cm9rZU9wYWNpdHk6IDAsIHN0cm9rZVdpZHRoOiBpbnRlcmFjdGlvbldpZHRoLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS1pbnRlcmFjdGlvblwiIH0pKSA6IG51bGwsIGxhYmVsICYmIGlzTnVtZXJpYyhsYWJlbFgpICYmIGlzTnVtZXJpYyhsYWJlbFkpID8gKGpzeChFZGdlVGV4dCwgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpIDogbnVsbF0gfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG4vKipcbiAqIFRoZSBgZ2V0U2ltcGxlQmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc2ltcGxlXG4gKiBiZXppZXIgZWRnZSBiZXR3ZWVuIHR3byBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICovXG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNpbXBsZUJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU2ltcGxlQmV6aWVyRWRnZSA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU2ltcGxlQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlJztcblNpbXBsZUJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTbW9vdGhTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgb2Zmc2V0OiBwYXRoT3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgICAgICAgc3RlcFBvc2l0aW9uOiBwYXRoT3B0aW9ucz8uc3RlcFBvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc21vb3RoIHN0ZXAgZWRnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU21vb3RoU3RlcEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U21vb3RoU3RlcEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTbW9vdGhTdGVwRWRnZSA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbW9vdGhTdGVwRWRnZUludGVybmFsID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU21vb3RoU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2UnO1xuU21vb3RoU3RlcEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU3RlcEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KFNtb290aFN0ZXBFZGdlLCB7IC4uLnByb3BzLCBpZDogX2lkLCBwYXRoT3B0aW9uczogdXNlTWVtbygoKSA9PiAoeyBib3JkZXJSYWRpdXM6IDAsIG9mZnNldDogcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldCB9KSwgW3Byb3BzLnBhdGhPcHRpb25zPy5vZmZzZXRdKSB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIHN0ZXAgZWRnZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU3RlcEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0pIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8U3RlcEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTdGVwRWRnZSA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGVwRWRnZUludGVybmFsID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU3RlcEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2UnO1xuU3RlcEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlU3RyYWlnaHRFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc3RyYWlnaHQgbGluZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgU3RyYWlnaHRFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTdHJhaWdodEVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBTdHJhaWdodEVkZ2UgPSBjcmVhdGVTdHJhaWdodEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0cmFpZ2h0RWRnZUludGVybmFsID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0cmFpZ2h0RWRnZS5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2UnO1xuU3RyYWlnaHRFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGN1cnZhdHVyZTogcGF0aE9wdGlvbnM/LmN1cnZhdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIHRvIHJlbmRlciBhIGJlemllciBjdXJ2ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzeFxuICogaW1wb3J0IHsgQmV6aWVyRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxCZXppZXJFZGdlXG4gKiAgICAgICBzb3VyY2VYPXtzb3VyY2VYfVxuICogICAgICAgc291cmNlWT17c291cmNlWX1cbiAqICAgICAgIHRhcmdldFg9e3RhcmdldFh9XG4gKiAgICAgICB0YXJnZXRZPXt0YXJnZXRZfVxuICogICAgICAgc291cmNlUG9zaXRpb249e3NvdXJjZVBvc2l0aW9ufVxuICogICAgICAgdGFyZ2V0UG9zaXRpb249e3RhcmdldFBvc2l0aW9ufVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgQmV6aWVyRWRnZSA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlJztcbkJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5jb25zdCBidWlsdGluRWRnZVR5cGVzID0ge1xuICAgIGRlZmF1bHQ6IEJlemllckVkZ2VJbnRlcm5hbCxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlSW50ZXJuYWwsXG4gICAgc3RlcDogU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzbW9vdGhzdGVwOiBTbW9vdGhTdGVwRWRnZUludGVybmFsLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLFxufTtcbmNvbnN0IG51bGxQb3NpdGlvbiA9IHtcbiAgICBzb3VyY2VYOiBudWxsLFxuICAgIHNvdXJjZVk6IG51bGwsXG4gICAgdGFyZ2V0WDogbnVsbCxcbiAgICB0YXJnZXRZOiBudWxsLFxuICAgIHNvdXJjZVBvc2l0aW9uOiBudWxsLFxuICAgIHRhcmdldFBvc2l0aW9uOiBudWxsLFxufTtcblxuY29uc3Qgc2hpZnRYID0gKHgsIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdClcbiAgICAgICAgcmV0dXJuIHggLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KVxuICAgICAgICByZXR1cm4geCArIHNoaWZ0O1xuICAgIHJldHVybiB4O1xufTtcbmNvbnN0IHNoaWZ0WSA9ICh5LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlRvcClcbiAgICAgICAgcmV0dXJuIHkgLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHkgKyBzaGlmdDtcbiAgICByZXR1cm4geTtcbn07XG5jb25zdCBFZGdlVXBkYXRlckNsYXNzTmFtZSA9ICdyZWFjdC1mbG93X19lZGdldXBkYXRlcic7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBFZGdlQW5jaG9yKHsgcG9zaXRpb24sIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyA9IDEwLCBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0LCB0eXBlLCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VVcGRhdGVBbmNob3JzKHsgaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXMsIGVkZ2UsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBzZXRSZWNvbm5lY3RpbmcsIHNldFVwZGF0ZUhvdmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhbmRsZUVkZ2VVcGRhdGVyID0gKGV2ZW50LCBvcHBvc2l0ZUhhbmRsZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uQ29ubmVjdCwgZG9tTm9kZSwgaXNWYWxpZENvbm5lY3Rpb24sIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uUmFkaXVzLCBsaWIsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIGNhbmNlbENvbm5lY3Rpb24sIG5vZGVMb29rdXAsIHJmSWQ6IGZsb3dJZCwgcGFuQnksIHVwZGF0ZUNvbm5lY3Rpb24sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpc1RhcmdldCA9IG9wcG9zaXRlSGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnO1xuICAgICAgICBjb25zdCBfb25SZWNvbm5lY3RFbmQgPSAoZXZ0LCBjb25uZWN0aW9uU3RhdGUpID0+IHtcbiAgICAgICAgICAgIHNldFJlY29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZD8uKGV2dCwgZWRnZSwgb3Bwb3NpdGVIYW5kbGUudHlwZSwgY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Db25uZWN0RWRnZSA9IChjb25uZWN0aW9uKSA9PiBvblJlY29ubmVjdD8uKGVkZ2UsIGNvbm5lY3Rpb24pO1xuICAgICAgICBjb25zdCBfb25Db25uZWN0U3RhcnQgPSAoX2V2ZW50LCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHNldFJlY29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0U3RhcnQ/LihldmVudCwgZWRnZSwgb3Bwb3NpdGVIYW5kbGUudHlwZSk7XG4gICAgICAgICAgICBvbkNvbm5lY3RTdGFydD8uKF9ldmVudCwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFlIYW5kbGUub25Qb2ludGVyRG93bihldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgIGRvbU5vZGUsXG4gICAgICAgICAgICBoYW5kbGVJZDogb3Bwb3NpdGVIYW5kbGUuaWQsXG4gICAgICAgICAgICBub2RlSWQ6IG9wcG9zaXRlSGFuZGxlLm5vZGVJZCxcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgIGVkZ2VVcGRhdGVyVHlwZTogb3Bwb3NpdGVIYW5kbGUudHlwZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIGNhbmNlbENvbm5lY3Rpb24sXG4gICAgICAgICAgICBwYW5CeSxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFZGdlLFxuICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ6IF9vbkNvbm5lY3RTdGFydCxcbiAgICAgICAgICAgIG9uQ29ubmVjdEVuZCxcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kOiBfb25SZWNvbm5lY3RFbmQsXG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uLFxuICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIGdldEZyb21IYW5kbGU6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbi5mcm9tSGFuZGxlLFxuICAgICAgICAgICAgZHJhZ1RocmVzaG9sZDogc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uRHJhZ1RocmVzaG9sZCxcbiAgICAgICAgICAgIGhhbmRsZURvbU5vZGU6IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS50YXJnZXQsIGlkOiBlZGdlLnRhcmdldEhhbmRsZSA/PyBudWxsLCB0eXBlOiAndGFyZ2V0JyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnNvdXJjZSwgaWQ6IGVkZ2Uuc291cmNlSGFuZGxlID8/IG51bGwsIHR5cGU6ICdzb3VyY2UnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICdzb3VyY2UnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBjZW50ZXJYOiBzb3VyY2VYLCBjZW50ZXJZOiBzb3VyY2VZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksIChpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAndGFyZ2V0JykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgY2VudGVyWDogdGFyZ2V0WCwgY2VudGVyWTogdGFyZ2V0WSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VXcmFwcGVyKHsgaWQsIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25DbGljaywgb25Eb3VibGVDbGljaywgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25FcnJvciwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGxldCBlZGdlID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZUxvb2t1cC5nZXQoaWQpKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGVkZ2UgPSBkZWZhdWx0RWRnZU9wdGlvbnMgPyB7IC4uLmRlZmF1bHRFZGdlT3B0aW9ucywgLi4uZWRnZSB9IDogZWRnZTtcbiAgICBsZXQgZWRnZVR5cGUgPSBlZGdlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBFZGdlQ29tcG9uZW50ID0gZWRnZVR5cGVzPy5bZWRnZVR5cGVdIHx8IGJ1aWx0aW5FZGdlVHlwZXNbZWRnZVR5cGVdO1xuICAgIGlmIChFZGdlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTEnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMSddKGVkZ2VUeXBlKSk7XG4gICAgICAgIGVkZ2VUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBFZGdlQ29tcG9uZW50ID0gZWRnZVR5cGVzPy5bJ2RlZmF1bHQnXSB8fCBidWlsdGluRWRnZVR5cGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEoZWRnZS5mb2N1c2FibGUgfHwgKGVkZ2VzRm9jdXNhYmxlICYmIHR5cGVvZiBlZGdlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1JlY29ubmVjdGFibGUgPSB0eXBlb2Ygb25SZWNvbm5lY3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIChlZGdlLnJlY29ubmVjdGFibGUgfHwgKGVkZ2VzUmVjb25uZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5yZWNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKGVkZ2Uuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBlZGdlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgZWRnZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBbdXBkYXRlSG92ZXIsIHNldFVwZGF0ZUhvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcmVjb25uZWN0aW5nLCBzZXRSZWNvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHpJbmRleCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0gPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygoc3RvcmUpID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHN0b3JlLm5vZGVMb29rdXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHN0b3JlLm5vZGVMb29rdXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFzb3VyY2VOb2RlIHx8ICF0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHpJbmRleDogZWRnZS56SW5kZXgsXG4gICAgICAgICAgICAgICAgLi4ubnVsbFBvc2l0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSBnZXRFZGdlUG9zaXRpb24oe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogZWRnZS5zb3VyY2VIYW5kbGUgfHwgbnVsbCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogZWRnZS50YXJnZXRIYW5kbGUgfHwgbnVsbCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBzdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB6SW5kZXggPSBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgoe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBlbGV2YXRlT25TZWxlY3Q6IHN0b3JlLmVsZXZhdGVFZGdlc09uU2VsZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIC4uLihlZGdlUG9zaXRpb24gfHwgbnVsbFBvc2l0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9LCBbZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0LCBlZGdlLnNvdXJjZUhhbmRsZSwgZWRnZS50YXJnZXRIYW5kbGUsIGVkZ2Uuc2VsZWN0ZWQsIGVkZ2UuekluZGV4XSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1hcmtlclN0YXJ0VXJsID0gdXNlTWVtbygoKSA9PiAoZWRnZS5tYXJrZXJTdGFydCA/IGB1cmwoJyMke2dldE1hcmtlcklkKGVkZ2UubWFya2VyU3RhcnQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlclN0YXJ0LCByZklkXSk7XG4gICAgY29uc3QgbWFya2VyRW5kVXJsID0gdXNlTWVtbygoKSA9PiAoZWRnZS5tYXJrZXJFbmQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlckVuZCwgcmZJZCl9JylgIDogdW5kZWZpbmVkKSwgW2VkZ2UubWFya2VyRW5kLCByZklkXSk7XG4gICAgaWYgKGVkZ2UuaGlkZGVuIHx8IHNvdXJjZVggPT09IG51bGwgfHwgc291cmNlWSA9PT0gbnVsbCB8fCB0YXJnZXRYID09PSBudWxsIHx8IHRhcmdldFkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uRWRnZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWRFZGdlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbXSwgZWRnZXM6IFtlZGdlXSB9KTtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIGVkZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkVkZ2VEb3VibGVDbGljayA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VDb250ZXh0TWVudSA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZUVudGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZU1vdmUgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZUxlYXZlID0gb25Nb3VzZUxlYXZlXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgYWRkU2VsZWN0ZWRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGlmICh1bnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiB7IHpJbmRleCB9LCBjaGlsZHJlbjoganN4cyhcImdcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICAgICAncmVhY3QtZmxvd19fZWRnZScsXG4gICAgICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2VkZ2UtJHtlZGdlVHlwZX1gLFxuICAgICAgICAgICAgICAgIGVkZ2UuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogIWlzU2VsZWN0YWJsZSAmJiAhb25DbGljayxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRpbmc6IHVwZGF0ZUhvdmVyLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pLCBvbkNsaWNrOiBvbkVkZ2VDbGljaywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgcm9sZTogZWRnZS5hcmlhUm9sZSA/PyAoaXNGb2N1c2FibGUgPyAnZ3JvdXAnIDogJ2ltZycpLCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwiZWRnZVwiLCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19lZGdlLSR7aWR9YCwgXCJhcmlhLWxhYmVsXCI6IGVkZ2UuYXJpYUxhYmVsID09PSBudWxsID8gdW5kZWZpbmVkIDogZWRnZS5hcmlhTGFiZWwgfHwgYEVkZ2UgZnJvbSAke2VkZ2Uuc291cmNlfSB0byAke2VkZ2UudGFyZ2V0fWAsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBpc0ZvY3VzYWJsZSA/IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAgOiB1bmRlZmluZWQsIHJlZjogZWRnZVJlZiwgLi4uZWRnZS5kb21BdHRyaWJ1dGVzLCBjaGlsZHJlbjogWyFyZWNvbm5lY3RpbmcgJiYgKGpzeChFZGdlQ29tcG9uZW50LCB7IGlkOiBpZCwgc291cmNlOiBlZGdlLnNvdXJjZSwgdGFyZ2V0OiBlZGdlLnRhcmdldCwgdHlwZTogZWRnZS50eXBlLCBzZWxlY3RlZDogZWRnZS5zZWxlY3RlZCwgYW5pbWF0ZWQ6IGVkZ2UuYW5pbWF0ZWQsIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSwgZGVsZXRhYmxlOiBlZGdlLmRlbGV0YWJsZSA/PyB0cnVlLCBsYWJlbDogZWRnZS5sYWJlbCwgbGFiZWxTdHlsZTogZWRnZS5sYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogZWRnZS5sYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBlZGdlLmxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGVkZ2UubGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGVkZ2UubGFiZWxCZ0JvcmRlclJhZGl1cywgc291cmNlWDogc291cmNlWCwgc291cmNlWTogc291cmNlWSwgdGFyZ2V0WDogdGFyZ2V0WCwgdGFyZ2V0WTogdGFyZ2V0WSwgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGRhdGE6IGVkZ2UuZGF0YSwgc3R5bGU6IGVkZ2Uuc3R5bGUsIHNvdXJjZUhhbmRsZUlkOiBlZGdlLnNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlSWQ6IGVkZ2UudGFyZ2V0SGFuZGxlLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnRVcmwsIG1hcmtlckVuZDogbWFya2VyRW5kVXJsLCBwYXRoT3B0aW9uczogJ3BhdGhPcHRpb25zJyBpbiBlZGdlID8gZWRnZS5wYXRoT3B0aW9ucyA6IHVuZGVmaW5lZCwgaW50ZXJhY3Rpb25XaWR0aDogZWRnZS5pbnRlcmFjdGlvbldpZHRoIH0pKSwgaXNSZWNvbm5lY3RhYmxlICYmIChqc3goRWRnZVVwZGF0ZUFuY2hvcnMsIHsgZWRnZTogZWRnZSwgaXNSZWNvbm5lY3RhYmxlOiBpc1JlY29ubmVjdGFibGUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgc291cmNlWDogc291cmNlWCwgc291cmNlWTogc291cmNlWSwgdGFyZ2V0WDogdGFyZ2V0WCwgdGFyZ2V0WTogdGFyZ2V0WSwgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIHNldFVwZGF0ZUhvdmVyOiBzZXRVcGRhdGVIb3Zlciwgc2V0UmVjb25uZWN0aW5nOiBzZXRSZWNvbm5lY3RpbmcgfSkpXSB9KSB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGEgPSAocykgPT4gKHtcbiAgICBlZGdlc0ZvY3VzYWJsZTogcy5lZGdlc0ZvY3VzYWJsZSxcbiAgICBlZGdlc1JlY29ubmVjdGFibGU6IHMuZWRnZXNSZWNvbm5lY3RhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgY29ubmVjdGlvbk1vZGU6IHMuY29ubmVjdGlvbk1vZGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBFZGdlUmVuZGVyZXJDb21wb25lbnQoeyBkZWZhdWx0TWFya2VyQ29sb3IsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uUmVjb25uZWN0LCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VDbGljaywgcmVjb25uZWN0UmFkaXVzLCBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCB7IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlc1wiLCBjaGlsZHJlbjogW2pzeChNYXJrZXJEZWZpbml0aW9ucyQxLCB7IGRlZmF1bHRDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCByZklkOiByZklkIH0pLCBlZGdlSWRzLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeChFZGdlV3JhcHBlciwgeyBpZDogaWQsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlOiBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbkNsaWNrOiBvbkVkZ2VDbGljaywgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIHJmSWQ6IHJmSWQsIG9uRXJyb3I6IG9uRXJyb3IsIGVkZ2VUeXBlczogZWRnZVR5cGVzLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0sIGlkKSk7XG4gICAgICAgICAgICB9KV0gfSkpO1xufVxuRWRnZVJlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VSZW5kZXJlcic7XG5jb25zdCBFZGdlUmVuZGVyZXIgPSBtZW1vKEVkZ2VSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJDkgPSAocykgPT4gYHRyYW5zbGF0ZSgke3MudHJhbnNmb3JtWzBdfXB4LCR7cy50cmFuc2Zvcm1bMV19cHgpIHNjYWxlKCR7cy50cmFuc2Zvcm1bMl19KWA7XG5mdW5jdGlvbiBWaWV3cG9ydCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VTdG9yZShzZWxlY3RvciQ5KTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydCB4eWZsb3dfX3ZpZXdwb3J0IHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZTogeyB0cmFuc2Zvcm0gfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIG9uSW5pdCBoYW5kbGVyLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCkge1xuICAgIGNvbnN0IHJmSW5zdGFuY2UgPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZWQuY3VycmVudCAmJiByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWQgJiYgb25Jbml0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uSW5pdChyZkluc3RhbmNlKSwgMSk7XG4gICAgICAgICAgICBpc0luaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW29uSW5pdCwgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDggPSAoc3RhdGUpID0+IHN0YXRlLnBhblpvb20/LnN5bmNWaWV3cG9ydDtcbi8qKlxuICogSG9vayBmb3Igc3luY2luZyB0aGUgdmlld3BvcnQgd2l0aCB0aGUgcGFuem9vbSBpbnN0YW5jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB2aWV3cG9ydFxuICovXG5mdW5jdGlvbiB1c2VWaWV3cG9ydFN5bmModmlld3BvcnQpIHtcbiAgICBjb25zdCBzeW5jVmlld3BvcnQgPSB1c2VTdG9yZShzZWxlY3RvciQ4KTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzeW5jVmlld3BvcnQ/Lih2aWV3cG9ydCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybTogW3ZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0Lnpvb21dIH0pO1xuICAgICAgICB9XG4gICAgfSwgW3ZpZXdwb3J0LCBzeW5jVmlld3BvcnRdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc3RvcmVTZWxlY3RvciQxKHMpIHtcbiAgICByZXR1cm4gcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3NcbiAgICAgICAgPyB7IC4uLnMuY29ubmVjdGlvbiwgdG86IHBvaW50VG9SZW5kZXJlclBvaW50KHMuY29ubmVjdGlvbi50bywgcy50cmFuc2Zvcm0pIH1cbiAgICAgICAgOiB7IC4uLnMuY29ubmVjdGlvbiB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IoY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgaWYgKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBjb21iaW5lZFNlbGVjdG9yID0gKHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBzdG9yZVNlbGVjdG9yJDEocyk7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvblNlbGVjdG9yKGNvbm5lY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tYmluZWRTZWxlY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlU2VsZWN0b3IkMTtcbn1cbi8qKlxuICogVGhlIGB1c2VDb25uZWN0aW9uYCBob29rIHJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZVxuICogY29ubmVjdGlvbiBpbnRlcmFjdGlvbi4gSWYgbm8gY29ubmVjdGlvbiBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGl0IHJldHVybnMgbnVsbFxuICogZm9yIGV2ZXJ5IHByb3BlcnR5LiBBIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoaXMgaG9vayBpcyB0byBjb2xvcml6ZSBoYW5kbGVzXG4gKiBiYXNlZCBvbiBhIGNlcnRhaW4gY29uZGl0aW9uIChlLmcuIGlmIHRoZSBjb25uZWN0aW9uIGlzIHZhbGlkIG9yIG5vdCkuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNvbm5lY3Rpb25TZWxlY3RvciAtIEFuIG9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gZXh0cmFjdCBhIHNsaWNlIG9mIHRoZVxuICogYENvbm5lY3Rpb25TdGF0ZWAgZGF0YS4gVXNpbmcgYSBzZWxlY3RvciBjYW4gcHJldmVudCBjb21wb25lbnQgcmUtcmVuZGVycyB3aGVyZSBkYXRhIHlvdSBkb24ndFxuICogb3RoZXJ3aXNlIGNhcmUgYWJvdXQgbWlnaHQgY2hhbmdlLiBJZiBhIHNlbGVjdG9yIGlzIG5vdCBwcm92aWRlZCwgdGhlIGVudGlyZSBgQ29ubmVjdGlvblN0YXRlYFxuICogb2JqZWN0IGlzIHJldHVybmVkIHVuY2hhbmdlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUNvbm5lY3Rpb24gfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEFwcCgpIHtcbiAqICBjb25zdCBjb25uZWN0aW9uID0gdXNlQ29ubmVjdGlvbigpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj4ge2Nvbm5lY3Rpb24gPyBgU29tZW9uZSBpcyB0cnlpbmcgdG8gbWFrZSBhIGNvbm5lY3Rpb24gZnJvbSAke2Nvbm5lY3Rpb24uZnJvbU5vZGV9IHRvIHRoaXMgb25lLmAgOiAnVGhlcmUgYXJlIGN1cnJlbnRseSBubyBpbmNvbWluZyBjb25uZWN0aW9ucyEnfVxuICpcbiAqICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBDb25uZWN0aW9uU3RhdGVcbiAqL1xuZnVuY3Rpb24gdXNlQ29ubmVjdGlvbihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBjb25zdCBjb21iaW5lZFNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoY29ubmVjdGlvblNlbGVjdG9yKTtcbiAgICByZXR1cm4gdXNlU3RvcmUoY29tYmluZWRTZWxlY3Rvciwgc2hhbGxvdyk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4gKHtcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgaXNWYWxpZDogcy5jb25uZWN0aW9uLmlzVmFsaWQsXG4gICAgaW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgd2lkdGg6IHMud2lkdGgsXG4gICAgaGVpZ2h0OiBzLmhlaWdodCxcbn0pO1xuZnVuY3Rpb24gQ29ubmVjdGlvbkxpbmVXcmFwcGVyKHsgY29udGFpbmVyU3R5bGUsIHN0eWxlLCB0eXBlLCBjb21wb25lbnQsIH0pIHtcbiAgICBjb25zdCB7IG5vZGVzQ29ubmVjdGFibGUsIHdpZHRoLCBoZWlnaHQsIGlzVmFsaWQsIGluUHJvZ3Jlc3MgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlbmRlckNvbm5lY3Rpb24gPSAhISh3aWR0aCAmJiBub2Rlc0Nvbm5lY3RhYmxlICYmIGluUHJvZ3Jlc3MpO1xuICAgIGlmICghcmVuZGVyQ29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogY29udGFpbmVyU3R5bGUsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9ubGluZSByZWFjdC1mbG93X19jb250YWluZXJcIiwgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29ubmVjdGlvbicsIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCldKSwgY2hpbGRyZW46IGpzeChDb25uZWN0aW9uTGluZSwgeyBzdHlsZTogc3R5bGUsIHR5cGU6IHR5cGUsIEN1c3RvbUNvbXBvbmVudDogY29tcG9uZW50LCBpc1ZhbGlkOiBpc1ZhbGlkIH0pIH0pIH0pKTtcbn1cbmNvbnN0IENvbm5lY3Rpb25MaW5lID0gKHsgc3R5bGUsIHR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBDdXN0b21Db21wb25lbnQsIGlzVmFsaWQsIH0pID0+IHtcbiAgICBjb25zdCB7IGluUHJvZ3Jlc3MsIGZyb20sIGZyb21Ob2RlLCBmcm9tSGFuZGxlLCBmcm9tUG9zaXRpb24sIHRvLCB0b05vZGUsIHRvSGFuZGxlLCB0b1Bvc2l0aW9uIH0gPSB1c2VDb25uZWN0aW9uKCk7XG4gICAgaWYgKCFpblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEN1c3RvbUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKGpzeChDdXN0b21Db21wb25lbnQsIHsgY29ubmVjdGlvbkxpbmVUeXBlOiB0eXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBzdHlsZSwgZnJvbU5vZGU6IGZyb21Ob2RlLCBmcm9tSGFuZGxlOiBmcm9tSGFuZGxlLCBmcm9tWDogZnJvbS54LCBmcm9tWTogZnJvbS55LCB0b1g6IHRvLngsIHRvWTogdG8ueSwgZnJvbVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sIHRvUG9zaXRpb246IHRvUG9zaXRpb24sIGNvbm5lY3Rpb25TdGF0dXM6IGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCksIHRvTm9kZTogdG9Ob2RlLCB0b0hhbmRsZTogdG9IYW5kbGUgfSkpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSB7XG4gICAgICAgIHNvdXJjZVg6IGZyb20ueCxcbiAgICAgICAgc291cmNlWTogZnJvbS55LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbjogZnJvbVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRYOiB0by54LFxuICAgICAgICB0YXJnZXRZOiB0by55LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbjogdG9Qb3NpdGlvbixcbiAgICB9O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlNpbXBsZUJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNpbXBsZUJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgICAgICAuLi5wYXRoUGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlNtb290aFN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U3RyYWlnaHRQYXRoKHBhdGhQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4ganN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbi1wYXRoXCIsIHN0eWxlOiBzdHlsZSB9KTtcbn07XG5Db25uZWN0aW9uTGluZS5kaXNwbGF5TmFtZSA9ICdDb25uZWN0aW9uTGluZSc7XG5cbmNvbnN0IGVtcHR5VHlwZXMgPSB7fTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKG5vZGVPckVkZ2VUeXBlcyA9IGVtcHR5VHlwZXMpIHtcbiAgICBjb25zdCB0eXBlc1JlZiA9IHVzZVJlZihub2RlT3JFZGdlVHlwZXMpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZWRLZXlzID0gbmV3IFNldChbLi4uT2JqZWN0LmtleXModHlwZXNSZWYuY3VycmVudCksIC4uLk9iamVjdC5rZXlzKG5vZGVPckVkZ2VUeXBlcyldKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZWRLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVzUmVmLmN1cnJlbnRba2V5XSAhPT0gbm9kZU9yRWRnZVR5cGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAyJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzUmVmLmN1cnJlbnQgPSBub2RlT3JFZGdlVHlwZXM7XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZU9yRWRnZVR5cGVzXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0eWxlc0xvYWRlZFdhcm5pbmcoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGNoZWNrZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3BhbmUnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZSAmJiAhKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhbmUpLnpJbmRleCA9PT0gJzEnKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEzJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTMnXSgncmVhY3QnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIEdyYXBoVmlld0NvbXBvbmVudCh7IG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbkluaXQsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Ob2RlRG91YmxlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGRlbGV0ZUtleUNvZGUsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIGRlZmF1bHRNYXJrZXJDb2xvciwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZywgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UsIG5vZGVDbGlja0Rpc3RhbmNlLCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudCwgcmZJZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIH0pIHtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKG5vZGVUeXBlcyk7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhlZGdlVHlwZXMpO1xuICAgIHVzZVN0eWxlc0xvYWRlZFdhcm5pbmcoKTtcbiAgICB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCk7XG4gICAgdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KTtcbiAgICByZXR1cm4gKGpzeChGbG93UmVuZGVyZXIsIHsgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlOiBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWc6IHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgb25TZWxlY3Rpb25TdGFydDogb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQ6IG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgb25WaWV3cG9ydENoYW5nZTogb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQ6ICEhdmlld3BvcnQsIGNoaWxkcmVuOiBqc3hzKFZpZXdwb3J0LCB7IGNoaWxkcmVuOiBbanN4KEVkZ2VSZW5kZXJlciwgeyBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgZGVmYXVsdE1hcmtlckNvbG9yOiBkZWZhdWx0TWFya2VyQ29sb3IsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZDogcmZJZCB9KSwganN4KENvbm5lY3Rpb25MaW5lV3JhcHBlciwgeyBzdHlsZTogY29ubmVjdGlvbkxpbmVTdHlsZSwgdHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb21wb25lbnQ6IGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlclwiIH0pLCBqc3goTm9kZVJlbmRlcmVyLCB7IG5vZGVUeXBlczogbm9kZVR5cGVzLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrOiBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgbm9kZUNsaWNrRGlzdGFuY2U6IG5vZGVDbGlja0Rpc3RhbmNlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCByZklkOiByZklkIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsXCIgfSldIH0pIH0pKTtcbn1cbkdyYXBoVmlld0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdHcmFwaFZpZXcnO1xuY29uc3QgR3JhcGhWaWV3ID0gbWVtbyhHcmFwaFZpZXdDb21wb25lbnQpO1xuXG5jb25zdCBnZXRJbml0aWFsU3RhdGUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IG5vZGVMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGFyZW50TG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Mb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWRnZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdG9yZUVkZ2VzID0gZGVmYXVsdEVkZ2VzID8/IGVkZ2VzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZXMgPSBkZWZhdWx0Tm9kZXMgPz8gbm9kZXMgPz8gW107XG4gICAgY29uc3Qgc3RvcmVOb2RlT3JpZ2luID0gbm9kZU9yaWdpbiA/PyBbMCwgMF07XG4gICAgY29uc3Qgc3RvcmVOb2RlRXh0ZW50ID0gbm9kZUV4dGVudCA/PyBpbmZpbml0ZUV4dGVudDtcbiAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIHN0b3JlRWRnZXMpO1xuICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2RlcyhzdG9yZU5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50OiBzdG9yZU5vZGVFeHRlbnQsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiBmYWxzZSxcbiAgICB9KTtcbiAgICBsZXQgdHJhbnNmb3JtID0gWzAsIDAsIDFdO1xuICAgIGlmIChmaXRWaWV3ICYmIHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICBjb25zdCBib3VuZHMgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVMb29rdXAsIHtcbiAgICAgICAgICAgIGZpbHRlcjogKG5vZGUpID0+ICEhKChub2RlLndpZHRoIHx8IG5vZGUuaW5pdGlhbFdpZHRoKSAmJiAobm9kZS5oZWlnaHQgfHwgbm9kZS5pbml0aWFsSGVpZ2h0KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgZml0Vmlld09wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICAgICAgdHJhbnNmb3JtID0gW3gsIHksIHpvb21dO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZklkOiAnMScsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgbm9kZXM6IHN0b3JlTm9kZXMsXG4gICAgICAgIG5vZGVzSW5pdGlhbGl6ZWQsXG4gICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIHBhcmVudExvb2t1cCxcbiAgICAgICAgZWRnZXM6IHN0b3JlRWRnZXMsXG4gICAgICAgIGVkZ2VMb29rdXAsXG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAsXG4gICAgICAgIG9uTm9kZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIG9uRWRnZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIGhhc0RlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIGhhc0RlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHBhblpvb206IG51bGwsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBDb25uZWN0aW9uTW9kZS5TdHJpY3QsXG4gICAgICAgIGRvbU5vZGU6IG51bGwsXG4gICAgICAgIHBhbmVEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVEcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZDogMSxcbiAgICAgICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgICAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgbm9kZXNEcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIG5vZGVzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNSZWNvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgICAgICBlbGV2YXRlRWRnZXNPblNlbGVjdDogZmFsc2UsXG4gICAgICAgIHNlbGVjdE5vZGVzT25EcmFnOiB0cnVlLFxuICAgICAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGZpdFZpZXdRdWV1ZWQ6IGZpdFZpZXcgPz8gZmFsc2UsXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBmaXRWaWV3UmVzb2x2ZXI6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb246IHsgLi4uaW5pdGlhbENvbm5lY3Rpb24gfSxcbiAgICAgICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgICAgIGNvbm5lY3RPbkNsaWNrOiB0cnVlLFxuICAgICAgICBhcmlhTGl2ZU1lc3NhZ2U6ICcnLFxuICAgICAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRHJhZzogdHJ1ZSxcbiAgICAgICAgYXV0b1Bhbk9uTm9kZUZvY3VzOiB0cnVlLFxuICAgICAgICBhdXRvUGFuU3BlZWQ6IDE1LFxuICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiAyMCxcbiAgICAgICAgb25FcnJvcjogZGV2V2FybixcbiAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogW10sXG4gICAgICAgIGxpYjogJ3JlYWN0JyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBhcmlhTGFiZWxDb25maWc6IGRlZmF1bHRBcmlhTGFiZWxDb25maWcsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN0b3JlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pID0+IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVGaXRWaWV3KCkge1xuICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhblpvb20sIGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3UmVzb2x2ZXIsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmaXRWaWV3cG9ydCh7XG4gICAgICAgICAgICBub2Rlczogbm9kZUxvb2t1cCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICB9LCBmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcj8ucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdhaXQgZm9yIHRoZSBmaXRWaWV3cG9ydCB0byByZXNvbHZlIGJlZm9yZSBkZWxldGluZyB0aGUgcmVzb2x2ZXIsXG4gICAgICAgICAqIHdlIHdhbnQgdG8gcmV1c2UgdGhlIG9sZCByZXNvbHZlciBpZiB0aGUgdXNlciBjYWxscyBmaXRWaWV3IGFnYWluIGluIHRoZSBtZWFuIHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHNldCh7IGZpdFZpZXdSZXNvbHZlcjogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ2V0SW5pdGlhbFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGZpdFZpZXcsXG4gICAgICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIH0pLFxuICAgICAgICBzZXROb2RlczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGZpdFZpZXdRdWV1ZWQgfSA9IGdldCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNldE5vZGVzKCkgaXMgY2FsbGVkIGV4Y2x1c2l2ZWx5IGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9uczpcbiAgICAgICAgICAgICAqIC0gZWl0aGVyIHdoZW4gdGhlIGA8UmVhY3RGbG93IG5vZGVzPmAgcHJvcCBpcyB1cGRhdGVkIGluIHRoZSBjb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cCxcbiAgICAgICAgICAgICAqIC0gb3Igd2hlbiB0aGUgdXNlciBjYWxscyBzb21ldGhpbmcgbGlrZSBgcmVhY3RGbG93SW5zdGFuY2Uuc2V0Tm9kZXMoKWAgaW4gYW4gdW5jb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgdGFrZSB0aGUgbm90ZSBvYmplY3RzIHBhc3NlZCBieSB0aGUgdXNlciBhbmQgZXh0ZW5kIHRoZW0gd2l0aCBmaWVsZHNcbiAgICAgICAgICAgICAqIHJlbGV2YW50IGZvciBpbnRlcm5hbCBSZWFjdCBGbG93IG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaXRWaWV3UXVldWVkICYmIG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkLCBmaXRWaWV3UXVldWVkOiBmYWxzZSwgZml0Vmlld09wdGlvbnM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAgfSA9IGdldCgpO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcyk7XG4gICAgICAgICAgICBzZXQoeyBlZGdlcyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IChub2RlcywgZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0Tm9kZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNldEVkZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhlZGdlcyk7XG4gICAgICAgICAgICAgICAgc2V0KHsgaGFzRGVmYXVsdEVkZ2VzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBFdmVyeSBub2RlIGdldHMgcmVnaXN0ZXJkIGF0IGEgUmVzaXplT2JzZXJ2ZXIuIFdoZW5ldmVyIGEgbm9kZVxuICAgICAgICAgKiBjaGFuZ2VzIGl0cyBkaW1lbnNpb25zLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBtZWFzdXJlIHRoZVxuICAgICAgICAgKiBuZXcgZGltZW5zaW9ucyBhbmQgdXBkYXRlIHRoZSBub2Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHM6ICh1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBkZWJ1ZywgZml0Vmlld1F1ZXVlZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfSA9IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZEludGVybmFscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCBub2RlRXh0ZW50IH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gdHJpZ2dlciB1c2VTdG9yZSBjYWxscyB3aGVuZXZlciB1cGRhdGVOb2RlSW50ZXJuYWxzIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHNldCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBub2RlRHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSBub2RlbG9va3VwIHRvIGJlIHN1cmUgdG8gdXNlIHRoZSBjdXJyZW50IGV4cGFuZFBhcmVudCBhbmQgcGFyZW50SWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZFBhcmVudCA9ICEhKG5vZGU/LmV4cGFuZFBhcmVudCAmJiBub2RlPy5wYXJlbnRJZCAmJiBkcmFnSXRlbT8ucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHBhbmRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkcmFnSXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbk5vZGVzQ2hhbmdlLCBzZXROb2Rlcywgbm9kZXMsIGhhc0RlZmF1bHROb2RlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVzKHVwZGF0ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uRWRnZXNDaGFuZ2UsIHNldEVkZ2VzLCBlZGdlcywgaGFzRGVmYXVsdEVkZ2VzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRnZXModXBkYXRlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIGVkZ2UgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXM6IChzZWxlY3RlZE5vZGVJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gc2VsZWN0ZWROb2RlSWRzLm1hcCgobm9kZUlkKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZE5vZGVJZHNdKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCkpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG11bHRpU2VsZWN0aW9uQWN0aXZlLCBlZGdlTG9va3VwLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkRWRnZXMgPSBzZWxlY3RlZEVkZ2VJZHMubWFwKChlZGdlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoY2hhbmdlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZEVkZ2VJZHNdKSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgbmV3IFNldCgpLCB0cnVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlczogKHsgbm9kZXMsIGVkZ2VzIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgbm9kZXM6IHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzVG9VbnNlbGVjdCA9IG5vZGVzID8gbm9kZXMgOiBzdG9yZU5vZGVzO1xuICAgICAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIHdlIG5lZWQgdG8gdW5zZWxlY3QgdGhlIGludGVybmFsIG5vZGUgdGhhdCB3YXMgc2VsZWN0ZWQgcHJldmlvdXNseSBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICogc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSB1c2VyIHRvIHByZXZlbnQgaXQgdG8gYmUgc2VsZWN0ZWQgd2hpbGUgZHJhZ2dpbmcgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbE5vZGUuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShuLmlkLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWluWm9vbTogKG1pblpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF4Wm9vbTogKG1heFpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWluWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWF4Wm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IChjbGlja0Rpc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRDbGlja0Rpc3RhbmNlKGNsaWNrRGlzdGFuY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZWxlbWVudHNTZWxlY3RhYmxlIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXMucmVkdWNlKChyZXMsIGVkZ2UpID0+IChlZGdlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Tm9kZUV4dGVudDogKG5leHROb2RlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZUV4dGVudFswXVswXSA9PT0gbm9kZUV4dGVudFswXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzBdWzFdID09PSBub2RlRXh0ZW50WzBdWzFdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVsxXSA9PT0gbm9kZUV4dGVudFsxXVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXQoeyBub2RlRXh0ZW50OiBuZXh0Tm9kZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQoe1xuICAgICAgICAgICAgICAgIHg6IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbSxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyIC0geSAqIG5leHRab29tLFxuICAgICAgICAgICAgICAgIHpvb206IG5leHRab29tLFxuICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sIGVhc2U6IG9wdGlvbnM/LmVhc2UsIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZXQoeyBjb25uZWN0aW9uIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG4gICAgfTtcbn0sIE9iamVjdC5pcyk7XG5cbi8qKlxuICogVGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBpcyBhIFtjb250ZXh0IHByb3ZpZGVyXShodHRwczovL3JlYWN0LmRldi9sZWFybi9wYXNzaW5nLWRhdGEtZGVlcGx5LXdpdGgtY29udGV4dCMpXG4gKiB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGFjY2VzcyBhIGZsb3cncyBpbnRlcm5hbCBzdGF0ZSBvdXRzaWRlIG9mIHRoZVxuICogW2A8UmVhY3RGbG93IC8+YF0oL2FwaS1yZWZlcmVuY2UvcmVhY3QtZmxvdykgY29tcG9uZW50LiBNYW55IG9mIHRoZSBob29rcyB3ZVxuICogcHJvdmlkZSByZWx5IG9uIHRoaXMgY29tcG9uZW50IHRvIHdvcmsuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgICAgIDxSZWFjdEZsb3cgbm9kZXM9ey4uLn0gZWRnZXM9ey4uLn0gLz5cbiAqICAgICAgPFNpZGViYXIgLz5cbiAqICAgIDwvUmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgKTtcbiAqfVxuICpcbiAqZnVuY3Rpb24gU2lkZWJhcigpIHtcbiAqICAvLyBUaGlzIGhvb2sgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIGNvbXBvbmVudCBpdCdzIHVzZWQgaW4gaXMgYSBjaGlsZCBvZiBhXG4gKiAgLy8gPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+LlxuICogIGNvbnN0IG5vZGVzID0gdXNlTm9kZXMoKVxuICpcbiAqICByZXR1cm4gPGFzaWRlPmRvIHNvbWV0aGluZyB3aXRoIG5vZGVzPC9hc2lkZT47XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgSWYgeW91J3JlIHVzaW5nIGEgcm91dGVyIGFuZCB3YW50IHlvdXIgZmxvdydzIHN0YXRlIHRvIHBlcnNpc3QgYWNyb3NzIHJvdXRlcyxcbiAqIGl0J3Mgdml0YWwgdGhhdCB5b3UgcGxhY2UgdGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBfb3V0c2lkZV8gb2ZcbiAqIHlvdXIgcm91dGVyLiBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiB0aGUgc2FtZSBwYWdlIHlvdSB3aWxsIG5lZWQgdG8gdXNlIGEgc2VwYXJhdGVcbiAqIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGZvciBlYWNoIGZsb3cuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Rmxvd1Byb3ZpZGVyKHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBpbml0aWFsRml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50LFxuICAgIH0pKTtcbiAgICByZXR1cm4gKGpzeChQcm92aWRlciQxLCB7IHZhbHVlOiBzdG9yZSwgY2hpbGRyZW46IGpzeChCYXRjaFByb3ZpZGVyLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFdyYXBwZXIoeyBjaGlsZHJlbiwgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pIHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVhY3RGbG93UHJvdmlkZXIsIHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGluaXRpYWxNaW5ab29tOiBtaW5ab29tLCBpbml0aWFsTWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5mdW5jdGlvbiBSZWFjdEZsb3coeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCBjbGFzc05hbWUsIG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uSW5pdCwgb25Nb3ZlLCBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kLCBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcCwgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25EZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25CZWZvcmVEZWxldGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uTGluZVR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgZGVsZXRlS2V5Q29kZSA9ICdCYWNrc3BhY2UnLCBzZWxlY3Rpb25LZXlDb2RlID0gJ1NoaWZ0Jywgc2VsZWN0aW9uT25EcmFnID0gZmFsc2UsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbkFjdGl2YXRpb25LZXlDb2RlID0gJ1NwYWNlJywgbXVsdGlTZWxlY3Rpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCB6b29tQWN0aXZhdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzID0gZmFsc2UsIHNlbGVjdE5vZGVzT25EcmFnLCBub2Rlc0RyYWdnYWJsZSwgYXV0b1Bhbk9uTm9kZUZvY3VzLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGRlZmF1bHROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxID0gZGVmYXVsdFZpZXdwb3J0LCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgdHJhbnNsYXRlRXh0ZW50ID0gaW5maW5pdGVFeHRlbnQsIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlLCBub2RlRXh0ZW50LCBkZWZhdWx0TWFya2VyQ29sb3IgPSAnI2IxYjFiNycsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UgPSAwLCBub2RlQ2xpY2tEaXN0YW5jZSA9IDAsIGNoaWxkcmVuLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMgPSAxMCwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgbm9EcmFnQ2xhc3NOYW1lID0gJ25vZHJhZycsIG5vV2hlZWxDbGFzc05hbWUgPSAnbm93aGVlbCcsIG5vUGFuQ2xhc3NOYW1lID0gJ25vcGFuJywgZml0VmlldywgZml0Vmlld09wdGlvbnMsIGNvbm5lY3RPbkNsaWNrLCBhdHRyaWJ1dGlvblBvc2l0aW9uLCBwcm9PcHRpb25zLCBkZWZhdWx0RWRnZU9wdGlvbnMsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeSA9IGZhbHNlLCBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkLCBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbiwgb25FcnJvciwgc3R5bGUsIGlkLCBub2RlRHJhZ1RocmVzaG9sZCwgY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB3aWR0aCwgaGVpZ2h0LCBjb2xvck1vZGUgPSAnbGlnaHQnLCBkZWJ1Zywgb25TY3JvbGwsIGFyaWFMYWJlbENvbmZpZywgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCByZklkID0gaWQgfHwgJzEnO1xuICAgIGNvbnN0IGNvbG9yTW9kZUNsYXNzTmFtZSA9IHVzZUNvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgLy8gVW5kbyBzY3JvbGwgZXZlbnRzLCBwcmV2ZW50aW5nIHZpZXdwb3J0IGZyb20gc2hpZnRpbmcgd2hlbiBub2RlcyBvdXRzaWRlIG9mIGl0IGFyZSBmb2N1c2VkXG4gICAgY29uc3Qgd3JhcHBlck9uU2Nyb2xsID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvKHsgdG9wOiAwLCBsZWZ0OiAwLCBiZWhhdmlvcjogJ2luc3RhbnQnIH0pO1xuICAgICAgICBvblNjcm9sbD8uKGUpO1xuICAgIH0sIFtvblNjcm9sbF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInJmX193cmFwcGVyXCIsIC4uLnJlc3QsIG9uU2Nyb2xsOiB3cmFwcGVyT25TY3JvbGwsIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi53cmFwcGVyU3R5bGUgfSwgcmVmOiByZWYsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93JywgY2xhc3NOYW1lLCBjb2xvck1vZGVDbGFzc05hbWVdKSwgaWQ6IGlkLCByb2xlOiBcImFwcGxpY2F0aW9uXCIsIGNoaWxkcmVuOiBqc3hzKFdyYXBwZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgY2hpbGRyZW46IFtqc3goR3JhcGhWaWV3LCB7IG9uSW5pdDogb25Jbml0LCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBub2RlVHlwZXM6IG5vZGVUeXBlcywgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGNvbm5lY3Rpb25MaW5lVHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQkMSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2U6IG5vZGVDbGlja0Rpc3RhbmNlLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgdmlld3BvcnQ6IHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlIH0pLCBqc3goU3RvcmVVcGRhdGVyLCB7IG5vZGVzOiBub2RlcywgZWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMsIG9uQ29ubmVjdDogb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydDogb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZDogb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0OiBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZDogb25DbGlja0Nvbm5lY3RFbmQsIG5vZGVzRHJhZ2dhYmxlOiBub2Rlc0RyYWdnYWJsZSwgYXV0b1Bhbk9uTm9kZUZvY3VzOiBhdXRvUGFuT25Ob2RlRm9jdXMsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGVsZXZhdGVFZGdlc09uU2VsZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlOiBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlOiBvbkVkZ2VzQ2hhbmdlLCBzbmFwVG9HcmlkOiBzbmFwVG9HcmlkLCBzbmFwR3JpZDogc25hcEdyaWQsIGNvbm5lY3Rpb25Nb2RlOiBjb25uZWN0aW9uTW9kZSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIGNvbm5lY3RPbkNsaWNrOiBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zOiBkZWZhdWx0RWRnZU9wdGlvbnMsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZTogb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZTogb25FZGdlc0RlbGV0ZSwgb25EZWxldGU6IG9uRGVsZXRlLCBvbk5vZGVEcmFnU3RhcnQ6IG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZzogb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3A6IG9uTm9kZURyYWdTdG9wLCBvblNlbGVjdGlvbkRyYWc6IG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RhcnQ6IG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdG9wOiBvblNlbGVjdGlvbkRyYWdTdG9wLCBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCByZklkOiByZklkLCBhdXRvUGFuT25Db25uZWN0OiBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZzogYXV0b1Bhbk9uTm9kZURyYWcsIGF1dG9QYW5TcGVlZDogYXV0b1BhblNwZWVkLCBvbkVycm9yOiBvbkVycm9yLCBjb25uZWN0aW9uUmFkaXVzOiBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24sIHNlbGVjdE5vZGVzT25EcmFnOiBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQ6IG5vZGVEcmFnVGhyZXNob2xkLCBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZDogY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsIG9uQmVmb3JlRGVsZXRlOiBvbkJlZm9yZURlbGV0ZSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBkZWJ1ZzogZGVidWcsIGFyaWFMYWJlbENvbmZpZzogYXJpYUxhYmVsQ29uZmlnIH0pLCBqc3goU2VsZWN0aW9uTGlzdGVuZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLCBjaGlsZHJlbiwganN4KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLCBqc3goQTExeURlc2NyaXB0aW9ucywgeyByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pXSB9KSB9KSk7XG59XG4vKipcbiAqIFRoZSBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50IGlzIHRoZSBoZWFydCBvZiB5b3VyIFJlYWN0IEZsb3cgYXBwbGljYXRpb24uXG4gKiBJdCByZW5kZXJzIHlvdXIgbm9kZXMgYW5kIGVkZ2VzIGFuZCBoYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKDxSZWFjdEZsb3dcbiAqICAgIG5vZGVzPXsuLi59XG4gKiAgICBlZGdlcz17Li4ufVxuICogICAgb25Ob2Rlc0NoYW5nZT17Li4ufVxuICogICAgLi4uXG4gKiAgLz4pO1xuICp9XG4gKmBgYFxuICovXG52YXIgaW5kZXggPSBmaXhlZEZvcndhcmRSZWYoUmVhY3RGbG93KTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXInKTtcbi8qKlxuICogRWRnZXMgYXJlIFNWRy1iYXNlZC4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIG1vcmUgY29tcGxleCBsYWJlbHMgeW91IGNhbiB1c2UgdGhlXG4gKiBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBjb21wb25lbnQgdG8gYWNjZXNzIGEgZGl2IGJhc2VkIHJlbmRlcmVyLiBUaGlzIGNvbXBvbmVudFxuICogaXMgYSBwb3J0YWwgdGhhdCByZW5kZXJzIHRoZSBsYWJlbCBpbiBhIGA8ZGl2IC8+YCB0aGF0IGlzIHBvc2l0aW9uZWQgb24gdG9wIG9mXG4gKiB0aGUgZWRnZXMuIFlvdSBjYW4gc2VlIGFuIGV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGNvbXBvbmVudCBpbiB0aGVcbiAqIFtlZGdlIGxhYmVsIHJlbmRlcmVyIGV4YW1wbGVdKC9leGFtcGxlcy9lZGdlcy9lZGdlLWxhYmVsLXJlbmRlcmVyKS5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgZ2V0QmV6aWVyUGF0aCwgRWRnZUxhYmVsUmVuZGVyZXIsIEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBpZCwgZGF0YSwgLi4ucHJvcHMgfSkge1xuICogICBjb25zdCBbZWRnZVBhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgocHJvcHMpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8PlxuICogICAgICAgPEJhc2VFZGdlIGlkPXtpZH0gcGF0aD17ZWRnZVBhdGh9IC8+XG4gKiAgICAgICA8RWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgICAgIDxkaXZcbiAqICAgICAgICAgICBzdHlsZT17e1xuICogICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gKiAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgdHJhbnNsYXRlKCR7bGFiZWxYfXB4LCR7bGFiZWxZfXB4KWAsXG4gKiAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmY2MwMCcsXG4gKiAgICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAqICAgICAgICAgfX1cbiAqICAgICAgICAgICBjbGFzc05hbWU9XCJub2RyYWcgbm9wYW5cIlxuICogICAgICAgICA+XG4gKiAgICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICA8L0VkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgIDwvPlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoZSBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBoYXMgbm8gcG9pbnRlciBldmVudHMgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG9cbiAqIGFkZCBtb3VzZSBpbnRlcmFjdGlvbnMgeW91IG5lZWQgdG8gc2V0IHRoZSBzdHlsZSBgcG9pbnRlckV2ZW50czogYWxsYCBhbmQgYWRkXG4gKiB0aGUgYG5vcGFuYCBjbGFzcyBvbiB0aGUgbGFiZWwgb3IgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gaW50ZXJhY3Qgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQ2KTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDUgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsJyk7XG4vKipcbiAqIFRoZSBgPFZpZXdwb3J0UG9ydGFsIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYWRkIGNvbXBvbmVudHMgdG8gdGhlIHNhbWUgdmlld3BvcnRcbiAqIG9mIHRoZSBmbG93IHdoZXJlIG5vZGVzIGFuZCBlZGdlcyBhcmUgcmVuZGVyZWQuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXG4gKiB5b3VyIG93biBjb21wb25lbnRzIHRoYXQgYXJlIGFkaGVyZSB0byB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgbm9kZXMgJiBlZGdlc1xuICogYW5kIGFyZSBhbHNvIGFmZmVjdGVkIGJ5IHpvb21pbmcgYW5kIHBhbm5pbmdcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganN4XG4gKmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFZpZXdwb3J0UG9ydGFsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxWaWV3cG9ydFBvcnRhbD5cbiAqICAgICAgPGRpdlxuICogICAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMDBweCwgMTAwcHgpJywgcG9zaXRpb246ICdhYnNvbHV0ZScgfX1cbiAqICAgICAgPlxuICogICAgICAgIFRoaXMgZGl2IGlzIHBvc2l0aW9uZWQgYXQgWzEwMCwgMTAwXSBvbiB0aGUgZmxvdy5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8L1ZpZXdwb3J0UG9ydGFsPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIFZpZXdwb3J0UG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHZpZXdQb3J0YWxEaXYgPSB1c2VTdG9yZShzZWxlY3RvciQ1KTtcbiAgICBpZiAoIXZpZXdQb3J0YWxEaXYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHZpZXdQb3J0YWxEaXYpO1xufVxuXG4vKipcbiAqIFdoZW4geW91IHByb2dyYW1tYXRpY2FsbHkgYWRkIG9yIHJlbW92ZSBoYW5kbGVzIHRvIGEgbm9kZSBvciB1cGRhdGUgYSBub2RlJ3NcbiAqIGhhbmRsZSBwb3NpdGlvbiwgeW91IG5lZWQgdG8gbGV0IFJlYWN0IEZsb3cga25vdyBhYm91dCBpdCB1c2luZyB0aGlzIGhvb2suIFRoaXNcbiAqIHdpbGwgdXBkYXRlIHRoZSBpbnRlcm5hbCBkaW1lbnNpb25zIG9mIHRoZSBub2RlIGFuZCBwcm9wZXJseSByZXBvc2l0aW9uIGhhbmRsZXNcbiAqIG9uIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHRlbGwgUmVhY3QgRmxvdyB0byB1cGRhdGUgdGhlIGludGVybmFsIHN0YXRlIG9mIG9uZSBvciBtb3JlIG5vZGVzXG4gKiB0aGF0IHlvdSBoYXZlIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSYW5kb21IYW5kbGVOb2RlKHsgaWQgfSkge1xuICogIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCk7XG4gKiAgY29uc3QgW2hhbmRsZUNvdW50LCBzZXRIYW5kbGVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCByYW5kb21pemVIYW5kbGVDb3VudCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAqICAgc2V0SGFuZGxlQ291bnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApKTtcbiAqICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHMoaWQpO1xuICogIH0sIFtpZCwgdXBkYXRlTm9kZUludGVybmFsc10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAge0FycmF5LmZyb20oeyBsZW5ndGg6IGhhbmRsZUNvdW50IH0pLm1hcCgoXywgaW5kZXgpID0+IChcbiAqICAgICAgICA8SGFuZGxlXG4gKiAgICAgICAgICBrZXk9e2luZGV4fVxuICogICAgICAgICAgdHlwZT1cInRhcmdldFwiXG4gKiAgICAgICAgICBwb3NpdGlvbj1cImxlZnRcIlxuICogICAgICAgICAgaWQ9e2BoYW5kbGUtJHtpbmRleH1gfVxuICogICAgICAgIC8+XG4gKiAgICAgICkpfVxuICpcbiAqICAgICAgPGRpdj5cbiAqICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JhbmRvbWl6ZUhhbmRsZUNvdW50fT5SYW5kb21pemUgaGFuZGxlIGNvdW50PC9idXR0b24+XG4gKiAgICAgICAgPHA+VGhlcmUgYXJlIHtoYW5kbGVDb3VudH0gaGFuZGxlcyBvbiB0aGlzIG5vZGUuPC9wPlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgY2FuIG9ubHkgYmUgdXNlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGEgY2hpbGQgb2YgYVxuICp7QGxpbmsgUmVhY3RGbG93UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFJlYWN0Rmxvd30gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgdXBkYXRlTm9kZUludGVybmFscyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVwZGF0ZUlkcy5mb3JFYWNoKCh1cGRhdGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW1lbnQgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKGAucmVhY3QtZmxvd19fbm9kZVtkYXRhLWlkPVwiJHt1cGRhdGVJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KHVwZGF0ZUlkLCB7IGlkOiB1cGRhdGVJZCwgbm9kZUVsZW1lbnQsIGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgeyB0cmlnZ2VyRml0VmlldzogZmFsc2UgfSkpO1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3Qgbm9kZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUubm9kZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IG5vZGVzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgbm9kZSBjaGFuZ2VzKiosIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZFxuICogb3IgbW92ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG5vZGVzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAqICBjb25zdCBub2RlcyA9IHVzZU5vZGVzKCk7XG4gKlxuICogIHJldHVybiA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge25vZGVzLmxlbmd0aH0gbm9kZXMhPC9kaXY+O1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGVkZ2VzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgZWRnZSBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIGVkZ2VzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgZWRnZXMgPSB1c2VFZGdlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtlZGdlcy5sZW5ndGh9IGVkZ2VzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXMoKSB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZShlZGdlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZXM7XG59XG5cbmNvbnN0IHZpZXdwb3J0U2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG59KTtcbi8qKlxuICogVGhlIGB1c2VWaWV3cG9ydGAgaG9vayBpcyBhIGNvbnZlbmllbnQgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gKiB7QGxpbmsgVmlld3BvcnR9IGluIGEgY29tcG9uZW50LiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciB0aGUgdmlld3BvcnQgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlVmlld3BvcnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdwb3J0RGlzcGxheSgpIHtcbiAqICBjb25zdCB7IHgsIHksIHpvb20gfSA9IHVzZVZpZXdwb3J0KCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5cbiAqICAgICAgICBUaGUgdmlld3BvcnQgaXMgY3VycmVudGx5IGF0ICh7eH0sIHt5fSkgYW5kIHpvb21lZCB0byB7em9vbX0uXG4gKiAgICAgIDwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBub2Rlc2A6IFRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzLiBZb3UgbWlnaHQgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgbm9kZXNgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCwgb3IgeW91IG1heSB3YW50IHRvIG1hbmlwdWxhdGUgaXQgZmlyc3QgdG8gcGVyZm9ybSBzb21lIGxheW91dGluZyxcbiAqIGZvciBleGFtcGxlLlxuICogLSBgc2V0Tm9kZXNgOiBBIGZ1bmN0aW9uIHRoYXQgeW91IGNhbiB1c2UgdG8gdXBkYXRlIHRoZSBub2Rlcy4gWW91IGNhbiBwYXNzIGl0IGEgbmV3IGFycmF5IG9mXG4gKiBub2RlcyBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygbm9kZXMuXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdHVwbGUgcmV0dXJuZWQgYnkgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2suXG4gKiAtIGBvbk5vZGVzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBOb2RlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgbm9kZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uTm9kZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcykge1xuICAgIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAgICBjb25zdCBvbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldE5vZGVzKChuZHMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbmRzKSksIFtdKTtcbiAgICByZXR1cm4gW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV07XG59XG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgZWRnZXNgOiBUaGUgY3VycmVudCBhcnJheSBvZiBlZGdlcy4gWW91IG1pZ2h0IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYGVkZ2VzYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQsIG9yIHlvdSBtYXkgd2FudCB0byBtYW5pcHVsYXRlIGl0IGZpcnN0IHRvIHBlcmZvcm0gc29tZSBsYXlvdXRpbmcsXG4gKiBmb3IgZXhhbXBsZS5cbiAqXG4gKiAtIGBzZXRFZGdlc2A6IEEgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIHVzZSB0byB1cGRhdGUgdGhlIGVkZ2VzLiBZb3UgY2FuIHBhc3MgaXQgYSBuZXcgYXJyYXkgb2ZcbiAqIGVkZ2VzIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBhcnJheSBvZiBlZGdlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBlZGdlcy5cbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSB0dXBsZSByZXR1cm5lZCBieSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vay5cbiAqXG4gKiAtIGBvbkVkZ2VzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBFZGdlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgZWRnZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uRWRnZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcykge1xuICAgIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAgICBjb25zdCBvbkVkZ2VzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEVkZ2VzKChlZHMpID0+IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRzKSksIFtdKTtcbiAgICByZXR1cm4gW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV07XG59XG5cbi8qKlxuICogVGhlIGB1c2VPblZpZXdwb3J0Q2hhbmdlYCBob29rIGxldHMgeW91IGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgdmlld3BvcnQgc3VjaFxuICogYXMgcGFubmluZyBhbmQgem9vbWluZy4gWW91IGNhbiBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggcGhhc2Ugb2YgYSB2aWV3cG9ydFxuICogY2hhbmdlOiBgb25TdGFydGAsIGBvbkNoYW5nZWAsIGFuZCBgb25FbmRgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IHVzZU9uVmlld3BvcnRDaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFZpZXdwb3J0Q2hhbmdlTG9nZ2VyKCkge1xuICogIHVzZU9uVmlld3BvcnRDaGFuZ2Uoe1xuICogICAgb25TdGFydDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ3N0YXJ0Jywgdmlld3BvcnQpLFxuICogICAgb25DaGFuZ2U6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdjaGFuZ2UnLCB2aWV3cG9ydCksXG4gKiAgICBvbkVuZDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2VuZCcsIHZpZXdwb3J0KSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIG51bGw7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU9uVmlld3BvcnRDaGFuZ2UoeyBvblN0YXJ0LCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VTdGFydDogb25TdGFydCB9KTtcbiAgICB9LCBbb25TdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZTogb25DaGFuZ2UgfSk7XG4gICAgfSwgW29uQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlRW5kOiBvbkVuZCB9KTtcbiAgICB9LCBbb25FbmRdKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIGJvdGggbm9kZSBhbmQgZWRnZSBzZWxlY3Rpb24uIEFzIHRoZVxuICpuYW1lIGltcGxpZXMsIHRoZSBjYWxsYmFjayB5b3UgcHJvdmlkZSB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIG9mXG4gKl9laXRoZXJfIG5vZGVzIG9yIGVkZ2VzIGNoYW5nZXMuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VPblNlbGVjdGlvbkNoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gU2VsZWN0aW9uRGlzcGxheSgpIHtcbiAqICBjb25zdCBbc2VsZWN0ZWROb2Rlcywgc2V0U2VsZWN0ZWROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW3NlbGVjdGVkRWRnZXMsIHNldFNlbGVjdGVkRWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICpcbiAqICAvLyB0aGUgcGFzc2VkIGhhbmRsZXIgaGFzIHRvIGJlIG1lbW9pemVkLCBvdGhlcndpc2UgdGhlIGhvb2sgd2lsbCBub3Qgd29yayBjb3JyZWN0bHlcbiAqICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCh7IG5vZGVzLCBlZGdlcyB9KSA9PiB7XG4gKiAgICBzZXRTZWxlY3RlZE5vZGVzKG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICogICAgc2V0U2VsZWN0ZWRFZGdlcyhlZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAqICB9LCBbXSk7XG4gKlxuICogIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHtcbiAqICAgIG9uQ2hhbmdlLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+U2VsZWN0ZWQgbm9kZXM6IHtzZWxlY3RlZE5vZGVzLmpvaW4oJywgJyl9PC9wPlxuICogICAgICA8cD5TZWxlY3RlZCBlZGdlczoge3NlbGVjdGVkRWRnZXMuam9pbignLCAnKX08L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFlvdSBuZWVkIHRvIG1lbW9pemUgdGhlIHBhc3NlZCBgb25DaGFuZ2VgIGhhbmRsZXIsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gdXNlT25TZWxlY3Rpb25DaGFuZ2UoeyBvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IFsuLi5zdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMsIG9uQ2hhbmdlXTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGVycyA9IHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5maWx0ZXIoKGZuKSA9PiBmbiAhPT0gb25DaGFuZ2UpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0SGFuZGxlcnMgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW29uQ2hhbmdlXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDQgPSAob3B0aW9ucykgPT4gKHMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzKSB7XG4gICAgICAgIHJldHVybiBzLm5vZGVzSW5pdGlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmIChzLm5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgeyBpbnRlcm5hbHMgfV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQgfHwgIW5vZGVIYXNEaW1lbnNpb25zKGludGVybmFscy51c2VyTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFRoaXMgaG9vayB0ZWxscyB5b3Ugd2hldGhlciBhbGwgdGhlIG5vZGVzIGluIGEgZmxvdyBoYXZlIGJlZW4gbWVhc3VyZWQgYW5kIGdpdmVuXG4gKmEgd2lkdGggYW5kIGhlaWdodC4gV2hlbiB5b3UgYWRkIGEgbm9kZSB0byB0aGUgZmxvdywgdGhpcyBob29rIHdpbGwgcmV0dXJuXG4gKmBmYWxzZWAgYW5kIHRoZW4gYHRydWVgIGFnYWluIG9uY2UgdGhlIG5vZGUgaGFzIGJlZW4gbWVhc3VyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIG5vZGVzIGhhdmUgYmVlbiBpbml0aWFsaXplZCBieSB0aGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBhbmRcbiAqIGdpdmVuIGEgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVJlYWN0RmxvdywgdXNlTm9kZXNJbml0aWFsaXplZCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICppbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICpcbiAqY29uc3Qgb3B0aW9ucyA9IHtcbiAqICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTGF5b3V0KCkge1xuICogIGNvbnN0IHsgZ2V0Tm9kZXMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICogIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMpO1xuICogIGNvbnN0IFtsYXlvdXRlZE5vZGVzLCBzZXRMYXlvdXRlZE5vZGVzXSA9IHVzZVN0YXRlKGdldE5vZGVzKCkpO1xuICpcbiAqICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgaWYgKG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAqICAgICAgc2V0TGF5b3V0ZWROb2Rlcyh5b3VyTGF5b3V0aW5nRnVuY3Rpb24oZ2V0Tm9kZXMoKSkpO1xuICogICAgfVxuICogIH0sIFtub2Rlc0luaXRpYWxpemVkXSk7XG4gKlxuICogIHJldHVybiBsYXlvdXRlZE5vZGVzO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbn0pIHtcbiAgICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVN0b3JlKHNlbGVjdG9yJDQob3B0aW9ucykpO1xuICAgIHJldHVybiBpbml0aWFsaXplZDtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIGEgPEhhbmRsZSAvPiBpcyBjb25uZWN0ZWQgdG8gYW5vdGhlciA8SGFuZGxlIC8+IGFuZCBnZXQgdGhlIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBkZXByZWNhdGVkIFVzZSBgdXNlTm9kZUNvbm5lY3Rpb25zYCBpbnN0ZWFkLlxuICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBoYW5kbGUgY29ubmVjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUhhbmRsZUNvbm5lY3Rpb25zKHsgdHlwZSwgaWQsIG5vZGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0pIHtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgdXNlSGFuZGxlQ29ubmVjdGlvbnNgIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL2hvb2tzL3VzZU5vZGVDb25uZWN0aW9ucycpO1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbmNvbnN0IGVycm9yMDE0ID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMTQnXSgpO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiBjb25uZWN0aW9ucyBvbiBhIHNwZWNpZmljIG5vZGUsIGhhbmRsZSB0eXBlICgnc291cmNlJywgJ3RhcmdldCcpIG9yIGhhbmRsZSBJRC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUNvbm5lY3Rpb25zIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VOb2RlQ29ubmVjdGlvbnMoe1xuICogICAgaGFuZGxlVHlwZTogJ3RhcmdldCcsXG4gKiAgICBoYW5kbGVJZDogJ215LWhhbmRsZScsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2Nvbm5lY3Rpb25zLmxlbmd0aH0gaW5jb21pbmcgY29ubmVjdGlvbnMhPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZUNvbm5lY3Rpb25zKHsgaWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSA9IHt9KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IGlkID8/IG5vZGVJZDtcbiAgICBpZiAoIWN1cnJlbnROb2RlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yMDE0KTtcbiAgICB9XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfSR7aGFuZGxlVHlwZSA/IChoYW5kbGVJZCA/IGAtJHtoYW5kbGVUeXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7aGFuZGxlVHlwZX1gKSA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaXNjdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVzRGF0YShub2RlSWRzKSB7XG4gICAgY29uc3Qgbm9kZXNEYXRhID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBpc0FycmF5T2ZJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZHMpO1xuICAgICAgICBjb25zdCBfbm9kZUlkcyA9IGlzQXJyYXlPZklkcyA/IG5vZGVJZHMgOiBbbm9kZUlkc107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIF9ub2RlSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBub2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXlPZklkcyA/IGRhdGEgOiBkYXRhWzBdID8/IG51bGw7XG4gICAgfSwgW25vZGVJZHNdKSwgc2hhbGxvd05vZGVEYXRhKTtcbiAgICByZXR1cm4gbm9kZXNEYXRhO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHNwZWNpZmljIG5vZGUuXG4gKiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9vayB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSBub2RlIGNoYW5nZXMqKixcbiAqIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZCBvciBtb3ZlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgYSBub2RlIHlvdSB3YW50IHRvIG9ic2VydmUuXG4gKiBAcmV0dXJucyBUaGUgYEludGVybmFsTm9kZWAgb2JqZWN0IGZvciB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUludGVybmFsTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGludGVybmFsTm9kZSA9IHVzZUludGVybmFsTm9kZSgnbm9kZS0xJyk7XG4gKiAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpcyBhdDpcbiAqICAgICAgPHA+eDoge2Fic29sdXRlUG9zaXRpb24ueH08L3A+XG4gKiAgICAgIDxwPnk6IHthYnNvbHV0ZVBvc2l0aW9uLnl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlSW50ZXJuYWxOb2RlKGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiBzLm5vZGVMb29rdXAuZ2V0KGlkKSwgW2lkXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBMaW5lUGF0dGVybih7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgdmFyaWFudCwgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogbGluZVdpZHRoLCBkOiBgTSR7ZGltZW5zaW9uc1swXSAvIDJ9IDAgViR7ZGltZW5zaW9uc1sxXX0gTTAgJHtkaW1lbnNpb25zWzFdIC8gMn0gSCR7ZGltZW5zaW9uc1swXX1gLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgdmFyaWFudCwgY2xhc3NOYW1lXSkgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IHJhZGl1cywgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IGN4OiByYWRpdXMsIGN5OiByYWRpdXMsIHI6IHJhZGl1cywgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsICdkb3RzJywgY2xhc3NOYW1lXSkgfSkpO1xufVxuXG4vKipcbiAqIFRoZSB0aHJlZSB2YXJpYW50cyBhcmUgZXhwb3J0ZWQgYXMgYW4gZW51bSBmb3IgY29udmVuaWVuY2UuIFlvdSBjYW4gZWl0aGVyIGltcG9ydFxuICogdGhlIGVudW0gYW5kIHVzZSBpdCBsaWtlIGBCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc2Agb3IgeW91IGNhbiB1c2UgdGhlIHJhdyBzdHJpbmdcbiAqIHZhbHVlIGRpcmVjdGx5LlxuICogQHB1YmxpY1xuICovXG52YXIgQmFja2dyb3VuZFZhcmlhbnQ7XG4oZnVuY3Rpb24gKEJhY2tncm91bmRWYXJpYW50KSB7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJMaW5lc1wiXSA9IFwibGluZXNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkRvdHNcIl0gPSBcImRvdHNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkNyb3NzXCJdID0gXCJjcm9zc1wiO1xufSkoQmFja2dyb3VuZFZhcmlhbnQgfHwgKEJhY2tncm91bmRWYXJpYW50ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+ICh7IHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sIHBhdHRlcm5JZDogYHBhdHRlcm4tJHtzLnJmSWR9YCB9KTtcbmZ1bmN0aW9uIEJhY2tncm91bmRDb21wb25lbnQoeyBpZCwgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHMsIFxuLy8gb25seSB1c2VkIGZvciBkb3RzIGFuZCBjcm9zc1xuZ2FwID0gMjAsIFxuLy8gb25seSB1c2VkIGZvciBsaW5lcyBhbmQgY3Jvc3NcbnNpemUsIGxpbmVXaWR0aCA9IDEsIG9mZnNldCA9IDAsIGNvbG9yLCBiZ0NvbG9yLCBzdHlsZSwgY2xhc3NOYW1lLCBwYXR0ZXJuQ2xhc3NOYW1lLCB9KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYXR0ZXJuSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBvZmZzZXRYWSA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IFtvZmZzZXQsIG9mZnNldF07XG4gICAgY29uc3QgcGF0dGVybkRpbWVuc2lvbnMgPSBpc0Nyb3NzID8gW3NjYWxlZFNpemUsIHNjYWxlZFNpemVdIDogc2NhbGVkR2FwO1xuICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IFtcbiAgICAgICAgb2Zmc2V0WFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzBdIC8gMixcbiAgICAgICAgb2Zmc2V0WFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMixcbiAgICBdO1xuICAgIGNvbnN0IF9wYXR0ZXJuSWQgPSBgJHtwYXR0ZXJuSWR9JHtpZCA/IGlkIDogJyd9YDtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiBiZ0NvbG9yLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLXByb3BzJzogY29sb3IsXG4gICAgICAgIH0sIHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2JhY2tncm91bmRcIiwgY2hpbGRyZW46IFtqc3goXCJwYXR0ZXJuXCIsIHsgaWQ6IF9wYXR0ZXJuSWQsIHg6IHRyYW5zZm9ybVswXSAlIHNjYWxlZEdhcFswXSwgeTogdHJhbnNmb3JtWzFdICUgc2NhbGVkR2FwWzFdLCB3aWR0aDogc2NhbGVkR2FwWzBdLCBoZWlnaHQ6IHNjYWxlZEdhcFsxXSwgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsIHBhdHRlcm5UcmFuc2Zvcm06IGB0cmFuc2xhdGUoLSR7c2NhbGVkT2Zmc2V0WzBdfSwtJHtzY2FsZWRPZmZzZXRbMV19KWAsIGNoaWxkcmVuOiBpc0RvdHMgPyAoanN4KERvdFBhdHRlcm4sIHsgcmFkaXVzOiBzY2FsZWRTaXplIC8gMiwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSA6IChqc3goTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGxpbmVXaWR0aDogbGluZVdpZHRoLCB2YXJpYW50OiB2YXJpYW50LCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIH0pLCBqc3goXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7X3BhdHRlcm5JZH0pYCB9KV0gfSkpO1xufVxuQmFja2dyb3VuZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdCYWNrZ3JvdW5kJztcbi8qKlxuICogVGhlIGA8QmFja2dyb3VuZCAvPmAgY29tcG9uZW50IG1ha2VzIGl0IGNvbnZlbmllbnQgdG8gcmVuZGVyIGRpZmZlcmVudCB0eXBlcyBvZiBiYWNrZ3JvdW5kcyBjb21tb24gaW4gbm9kZS1iYXNlZCBVSXMuIEl0IGNvbWVzIHdpdGggdGhyZWUgdmFyaWFudHM6IGxpbmVzLCBkb3RzIGFuZCBjcm9zcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRvIHVzZSB0aGUgQmFja2dyb3VuZCBjb21wb25lbnQuXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZCBjb2xvcj1cIiNjY2NcIiB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzfSAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgeW91IGNhbiBzZWUgaG93IHRvIGNvbWJpbmUgbXVsdGlwbGUgYmFja2dyb3VuZHNcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqIGltcG9ydCAnQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8UmVhY3RGbG93IGRlZmF1bHROb2Rlcz17Wy4uLl19IGRlZmF1bHRFZGdlcz17Wy4uLl19PlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIxXCJcbiAqICAgICAgICAgZ2FwPXsxMH1cbiAqICAgICAgICAgY29sb3I9XCIjZjFmMWYxXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIyXCJcbiAqICAgICAgICAgZ2FwPXsxMDB9XG4gKiAgICAgICAgIGNvbG9yPVwiI2NjY1wiXG4gKiAgICAgICAgIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkxpbmVzfVxuICogICAgICAgLz5cbiAqICAgICA8L1JlYWN0Rmxvdz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogV2hlbiBjb21iaW5pbmcgbXVsdGlwbGUgPEJhY2tncm91bmQgLz4gY29tcG9uZW50cyBpdOKAmXMgaW1wb3J0YW50IHRvIGdpdmUgZWFjaCBvZiB0aGVtIGEgdW5pcXVlIGlkIHByb3AhXG4gKlxuICovXG5jb25zdCBCYWNrZ3JvdW5kID0gbWVtbyhCYWNrZ3JvdW5kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUGx1c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMyIDE4LjEzM0gxOC4xMzNWMzJoLTQuMjY2VjE4LjEzM0gwdi00LjI2NmgxMy44NjdWMGg0LjI2NnYxMy44NjdIMzJ6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiA1XCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRml0Vmlld0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjkyIDQuNjNjMC0uNTMuNC0uOTM4LjkzOS0uOTM4aDUuMjE1VjBINC43MDhDMi4xMyAwIDAgMi4wNTQgMCA0LjYzdjUuMjE2aDMuNjkyVjQuNjMxek0yNy4zNTQgMGgtNS4ydjMuNjkyaDUuMTdjLjUzIDAgLjk4NC40Ljk4NC45Mzl2NS4yMTVIMzJWNC42MzFBNC42MjQgNC42MjQgMCAwMDI3LjM1NCAwem0uOTU0IDI0LjgzYzAgLjUzMi0uNC45NC0uOTM5Ljk0aC01LjIxNXYzLjc2OGg1LjIxNWMyLjU3NyAwIDQuNjMxLTIuMTMgNC42MzEtNC43MDd2LTUuMTM5aC0zLjY5MnY1LjEzOXptLTIzLjY3Ny45NGMtLjUzMSAwLS45MzktLjQtLjkzOS0uOTR2LTUuMTM4SDB2NS4xMzljMCAyLjU3NyAyLjEzIDQuNzA3IDQuNzA4IDQuNzA3aDUuMTM4VjI1Ljc3SDQuNjMxelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwIDggMCA0LjU3MSAzLjQyOSA0LjU3MSA3LjYxOXYzLjA0OEgzLjA0OEEzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6bTQuNzI0LTEzLjg2Nkg3LjQ2N1Y3LjYxOWMwLTIuNTkgMi4xMzMtNC43MjQgNC43MjMtNC43MjQgMi41OTEgMCA0LjcyNCAyLjEzMyA0LjcyNCA0LjcyNHYzLjA0OHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pIH0pKTtcbn1cblxuLyoqXG4gKiBZb3UgY2FuIGFkZCBidXR0b25zIHRvIHRoZSBjb250cm9sIHBhbmVsIGJ5IHVzaW5nIHRoZSBgPENvbnRyb2xCdXR0b24gLz5gIGNvbXBvbmVudFxuICogYW5kIHBhc3MgaXQgYXMgYSBjaGlsZCB0byB0aGUgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IE1hZ2ljV2FuZCB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1pY29ucydcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scywgQ29udHJvbEJ1dHRvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzPlxuICogICAgICAgIDxDb250cm9sQnV0dG9uIG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdTb21ldGhpbmcgbWFnaWNhbCBqdXN0IGhhcHBlbmVkLiDinKgnKX0+XG4gKiAgICAgICAgICA8TWFnaWNXYW5kIC8+XG4gKiAgICAgICAgPC9Db250cm9sQnV0dG9uPlxuICogICAgICA8L0NvbnRyb2xzPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBDb250cm9sQnV0dG9uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29udHJvbHMtYnV0dG9uJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDIgPSAocykgPT4gKHtcbiAgICBpc0ludGVyYWN0aXZlOiBzLm5vZGVzRHJhZ2dhYmxlIHx8IHMubm9kZXNDb25uZWN0YWJsZSB8fCBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBtaW5ab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPD0gcy5taW5ab29tLFxuICAgIG1heFpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA+PSBzLm1heFpvb20sXG4gICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbn0pO1xuZnVuY3Rpb24gQ29udHJvbHNDb21wb25lbnQoeyBzdHlsZSwgc2hvd1pvb20gPSB0cnVlLCBzaG93Rml0VmlldyA9IHRydWUsIHNob3dJbnRlcmFjdGl2ZSA9IHRydWUsIGZpdFZpZXdPcHRpb25zLCBvblpvb21Jbiwgb25ab29tT3V0LCBvbkZpdFZpZXcsIG9uSW50ZXJhY3RpdmVDaGFuZ2UsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0Jywgb3JpZW50YXRpb24gPSAndmVydGljYWwnLCAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGlzSW50ZXJhY3RpdmUsIG1pblpvb21SZWFjaGVkLCBtYXhab29tUmVhY2hlZCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQyLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IHpvb21Jbiwgem9vbU91dCwgZml0VmlldyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3Qgb25ab29tSW5IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tSW4oKTtcbiAgICAgICAgb25ab29tSW4/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25ab29tT3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbU91dCgpO1xuICAgICAgICBvblpvb21PdXQ/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25GaXRWaWV3SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZml0VmlldyhmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIG9uRml0Vmlldz8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblRvZ2dsZUludGVyYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzRHJhZ2dhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIG5vZGVzQ29ubmVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uSW50ZXJhY3RpdmVDaGFuZ2U/LighaXNJbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmllbnRhdGlvbkNsYXNzID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgcmV0dXJuIChqc3hzKFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIG9yaWVudGF0aW9uQ2xhc3MsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsID8/IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBbc2hvd1pvb20gJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21JbkhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29taW5cIiwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuem9vbUluLmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtYXhab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChQbHVzSWNvbiwge30pIH0pLCBqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21PdXRIYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbW91dFwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBkaXNhYmxlZDogbWluWm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goTWludXNJY29uLCB7fSkgfSldIH0pKSwgc2hvd0ZpdFZpZXcgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1maXR2aWV3XCIsIG9uQ2xpY2s6IG9uRml0Vmlld0hhbmRsZXIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBqc3goRml0Vmlld0ljb24sIHt9KSB9KSksIHNob3dJbnRlcmFjdGl2ZSAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmludGVyYWN0aXZlLmFyaWFMYWJlbCddLCBjaGlsZHJlbjogaXNJbnRlcmFjdGl2ZSA/IGpzeChVbmxvY2tJY29uLCB7fSkgOiBqc3goTG9ja0ljb24sIHt9KSB9KSksIGNoaWxkcmVuXSB9KSk7XG59XG5Db250cm9sc0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdDb250cm9scyc7XG4vKipcbiAqIFRoZSBgPENvbnRyb2xzIC8+YCBjb21wb25lbnQgcmVuZGVycyBhIHNtYWxsIHBhbmVsIHRoYXQgY29udGFpbnMgY29udmVuaWVudFxuICogYnV0dG9ucyB0byB6b29tIGluLCB6b29tIG91dCwgZml0IHRoZSB2aWV3LCBhbmQgbG9jayB0aGUgdmlld3BvcnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQ29udHJvbHMgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17Wy4uLl19IGVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgIDxDb250cm9scyAvPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRvIGV4dGVuZCBvciBjdXN0b21pc2UgdGhlIGNvbnRyb2xzLCB5b3UgY2FuIHVzZSB0aGUgW2A8Q29udHJvbEJ1dHRvbiAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbC1idXR0b24pIGNvbXBvbmVudFxuICpcbiAqL1xuY29uc3QgQ29udHJvbHMgPSBtZW1vKENvbnRyb2xzQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gTWluaU1hcE5vZGVDb21wb25lbnQoeyBpZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGNvbG9yLCBzdHJva2VDb2xvciwgc3Ryb2tlV2lkdGgsIGNsYXNzTmFtZSwgYm9yZGVyUmFkaXVzLCBzaGFwZVJlbmRlcmluZywgc2VsZWN0ZWQsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJhY2tncm91bmRDb2xvciB9ID0gc3R5bGUgfHwge307XG4gICAgY29uc3QgZmlsbCA9IChjb2xvciB8fCBiYWNrZ3JvdW5kIHx8IGJhY2tncm91bmRDb2xvcik7XG4gICAgcmV0dXJuIChqc3goXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiB7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcsIG9uQ2xpY2s6IG9uQ2xpY2sgPyAoZXZlbnQpID0+IG9uQ2xpY2soZXZlbnQsIGlkKSA6IHVuZGVmaW5lZCB9KSk7XG59XG5jb25zdCBNaW5pTWFwTm9kZSA9IG1lbW8oTWluaU1hcE5vZGVDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3Rvck5vZGVJZHMgPSAocykgPT4gcy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuY29uc3QgZ2V0QXR0ckZ1bmN0aW9uID0gKGZ1bmMpID0+IGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZ1bmMgOiAoKSA9PiBmdW5jO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQgPSBNaW5pTWFwTm9kZSwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZShzZWxlY3Rvck5vZGVJZHMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNvbG9yKTtcbiAgICBjb25zdCBub2RlU3Ryb2tlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVTdHJva2VDb2xvcik7XG4gICAgY29uc3Qgbm9kZUNsYXNzTmFtZUZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNsYXNzTmFtZSk7XG4gICAgY29uc3Qgc2hhcGVSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhIXdpbmRvdy5jaHJvbWUgPyAnY3Jpc3BFZGdlcycgOiAnZ2VvbWV0cmljUHJlY2lzaW9uJztcbiAgICByZXR1cm4gKGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gKFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE1pbmlNYXBOb2RlcyBhbmRcbiAgICAgICAgICogTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIGEgc2ltaWxhciBjb21taXQgaW4gYE5vZGVSZW5kZXJlci9pbmRleC50c3hgLlxuICAgICAgICAgKi9cbiAgICAgICAganN4KE5vZGVDb21wb25lbnRXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVDb2xvckZ1bmM6IG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmM6IG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jOiBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIE5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQsIG9uQ2xpY2s6IG9uQ2xpY2ssIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZyB9LCBub2RlSWQpKSkgfSkpO1xufVxuZnVuY3Rpb24gTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcih7IGlkLCBub2RlQ29sb3JGdW5jLCBub2RlU3Ryb2tlQ29sb3JGdW5jLCBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoLCBzaGFwZVJlbmRlcmluZywgTm9kZUNvbXBvbmVudCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBpbnRlcm5hbHMgfSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBub2RlID0gaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaGlkZGVuIHx8ICFub2RlSGFzRGltZW5zaW9ucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTm9kZUNvbXBvbmVudCwgeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogbm9kZS5zdHlsZSwgc2VsZWN0ZWQ6ICEhbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xufVxuY29uc3QgTm9kZUNvbXBvbmVudFdyYXBwZXIgPSBtZW1vKE5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIpO1xudmFyIE1pbmlNYXBOb2RlcyQxID0gbWVtbyhNaW5pTWFwTm9kZXMpO1xuXG5jb25zdCBkZWZhdWx0V2lkdGggPSAyMDA7XG5jb25zdCBkZWZhdWx0SGVpZ2h0ID0gMTUwO1xuY29uc3QgZmlsdGVySGlkZGVuID0gKG5vZGUpID0+ICFub2RlLmhpZGRlbjtcbmNvbnN0IHNlbGVjdG9yJDEgPSAocykgPT4ge1xuICAgIGNvbnN0IHZpZXdCQiA9IHtcbiAgICAgICAgeDogLXMudHJhbnNmb3JtWzBdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC1zLnRyYW5zZm9ybVsxXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogcy53aWR0aCAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0IC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aWV3QkIsXG4gICAgICAgIGJvdW5kaW5nUmVjdDogcy5ub2RlTG9va3VwLnNpemUgPiAwXG4gICAgICAgICAgICA/IGdldEJvdW5kc09mUmVjdHMoZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHsgZmlsdGVyOiBmaWx0ZXJIaWRkZW4gfSksIHZpZXdCQilcbiAgICAgICAgICAgIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgICAgIHBhblpvb206IHMucGFuWm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBzLnRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgZmxvd1dpZHRoOiBzLndpZHRoLFxuICAgICAgICBmbG93SGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbiAgICB9O1xufTtcbmNvbnN0IEFSSUFfTEFCRUxfS0VZID0gJ3JlYWN0LWZsb3dfX21pbmltYXAtZGVzYyc7XG5mdW5jdGlvbiBNaW5pTWFwQ29tcG9uZW50KHsgc3R5bGUsIGNsYXNzTmFtZSwgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQsIGJnQ29sb3IsIG1hc2tDb2xvciwgbWFza1N0cm9rZUNvbG9yLCBtYXNrU3Ryb2tlV2lkdGgsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcsIG9uQ2xpY2ssIG9uTm9kZUNsaWNrLCBwYW5uYWJsZSA9IGZhbHNlLCB6b29tYWJsZSA9IGZhbHNlLCBhcmlhTGFiZWwsIGludmVyc2VQYW4sIHpvb21TdGVwID0gMSwgb2Zmc2V0U2NhbGUgPSA1LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN2ZyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IGJvdW5kaW5nUmVjdCwgdmlld0JCLCByZklkLCBwYW5ab29tLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQxLCBzaGFsbG93KTtcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSBzdHlsZT8ud2lkdGggPz8gZGVmYXVsdFdpZHRoO1xuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBzdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgdmlld1NjYWxlID0gTWF0aC5tYXgoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3Qgdmlld1dpZHRoID0gdmlld1NjYWxlICogZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB2aWV3U2NhbGUgKiBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFNjYWxlICogdmlld1NjYWxlO1xuICAgIGNvbnN0IHggPSBib3VuZGluZ1JlY3QueCAtICh2aWV3V2lkdGggLSBib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB5ID0gYm91bmRpbmdSZWN0LnkgLSAodmlld0hlaWdodCAtIGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdXaWR0aCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdmlld0hlaWdodCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgbGFiZWxsZWRCeSA9IGAke0FSSUFfTEFCRUxfS0VZfS0ke3JmSWR9YDtcbiAgICBjb25zdCB2aWV3U2NhbGVSZWYgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgbWluaW1hcEluc3RhbmNlID0gdXNlUmVmKCk7XG4gICAgdmlld1NjYWxlUmVmLmN1cnJlbnQgPSB2aWV3U2NhbGU7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2Zy5jdXJyZW50ICYmIHBhblpvb20pIHtcbiAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50ID0gWFlNaW5pbWFwKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBzdmcuY3VycmVudCxcbiAgICAgICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0Vmlld1NjYWxlOiAoKSA9PiB2aWV3U2NhbGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtwYW5ab29tXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICB3aWR0aDogZmxvd1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBmbG93SGVpZ2h0LFxuICAgICAgICAgICAgaW52ZXJzZVBhbixcbiAgICAgICAgICAgIHBhbm5hYmxlLFxuICAgICAgICAgICAgem9vbVN0ZXAsXG4gICAgICAgICAgICB6b29tYWJsZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW3Bhbm5hYmxlLCB6b29tYWJsZSwgaW52ZXJzZVBhbiwgem9vbVN0ZXAsIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0XSk7XG4gICAgY29uc3Qgb25TdmdDbGljayA9IG9uQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5wb2ludGVyKGV2ZW50KSB8fCBbMCwgMF07XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TdmdOb2RlQ2xpY2sgPSBvbk5vZGVDbGlja1xuICAgICAgICA/IHVzZUNhbGxiYWNrKChldmVudCwgbm9kZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChub2RlSWQpLmludGVybmFscy51c2VyTm9kZTtcbiAgICAgICAgICAgIG9uTm9kZUNsaWNrKGV2ZW50LCBub2RlKTtcbiAgICAgICAgfSwgW10pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IF9hcmlhTGFiZWwgPSBhcmlhTGFiZWwgPz8gYXJpYUxhYmVsQ29uZmlnWydtaW5pbWFwLmFyaWFMYWJlbCddO1xuICAgIHJldHVybiAoanN4KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIGJnQ29sb3IgPT09ICdzdHJpbmcnID8gYmdDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBtYXNrU3Ryb2tlV2lkdGggKiB2aWV3U2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZVN0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlV2lkdGggPT09ICdudW1iZXInID8gbm9kZVN0cm9rZVdpZHRoIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcCcsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX21pbmltYXBcIiwgY2hpbGRyZW46IGpzeHMoXCJzdmdcIiwgeyB3aWR0aDogZWxlbWVudFdpZHRoLCBoZWlnaHQ6IGVsZW1lbnRIZWlnaHQsIHZpZXdCb3g6IGAke3h9ICR7eX0gJHt3aWR0aH0gJHtoZWlnaHR9YCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtc3ZnXCIsIHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksIHJlZjogc3ZnLCBvbkNsaWNrOiBvblN2Z0NsaWNrLCBjaGlsZHJlbjogW19hcmlhTGFiZWwgJiYganN4KFwidGl0bGVcIiwgeyBpZDogbGFiZWxsZWRCeSwgY2hpbGRyZW46IF9hcmlhTGFiZWwgfSksIGpzeChNaW5pTWFwTm9kZXMkMSwgeyBvbkNsaWNrOiBvblN2Z05vZGVDbGljaywgbm9kZUNvbG9yOiBub2RlQ29sb3IsIG5vZGVTdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlQ2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgbm9kZUNvbXBvbmVudDogbm9kZUNvbXBvbmVudCB9KSwganN4KFwicGF0aFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLW1hc2tcIiwgZDogYE0ke3ggLSBvZmZzZXR9LCR7eSAtIG9mZnNldH1oJHt3aWR0aCArIG9mZnNldCAqIDJ9diR7aGVpZ2h0ICsgb2Zmc2V0ICogMn1oJHstd2lkdGggLSBvZmZzZXQgKiAyfXpcbiAgICAgICAgTSR7dmlld0JCLnh9LCR7dmlld0JCLnl9aCR7dmlld0JCLndpZHRofXYke3ZpZXdCQi5oZWlnaHR9aCR7LXZpZXdCQi53aWR0aH16YCwgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9KV0gfSkgfSkpO1xufVxuTWluaU1hcENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdNaW5pTWFwJztcbi8qKlxuICogVGhlIGA8TWluaU1hcCAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIHJlbmRlciBhbiBvdmVydmlldyBvZiB5b3VyIGZsb3cuIEl0XG4gKiByZW5kZXJzIGVhY2ggbm9kZSBhcyBhbiBTVkcgZWxlbWVudCBhbmQgdmlzdWFsaXplcyB3aGVyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBpc1xuICogaW4gcmVsYXRpb24gdG8gdGhlIHJlc3Qgb2YgdGhlIGZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBNaW5pTWFwIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXV19IGVkZ2VzPXtbLi4uXV19PlxuICogICAgICA8TWluaU1hcCBub2RlU3Ryb2tlV2lkdGg9ezN9IC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBNaW5pTWFwID0gbWVtbyhNaW5pTWFwQ29tcG9uZW50KTtcblxuY29uc3Qgc2NhbGVTZWxlY3RvciA9IChjYWxjdWxhdGVTY2FsZSkgPT4gKHN0b3JlKSA9PiBjYWxjdWxhdGVTY2FsZSA/IGAke01hdGgubWF4KDEgLyBzdG9yZS50cmFuc2Zvcm1bMl0sIDEpfWAgOiB1bmRlZmluZWQ7XG5jb25zdCBkZWZhdWx0UG9zaXRpb25zID0ge1xuICAgIFtSZXNpemVDb250cm9sVmFyaWFudC5MaW5lXTogJ3JpZ2h0JyxcbiAgICBbUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlXTogJ2JvdHRvbS1yaWdodCcsXG59O1xuZnVuY3Rpb24gUmVzaXplQ29udHJvbCh7IG5vZGVJZCwgcG9zaXRpb24sIHZhcmlhbnQgPSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGUsIGNsYXNzTmFtZSwgc3R5bGUgPSB1bmRlZmluZWQsIGNoaWxkcmVuLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIHJlc2l6ZURpcmVjdGlvbiwgYXV0b1NjYWxlID0gdHJ1ZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IGNvbnRleHROb2RlSWQ7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHJlc2l6ZUNvbnRyb2xSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXNIYW5kbGVDb250cm9sID0gdmFyaWFudCA9PT0gUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlO1xuICAgIGNvbnN0IHNjYWxlID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2NhbGVTZWxlY3Rvcihpc0hhbmRsZUNvbnRyb2wgJiYgYXV0b1NjYWxlKSwgW2lzSGFuZGxlQ29udHJvbCwgYXV0b1NjYWxlXSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlc2l6ZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udHJvbFBvc2l0aW9uID0gcG9zaXRpb24gPz8gZGVmYXVsdFBvc2l0aW9uc1t2YXJpYW50XTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCB8fCAhaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50ID0gWFlSZXNpemVyKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiByZXNpemVDb250cm9sUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZURvbU5vZGU6IGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiBjaGFuZ2UueCwgeTogY2hhbmdlLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2hhbmdlLndpZHRoID8/IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGNoYW5nZS5oZWlnaHQgPz8gbm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoYW5nZS54ID8/IG5vZGUucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoYW5nZS55ID8/IG5vZGUucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyB3aWR0aCwgaGVpZ2h0IH0sIG5vZGUucGFyZW50SWQsIG5vZGVMb29rdXAsIG9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KFtjaGlsZF0sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2hlbiB0aGUgcGFyZW50IHdhcyBleHBhbmRlZCBieSB0aGUgY2hpbGQgbm9kZSwgaXRzIHBvc2l0aW9uIHdpbGwgYmUgY2xhbXBlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogMCwwIHdoZW4gbm9kZSBvcmlnaW4gaXMgMCwwIGFuZCB0byB3aWR0aCwgaGVpZ2h0IGlmIGl0J3MgMSwxXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi54ID0gY2hhbmdlLnggPyBNYXRoLm1heChvcmlnaW5bMF0gKiB3aWR0aCwgY2hhbmdlLngpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnkgPSBjaGFuZ2UueSA/IE1hdGgubWF4KG9yaWdpblsxXSAqIGhlaWdodCwgY2hhbmdlLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIG5leHRQb3NpdGlvbi55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4ubmV4dFBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY2hhbmdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXRBdHRyaWJ1dGVzID0gIXJlc2l6ZURpcmVjdGlvbiA/IHRydWUgOiByZXNpemVEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjaGFuZ2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2hhbmdlLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChkaW1lbnNpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRDaGFuZ2Ugb2YgY2hpbGRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25FbmQ6ICh7IHdpZHRoLCBoZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS50cmlnZ2VyTm9kZUNoYW5nZXMoW2RpbWVuc2lvbkNoYW5nZV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNpemVyLmN1cnJlbnQudXBkYXRlKHtcbiAgICAgICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgICAgIGJvdW5kYXJpZXM6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIHJlc2l6ZURpcmVjdGlvbixcbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgIF0pO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NOYW1lcyA9IGNvbnRyb2xQb3NpdGlvbi5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3Jlc2l6ZS1jb250cm9sJywgJ25vZHJhZycsIC4uLnBvc2l0aW9uQ2xhc3NOYW1lcywgdmFyaWFudCwgY2xhc3NOYW1lXSksIHJlZjogcmVzaXplQ29udHJvbFJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICAuLi4oY29sb3IgJiYgeyBbaXNIYW5kbGVDb250cm9sID8gJ2JhY2tncm91bmRDb2xvcicgOiAnYm9yZGVyQ29sb3InXTogY29sb3IgfSksXG4gICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIFRvIGNyZWF0ZSB5b3VyIG93biByZXNpemluZyBVSSwgeW91IGNhbiB1c2UgdGhlIGBOb2RlUmVzaXplQ29udHJvbGAgY29tcG9uZW50IHdoZXJlIHlvdSBjYW4gcGFzcyBjaGlsZHJlbiAoc3VjaCBhcyBpY29ucykuXG4gKiBAcHVibGljXG4gKlxuICovXG5jb25zdCBOb2RlUmVzaXplQ29udHJvbCA9IG1lbW8oUmVzaXplQ29udHJvbCk7XG5cbi8qKlxuICogVGhlIGA8Tm9kZVJlc2l6ZXIgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgYSByZXNpemUgZnVuY3Rpb25hbGl0eSB0byB5b3VyXG4gKiBub2Rlcy4gSXQgcmVuZGVycyBkcmFnZ2FibGUgY29udHJvbHMgYXJvdW5kIHRoZSBub2RlIHRvIHJlc2l6ZSBpbiBhbGwgZGlyZWN0aW9ucy5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVJlc2l6ZXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFJlc2l6YWJsZU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVSZXNpemVyIG1pbldpZHRoPXsxMDB9IG1pbkhlaWdodD17MzB9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6IDEwIH19PntkYXRhLmxhYmVsfTwvZGl2PlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhSZXNpemFibGVOb2RlKTtcbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIE5vZGVSZXNpemVyKHsgbm9kZUlkLCBpc1Zpc2libGUgPSB0cnVlLCBoYW5kbGVDbGFzc05hbWUsIGhhbmRsZVN0eWxlLCBsaW5lQ2xhc3NOYW1lLCBsaW5lU3R5bGUsIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgYXV0b1NjYWxlID0gdHJ1ZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUy5tYXAoKHBvc2l0aW9uKSA9PiAoanN4KE5vZGVSZXNpemVDb250cm9sLCB7IGNsYXNzTmFtZTogbGluZUNsYXNzTmFtZSwgc3R5bGU6IGxpbmVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgdmFyaWFudDogUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgYXV0b1NjYWxlOiBhdXRvU2NhbGUsIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKSwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc05hbWUsIHN0eWxlOiBoYW5kbGVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgYXV0b1NjYWxlOiBhdXRvU2NhbGUsIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKV0gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3JlbmRlcmVyJyk7XG5mdW5jdGlvbiBOb2RlVG9vbGJhclBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB3cmFwcGVyUmVmID0gdXNlU3RvcmUoc2VsZWN0b3IpO1xuICAgIGlmICghd3JhcHBlclJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgd3JhcHBlclJlZik7XG59XG5cbmNvbnN0IG5vZGVFcXVhbGl0eUZuID0gKGEsIGIpID0+IGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggfHxcbiAgICBhPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICE9PSBiPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IHx8XG4gICAgYT8ubWVhc3VyZWQud2lkdGggIT09IGI/Lm1lYXN1cmVkLndpZHRoIHx8XG4gICAgYT8ubWVhc3VyZWQuaGVpZ2h0ICE9PSBiPy5tZWFzdXJlZC5oZWlnaHQgfHxcbiAgICBhPy5zZWxlY3RlZCAhPT0gYj8uc2VsZWN0ZWQgfHxcbiAgICBhPy5pbnRlcm5hbHMueiAhPT0gYj8uaW50ZXJuYWxzLno7XG5jb25zdCBub2Rlc0VxdWFsaXR5Rm4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgYSkge1xuICAgICAgICBpZiAobm9kZUVxdWFsaXR5Rm4obm9kZSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBzdG9yZVNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxuICAgIHNlbGVjdGVkTm9kZXNDb3VudDogc3RhdGUubm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlLnNlbGVjdGVkKS5sZW5ndGgsXG59KTtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgY2FuIHJlbmRlciBhIHRvb2xiYXIgb3IgdG9vbHRpcCB0byBvbmUgc2lkZSBvZiBhIGN1c3RvbSBub2RlLiBUaGlzXG4gKiB0b29sYmFyIGRvZXNuJ3Qgc2NhbGUgd2l0aCB0aGUgdmlld3BvcnQgc28gdGhhdCB0aGUgY29udGVudCBpcyBhbHdheXMgdmlzaWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24sIE5vZGVUb29sYmFyIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBDdXN0b21Ob2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxOb2RlVG9vbGJhciBpc1Zpc2libGU9e2RhdGEudG9vbGJhclZpc2libGV9IHBvc2l0aW9uPXtkYXRhLnRvb2xiYXJQb3NpdGlvbn0+XG4gKiAgICAgICAgPGJ1dHRvbj5kZWxldGU8L2J1dHRvbj5cbiAqICAgICAgICA8YnV0dG9uPmNvcHk8L2J1dHRvbj5cbiAqICAgICAgICA8YnV0dG9uPmV4cGFuZDwvYnV0dG9uPlxuICogICAgICA8L05vZGVUb29sYmFyPlxuICpcbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCAyMHB4JyB9fT5cbiAqICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgPC9kaXY+XG4gKlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IG1lbW8oQ3VzdG9tTm9kZSk7XG4gKmBgYFxuICogQHJlbWFya3MgQnkgZGVmYXVsdCwgdGhlIHRvb2xiYXIgaXMgb25seSB2aXNpYmxlIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkLiBJZiBtdWx0aXBsZVxuICogbm9kZXMgYXJlIHNlbGVjdGVkIGl0IHdpbGwgbm90IGJlIHZpc2libGUgdG8gcHJldmVudCBvdmVybGFwcGluZyB0b29sYmFycyBvclxuICogY2x1dHRlci4gWW91IGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIGJ5IHNldHRpbmcgdGhlIGBpc1Zpc2libGVgIHByb3AgdG8gYHRydWVgLlxuICovXG5mdW5jdGlvbiBOb2RlVG9vbGJhcih7IG5vZGVJZCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgc3R5bGUsIGlzVmlzaWJsZSwgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG9mZnNldCA9IDEwLCBhbGlnbiA9ICdjZW50ZXInLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3Qgbm9kZXNTZWxlY3RvciA9IHVzZUNhbGxiYWNrKChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBub2RlSWRzID0gQXJyYXkuaXNBcnJheShub2RlSWQpID8gbm9kZUlkIDogW25vZGVJZCB8fCBjb250ZXh0Tm9kZUlkIHx8ICcnXTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlcyA9IG5vZGVJZHMucmVkdWNlKChyZXMsIGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RhdGUubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsTm9kZXM7XG4gICAgfSwgW25vZGVJZCwgY29udGV4dE5vZGVJZF0pO1xuICAgIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUobm9kZXNTZWxlY3Rvciwgbm9kZXNFcXVhbGl0eUZuKTtcbiAgICBjb25zdCB7IHgsIHksIHpvb20sIHNlbGVjdGVkTm9kZXNDb3VudCB9ID0gdXNlU3RvcmUoc3RvcmVTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgLy8gaWYgaXNWaXNpYmxlIGlzIG5vdCBzZXQsIHdlIHNob3cgdGhlIHRvb2xiYXIgb25seSBpZiBpdHMgbm9kZSBpcyBzZWxlY3RlZCBhbmQgbm8gb3RoZXIgbm9kZSBpcyBzZWxlY3RlZFxuICAgIGNvbnN0IGlzQWN0aXZlID0gdHlwZW9mIGlzVmlzaWJsZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgID8gaXNWaXNpYmxlXG4gICAgICAgIDogbm9kZXMuc2l6ZSA9PT0gMSAmJiBub2Rlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU/LnNlbGVjdGVkICYmIHNlbGVjdGVkTm9kZXNDb3VudCA9PT0gMTtcbiAgICBpZiAoIWlzQWN0aXZlIHx8ICFub2Rlcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlUmVjdCA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXMpO1xuICAgIGNvbnN0IG5vZGVzQXJyYXkgPSBBcnJheS5mcm9tKG5vZGVzLnZhbHVlcygpKTtcbiAgICBjb25zdCB6SW5kZXggPSBNYXRoLm1heCguLi5ub2Rlc0FycmF5Lm1hcCgobm9kZSkgPT4gbm9kZS5pbnRlcm5hbHMueiArIDEpKTtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0cmFuc2Zvcm06IGdldE5vZGVUb29sYmFyVHJhbnNmb3JtKG5vZGVSZWN0LCB7IHgsIHksIHpvb20gfSwgcG9zaXRpb24sIG9mZnNldCwgYWxpZ24pLFxuICAgICAgICB6SW5kZXgsXG4gICAgICAgIC4uLnN0eWxlLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goTm9kZVRvb2xiYXJQb3J0YWwsIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHN0eWxlOiB3cmFwcGVyU3R5bGUsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2RlLXRvb2xiYXInLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgXCJkYXRhLWlkXCI6IG5vZGVzQXJyYXkucmVkdWNlKChhY2MsIG5vZGUpID0+IGAke2FjY30ke25vZGUuaWR9IGAsICcnKS50cmltKCksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmV4cG9ydCB7IEJhY2tncm91bmQsIEJhY2tncm91bmRWYXJpYW50LCBCYXNlRWRnZSwgQmV6aWVyRWRnZSwgQ29udHJvbEJ1dHRvbiwgQ29udHJvbHMsIEVkZ2VMYWJlbFJlbmRlcmVyLCBFZGdlVGV4dCwgSGFuZGxlLCBNaW5pTWFwLCBNaW5pTWFwTm9kZSwgTm9kZVJlc2l6ZUNvbnRyb2wsIE5vZGVSZXNpemVyLCBOb2RlVG9vbGJhciwgUGFuZWwsIGluZGV4IGFzIFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIFNpbXBsZUJlemllckVkZ2UsIFNtb290aFN0ZXBFZGdlLCBTdGVwRWRnZSwgU3RyYWlnaHRFZGdlLCBWaWV3cG9ydFBvcnRhbCwgYXBwbHlFZGdlQ2hhbmdlcywgYXBwbHlOb2RlQ2hhbmdlcywgZ2V0U2ltcGxlQmV6aWVyUGF0aCwgaXNFZGdlLCBpc05vZGUsIHVzZUNvbm5lY3Rpb24sIHVzZUVkZ2VzLCB1c2VFZGdlc1N0YXRlLCB1c2VIYW5kbGVDb25uZWN0aW9ucywgdXNlSW50ZXJuYWxOb2RlLCB1c2VLZXlQcmVzcywgdXNlTm9kZUNvbm5lY3Rpb25zLCB1c2VOb2RlSWQsIHVzZU5vZGVzLCB1c2VOb2Rlc0RhdGEsIHVzZU5vZGVzSW5pdGlhbGl6ZWQsIHVzZU5vZGVzU3RhdGUsIHVzZU9uU2VsZWN0aW9uQ2hhbmdlLCB1c2VPblZpZXdwb3J0Q2hhbmdlLCB1c2VSZWFjdEZsb3csIHVzZVN0b3JlLCB1c2VTdG9yZUFwaSwgdXNlVXBkYXRlTm9kZUludGVybmFscywgdXNlVmlld3BvcnQgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJmb3J3YXJkUmVmIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIm1lbW8iLCJjYyIsImVycm9yTWVzc2FnZXMiLCJtZXJnZUFyaWFMYWJlbENvbmZpZyIsImluZmluaXRlRXh0ZW50IiwiaXNJbnB1dERPTU5vZGUiLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInBvaW50VG9SZW5kZXJlclBvaW50IiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJpc05vZGVCYXNlIiwiaXNFZGdlQmFzZSIsImdldEVsZW1lbnRzVG9SZW1vdmUiLCJpc1JlY3RPYmplY3QiLCJub2RlVG9SZWN0IiwiZ2V0T3ZlcmxhcHBpbmdBcmVhIiwiZ2V0Tm9kZXNCb3VuZHMiLCJ3aXRoUmVzb2x2ZXJzIiwiZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uIiwiZ2V0RGltZW5zaW9ucyIsIlhZUGFuWm9vbSIsIlBhbk9uU2Nyb2xsTW9kZSIsIlNlbGVjdGlvbk1vZGUiLCJnZXRFdmVudFBvc2l0aW9uIiwiZ2V0Tm9kZXNJbnNpZGUiLCJhcmVTZXRzRXF1YWwiLCJYWURyYWciLCJzbmFwUG9zaXRpb24iLCJjYWxjdWxhdGVOb2RlUG9zaXRpb24iLCJQb3NpdGlvbiIsIkNvbm5lY3Rpb25Nb2RlIiwiaXNNb3VzZUV2ZW50IiwiWFlIYW5kbGUiLCJnZXRIb3N0Rm9yRWxlbWVudCIsImFkZEVkZ2UiLCJnZXRJbnRlcm5hbE5vZGVzQm91bmRzIiwiaXNOdW1lcmljIiwibm9kZUhhc0RpbWVuc2lvbnMiLCJnZXROb2RlRGltZW5zaW9ucyIsImVsZW1lbnRTZWxlY3Rpb25LZXlzIiwiaXNFZGdlVmlzaWJsZSIsIk1hcmtlclR5cGUiLCJjcmVhdGVNYXJrZXJJZHMiLCJnZXRCZXppZXJFZGdlQ2VudGVyIiwiZ2V0U21vb3RoU3RlcFBhdGgiLCJnZXRTdHJhaWdodFBhdGgiLCJnZXRCZXppZXJQYXRoIiwiZ2V0RWRnZVBvc2l0aW9uIiwiZ2V0RWxldmF0ZWRFZGdlWkluZGV4IiwiZ2V0TWFya2VySWQiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiQ29ubmVjdGlvbkxpbmVUeXBlIiwidXBkYXRlQ29ubmVjdGlvbkxvb2t1cCIsImFkb3B0VXNlck5vZGVzIiwiaW5pdGlhbENvbm5lY3Rpb24iLCJkZXZXYXJuIiwiZGVmYXVsdEFyaWFMYWJlbENvbmZpZyIsInVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyIsImhhbmRsZUV4cGFuZFBhcmVudCIsInBhbkJ5IiwiZml0Vmlld3BvcnQiLCJpc01hY09zIiwiYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCIsImhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UiLCJzaGFsbG93Tm9kZURhdGEiLCJYWU1pbmltYXAiLCJnZXRCb3VuZHNPZlJlY3RzIiwiUmVzaXplQ29udHJvbFZhcmlhbnQiLCJYWVJlc2l6ZXIiLCJYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TIiwiWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TIiwiZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0iLCJnZXRDb25uZWN0ZWRFZGdlcyIsImdldEVkZ2VDZW50ZXIiLCJnZXRJbmNvbWVycyIsImdldE91dGdvZXJzIiwicmVjb25uZWN0RWRnZSIsInVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4iLCJjcmVhdGVXaXRoRXF1YWxpdHlGbiIsInNoYWxsb3ciLCJjcmVhdGVQb3J0YWwiLCJTdG9yZUNvbnRleHQiLCJQcm92aWRlciQxIiwiUHJvdmlkZXIiLCJ6dXN0YW5kRXJyb3JNZXNzYWdlIiwidXNlU3RvcmUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJzdG9yZSIsIkVycm9yIiwidXNlU3RvcmVBcGkiLCJnZXRTdGF0ZSIsInNldFN0YXRlIiwic3Vic2NyaWJlIiwic3R5bGUiLCJkaXNwbGF5IiwiYXJpYUxpdmVTdHlsZSIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJtYXJnaW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJjbGlwIiwiY2xpcFBhdGgiLCJBUklBX05PREVfREVTQ19LRVkiLCJBUklBX0VER0VfREVTQ19LRVkiLCJBUklBX0xJVkVfTUVTU0FHRSIsImFyaWFMaXZlU2VsZWN0b3IiLCJzIiwiYXJpYUxpdmVNZXNzYWdlIiwiYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IiLCJhcmlhTGFiZWxDb25maWciLCJBcmlhTGl2ZU1lc3NhZ2UiLCJyZklkIiwiaWQiLCJjaGlsZHJlbiIsIkExMXlEZXNjcmlwdGlvbnMiLCJkaXNhYmxlS2V5Ym9hcmRBMTF5IiwiUGFuZWwiLCJjbGFzc05hbWUiLCJyZXN0IiwicmVmIiwicG9zaXRpb25DbGFzc2VzIiwic3BsaXQiLCJkaXNwbGF5TmFtZSIsIkF0dHJpYnV0aW9uIiwicHJvT3B0aW9ucyIsImhpZGVBdHRyaWJ1dGlvbiIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJzZWxlY3RvciRtIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkRWRnZXMiLCJub2RlIiwibm9kZUxvb2t1cCIsInNlbGVjdGVkIiwicHVzaCIsImludGVybmFscyIsInVzZXJOb2RlIiwiZWRnZSIsImVkZ2VMb29rdXAiLCJzZWxlY3RJZCIsIm9iaiIsImFyZUVxdWFsIiwiYSIsImIiLCJtYXAiLCJTZWxlY3Rpb25MaXN0ZW5lcklubmVyIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJwYXJhbXMiLCJub2RlcyIsImVkZ2VzIiwib25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImZvckVhY2giLCJmbiIsImNoYW5nZVNlbGVjdG9yIiwiU2VsZWN0aW9uTGlzdGVuZXIiLCJzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZGVmYXVsdE5vZGVPcmlnaW4iLCJkZWZhdWx0Vmlld3BvcnQiLCJ4IiwieSIsInpvb20iLCJyZWFjdEZsb3dGaWVsZHNUb1RyYWNrIiwiZmllbGRzVG9UcmFjayIsInNlbGVjdG9yJGwiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwic2V0TWluWm9vbSIsInNldE1heFpvb20iLCJzZXRUcmFuc2xhdGVFeHRlbnQiLCJzZXROb2RlRXh0ZW50IiwicmVzZXQiLCJzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyIsInNldFBhbmVDbGlja0Rpc3RhbmNlIiwiaW5pdFByZXZWYWx1ZXMiLCJ0cmFuc2xhdGVFeHRlbnQiLCJub2RlT3JpZ2luIiwibWluWm9vbSIsIm1heFpvb20iLCJlbGVtZW50c1NlbGVjdGFibGUiLCJub1BhbkNsYXNzTmFtZSIsInBhbmVDbGlja0Rpc3RhbmNlIiwiU3RvcmVVcGRhdGVyIiwicHJvcHMiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJwcmV2aW91c0ZpZWxkcyIsImN1cnJlbnQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwicHJldmlvdXNGaWVsZFZhbHVlIiwiZml0Vmlld1F1ZXVlZCIsImZpdFZpZXdPcHRpb25zIiwiZ2V0TWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJ1c2VDb2xvck1vZGVDbGFzcyIsImNvbG9yTW9kZSIsImNvbG9yTW9kZUNsYXNzIiwic2V0Q29sb3JNb2RlQ2xhc3MiLCJtZWRpYVF1ZXJ5IiwidXBkYXRlQ29sb3JNb2RlQ2xhc3MiLCJtYXRjaGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0RG9jIiwiZG9jdW1lbnQiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJvcHRpb25zIiwiYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIiLCJrZXlQcmVzc2VkIiwic2V0S2V5UHJlc3NlZCIsIm1vZGlmaWVyUHJlc3NlZCIsInByZXNzZWRLZXlzIiwiU2V0Iiwia2V5Q29kZXMiLCJrZXlzVG9XYXRjaCIsImtleUNvZGVBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiZmlsdGVyIiwia2MiLCJyZXBsYWNlIiwia2V5c0ZsYXQiLCJyZWR1Y2UiLCJyZXMiLCJpdGVtIiwiY29uY2F0IiwiZG93bkhhbmRsZXIiLCJldmVudCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJwcmV2ZW50QWN0aW9uIiwia2V5T3JDb2RlIiwidXNlS2V5T3JDb2RlIiwiY29kZSIsImFkZCIsImlzTWF0Y2hpbmdLZXkiLCJjb21wb3NlZFBhdGgiLCJpc0ludGVyYWN0aXZlRWxlbWVudCIsIm5vZGVOYW1lIiwicHJldmVudERlZmF1bHQiLCJ1cEhhbmRsZXIiLCJjbGVhciIsImRlbGV0ZSIsImtleSIsInJlc2V0SGFuZGxlciIsImlzVXAiLCJsZW5ndGgiLCJzaXplIiwic29tZSIsImV2ZXJ5IiwiayIsImhhcyIsImV2ZW50Q29kZSIsImluY2x1ZGVzIiwidXNlVmlld3BvcnRIZWxwZXIiLCJ6b29tSW4iLCJwYW5ab29tIiwic2NhbGVCeSIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ6b29tT3V0Iiwiem9vbVRvIiwiem9vbUxldmVsIiwic2NhbGVUbyIsImdldFpvb20iLCJ0cmFuc2Zvcm0iLCJzZXRWaWV3cG9ydCIsInZpZXdwb3J0IiwidFgiLCJ0WSIsInRab29tIiwiZ2V0Vmlld3BvcnQiLCJzZXRDZW50ZXIiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJlYXNlIiwiaW50ZXJwb2xhdGUiLCJzY3JlZW5Ub0Zsb3dQb3NpdGlvbiIsImNsaWVudFBvc2l0aW9uIiwic25hcEdyaWQiLCJzbmFwVG9HcmlkIiwiZG9tTm9kZSIsImRvbVgiLCJkb21ZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29ycmVjdGVkUG9zaXRpb24iLCJfc25hcEdyaWQiLCJfc25hcFRvR3JpZCIsImZsb3dUb1NjcmVlblBvc2l0aW9uIiwiZmxvd1Bvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJlbGVtZW50cyIsInVwZGF0ZWRFbGVtZW50cyIsImNoYW5nZXNNYXAiLCJNYXAiLCJhZGRJdGVtQ2hhbmdlcyIsImNoYW5nZSIsInR5cGUiLCJzZXQiLCJlbGVtZW50Q2hhbmdlcyIsImdldCIsImVsZW1lbnQiLCJ1cGRhdGVkRWxlbWVudCIsImFwcGx5Q2hhbmdlIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJzcGxpY2UiLCJkcmFnZ2luZyIsImRpbWVuc2lvbnMiLCJtZWFzdXJlZCIsInNldEF0dHJpYnV0ZXMiLCJyZXNpemluZyIsImFwcGx5Tm9kZUNoYW5nZXMiLCJhcHBseUVkZ2VDaGFuZ2VzIiwiY3JlYXRlU2VsZWN0aW9uQ2hhbmdlIiwiZ2V0U2VsZWN0aW9uQ2hhbmdlcyIsIml0ZW1zIiwic2VsZWN0ZWRJZHMiLCJtdXRhdGVJdGVtIiwid2lsbEJlU2VsZWN0ZWQiLCJnZXRFbGVtZW50c0RpZmZDaGFuZ2VzIiwibG9va3VwIiwiaXRlbXNMb29rdXAiLCJlbnRyaWVzIiwibG9va3VwSXRlbSIsInN0b3JlSXRlbSIsIm5leHROb2RlIiwiZWxlbWVudFRvUmVtb3ZlQ2hhbmdlIiwiaXNOb2RlIiwiaXNFZGdlIiwiZml4ZWRGb3J3YXJkUmVmIiwicmVuZGVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZVF1ZXVlIiwicnVuUXVldWUiLCJzZXJpYWwiLCJzZXRTZXJpYWwiLCJCaWdJbnQiLCJxdWV1ZSIsImNyZWF0ZVF1ZXVlIiwibiIsInF1ZXVlSXRlbXMiLCJjYiIsIkJhdGNoQ29udGV4dCIsIkJhdGNoUHJvdmlkZXIiLCJub2RlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdE5vZGVzIiwib25Ob2Rlc0NoYW5nZSIsIm5leHQiLCJwYXlsb2FkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibm9kZVF1ZXVlIiwiZWRnZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHRFZGdlcyIsIm9uRWRnZXNDaGFuZ2UiLCJlZGdlUXVldWUiLCJ2YWx1ZSIsInVzZUJhdGNoQ29udGV4dCIsImJhdGNoQ29udGV4dCIsInNlbGVjdG9yJGsiLCJ1c2VSZWFjdEZsb3ciLCJ2aWV3cG9ydEhlbHBlciIsInZpZXdwb3J0SW5pdGlhbGl6ZWQiLCJnZW5lcmFsSGVscGVyIiwiZ2V0SW50ZXJuYWxOb2RlIiwiZ2V0Tm9kZVJlY3QiLCJub2RlVG9Vc2UiLCJwYXJlbnRJZCIsIm5vZGVXaXRoUG9zaXRpb24iLCJ1cGRhdGVOb2RlIiwibm9kZVVwZGF0ZSIsInByZXZOb2RlcyIsInVwZGF0ZUVkZ2UiLCJlZGdlVXBkYXRlIiwicHJldkVkZ2VzIiwibmV4dEVkZ2UiLCJnZXROb2RlcyIsImdldE5vZGUiLCJnZXRFZGdlcyIsImUiLCJnZXRFZGdlIiwiYWRkTm9kZXMiLCJuZXdOb2RlcyIsImFkZEVkZ2VzIiwibmV3RWRnZXMiLCJ0b09iamVjdCIsImRlbGV0ZUVsZW1lbnRzIiwibm9kZXNUb1JlbW92ZSIsImVkZ2VzVG9SZW1vdmUiLCJvbk5vZGVzRGVsZXRlIiwib25FZGdlc0RlbGV0ZSIsInRyaWdnZXJOb2RlQ2hhbmdlcyIsInRyaWdnZXJFZGdlQ2hhbmdlcyIsIm9uRGVsZXRlIiwib25CZWZvcmVEZWxldGUiLCJtYXRjaGluZ05vZGVzIiwibWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ05vZGVzIiwiZWRnZUNoYW5nZXMiLCJub2RlQ2hhbmdlcyIsImRlbGV0ZWROb2RlcyIsImRlbGV0ZWRFZGdlcyIsImdldEludGVyc2VjdGluZ05vZGVzIiwibm9kZU9yUmVjdCIsInBhcnRpYWxseSIsImlzUmVjdCIsIm5vZGVSZWN0IiwiaGFzTm9kZXNPcHRpb24iLCJpbnRlcm5hbE5vZGUiLCJwb3NpdGlvbkFic29sdXRlIiwiY3Vyck5vZGVSZWN0Iiwib3ZlcmxhcHBpbmdBcmVhIiwicGFydGlhbGx5VmlzaWJsZSIsImlzTm9kZUludGVyc2VjdGluZyIsImFyZWEiLCJ1cGRhdGVOb2RlRGF0YSIsImRhdGFVcGRhdGUiLCJuZXh0RGF0YSIsImRhdGEiLCJ1cGRhdGVFZGdlRGF0YSIsImdldEhhbmRsZUNvbm5lY3Rpb25zIiwibm9kZUlkIiwiZnJvbSIsImNvbm5lY3Rpb25Mb29rdXAiLCJ2YWx1ZXMiLCJnZXROb2RlQ29ubmVjdGlvbnMiLCJoYW5kbGVJZCIsImZpdFZpZXciLCJmaXRWaWV3UmVzb2x2ZXIiLCJwcm9taXNlIiwid2luJDEiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInVwZGF0ZURpbWVuc2lvbnMiLCJvbkVycm9yIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJjb250YWluZXJTdHlsZSIsInRvcCIsImxlZnQiLCJzZWxlY3RvciRqIiwidXNlclNlbGVjdGlvbkFjdGl2ZSIsImxpYiIsIlpvb21QYW5lIiwib25QYW5lQ29udGV4dE1lbnUiLCJ6b29tT25TY3JvbGwiLCJ6b29tT25QaW5jaCIsInBhbk9uU2Nyb2xsIiwicGFuT25TY3JvbGxTcGVlZCIsInBhbk9uU2Nyb2xsTW9kZSIsIkZyZWUiLCJ6b29tT25Eb3VibGVDbGljayIsInBhbk9uRHJhZyIsInpvb21BY3RpdmF0aW9uS2V5Q29kZSIsInByZXZlbnRTY3JvbGxpbmciLCJub1doZWVsQ2xhc3NOYW1lIiwib25WaWV3cG9ydENoYW5nZSIsImlzQ29udHJvbGxlZFZpZXdwb3J0Iiwiem9vbVBhbmUiLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJvblRyYW5zZm9ybUNoYW5nZSIsIm9uRHJhZ2dpbmdDaGFuZ2UiLCJwYW5lRHJhZ2dpbmciLCJvblBhblpvb21TdGFydCIsInZwIiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25Nb3ZlU3RhcnQiLCJvblBhblpvb20iLCJvbk1vdmUiLCJvblBhblpvb21FbmQiLCJvblZpZXdwb3J0Q2hhbmdlRW5kIiwib25Nb3ZlRW5kIiwiY2xvc2VzdCIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJzZWxlY3RvciRpIiwidXNlclNlbGVjdGlvblJlY3QiLCJVc2VyU2VsZWN0aW9uIiwiaXNBY3RpdmUiLCJ3cmFwSGFuZGxlciIsImhhbmRsZXIiLCJjb250YWluZXJSZWYiLCJzZWxlY3RvciRoIiwiY29ubmVjdGlvbkluUHJvZ3Jlc3MiLCJjb25uZWN0aW9uIiwiaW5Qcm9ncmVzcyIsIlBhbmUiLCJpc1NlbGVjdGluZyIsInNlbGVjdGlvbktleVByZXNzZWQiLCJzZWxlY3Rpb25Nb2RlIiwiRnVsbCIsInNlbGVjdGlvbk9uRHJhZyIsIm9uU2VsZWN0aW9uU3RhcnQiLCJvblNlbGVjdGlvbkVuZCIsIm9uUGFuZUNsaWNrIiwib25QYW5lU2Nyb2xsIiwib25QYW5lTW91c2VFbnRlciIsIm9uUGFuZU1vdXNlTW92ZSIsIm9uUGFuZU1vdXNlTGVhdmUiLCJoYXNBY3RpdmVTZWxlY3Rpb24iLCJjb250YWluZXIiLCJjb250YWluZXJCb3VuZHMiLCJzZWxlY3RlZE5vZGVJZHMiLCJzZWxlY3RlZEVkZ2VJZHMiLCJzZWxlY3Rpb25JblByb2dyZXNzIiwic2VsZWN0aW9uU3RhcnRlZCIsIm9uQ2xpY2siLCJyZXNldFNlbGVjdGVkRWxlbWVudHMiLCJvbkNvbnRleHRNZW51Iiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJidXR0b24iLCJzZXRQb2ludGVyQ2FwdHVyZSIsInBvaW50ZXJJZCIsIm5hdGl2ZUV2ZW50Iiwic3RhcnRYIiwic3RhcnRZIiwib25Qb2ludGVyTW92ZSIsImRlZmF1bHRFZGdlT3B0aW9ucyIsIm1vdXNlWCIsIm1vdXNlWSIsIm5leHRVc2VyU2VsZWN0UmVjdCIsIk1hdGgiLCJhYnMiLCJwcmV2U2VsZWN0ZWROb2RlSWRzIiwicHJldlNlbGVjdGVkRWRnZUlkcyIsIlBhcnRpYWwiLCJlZGdlc1NlbGVjdGFibGUiLCJzZWxlY3RhYmxlIiwiY29ubmVjdGlvbnMiLCJlZGdlSWQiLCJvblBvaW50ZXJVcCIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsImRyYWdnYWJsZSIsInNlbGVjdGlvbiIsIm9uUG9pbnRlckVudGVyIiwib25Qb2ludGVyTGVhdmUiLCJoYW5kbGVOb2RlQ2xpY2siLCJ1bnNlbGVjdCIsIm5vZGVSZWYiLCJhZGRTZWxlY3RlZE5vZGVzIiwidW5zZWxlY3ROb2Rlc0FuZEVkZ2VzIiwiYmx1ciIsInVzZURyYWciLCJkaXNhYmxlZCIsIm5vRHJhZ0NsYXNzTmFtZSIsImhhbmRsZVNlbGVjdG9yIiwiaXNTZWxlY3RhYmxlIiwibm9kZUNsaWNrRGlzdGFuY2UiLCJzZXREcmFnZ2luZyIsInh5RHJhZyIsImdldFN0b3JlSXRlbXMiLCJvbk5vZGVNb3VzZURvd24iLCJvbkRyYWdTdGFydCIsIm9uRHJhZ1N0b3AiLCJzZWxlY3RlZEFuZERyYWdnYWJsZSIsIm5vZGVzRHJhZ2dhYmxlIiwidXNlTW92ZVNlbGVjdGVkTm9kZXMiLCJtb3ZlU2VsZWN0ZWROb2RlcyIsIm5vZGVFeHRlbnQiLCJ1cGRhdGVOb2RlUG9zaXRpb25zIiwibm9kZVVwZGF0ZXMiLCJpc1NlbGVjdGVkIiwieFZlbG8iLCJ5VmVsbyIsInhEaWZmIiwiZGlyZWN0aW9uIiwiZmFjdG9yIiwieURpZmYiLCJuZXh0UG9zaXRpb24iLCJOb2RlSWRDb250ZXh0IiwiQ29uc3VtZXIiLCJ1c2VOb2RlSWQiLCJzZWxlY3RvciRnIiwiY29ubmVjdE9uQ2xpY2siLCJjb25uZWN0aW5nU2VsZWN0b3IiLCJzdGF0ZSIsImNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlIiwiY2xpY2tIYW5kbGUiLCJjb25uZWN0aW9uTW9kZSIsImZyb21IYW5kbGUiLCJ0b0hhbmRsZSIsImlzVmFsaWQiLCJjb25uZWN0aW5nVG8iLCJjb25uZWN0aW5nRnJvbSIsImNsaWNrQ29ubmVjdGluZyIsImlzUG9zc2libGVFbmRIYW5kbGUiLCJTdHJpY3QiLCJjb25uZWN0aW9uSW5Qcm9jZXNzIiwiY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzIiwidmFsaWQiLCJIYW5kbGVDb21wb25lbnQiLCJUb3AiLCJpc1ZhbGlkQ29ubmVjdGlvbiIsImlzQ29ubmVjdGFibGUiLCJpc0Nvbm5lY3RhYmxlU3RhcnQiLCJpc0Nvbm5lY3RhYmxlRW5kIiwib25Db25uZWN0Iiwib25Nb3VzZURvd24iLCJvblRvdWNoU3RhcnQiLCJpc1RhcmdldCIsIm9uQ29ubmVjdEV4dGVuZGVkIiwib25Db25uZWN0QWN0aW9uIiwiZWRnZVBhcmFtcyIsImlzTW91c2VUcmlnZ2VyZWQiLCJjdXJyZW50U3RvcmUiLCJoYW5kbGVEb21Ob2RlIiwiY3VycmVudFRhcmdldCIsImF1dG9QYW5PbkNvbm5lY3QiLCJjb25uZWN0aW9uUmFkaXVzIiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0RW5kIiwidXBkYXRlQ29ubmVjdGlvbiIsImdldFRyYW5zZm9ybSIsImdldEZyb21IYW5kbGUiLCJhdXRvUGFuU3BlZWQiLCJkcmFnVGhyZXNob2xkIiwiY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQiLCJvbkNsaWNrQ29ubmVjdFN0YXJ0Iiwib25DbGlja0Nvbm5lY3RFbmQiLCJpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIiwiY29ubmVjdGlvblN0YXRlIiwiaGFuZGxlVHlwZSIsImRvYyIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImhhbmRsZSIsImZyb21Ob2RlSWQiLCJmcm9tSGFuZGxlSWQiLCJmcm9tVHlwZSIsImNvbm5lY3Rpb25DbG9uZSIsInN0cnVjdHVyZWRDbG9uZSIsInRvUG9zaXRpb24iLCJzb3VyY2UiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNsaWNrY29ubmVjdGluZyIsImNvbm5lY3Rpbmdmcm9tIiwiY29ubmVjdGluZ3RvIiwiY29ubmVjdGlvbmluZGljYXRvciIsIkhhbmRsZSIsIklucHV0Tm9kZSIsInNvdXJjZVBvc2l0aW9uIiwiQm90dG9tIiwibGFiZWwiLCJEZWZhdWx0Tm9kZSIsInRhcmdldFBvc2l0aW9uIiwiR3JvdXBOb2RlIiwiT3V0cHV0Tm9kZSIsImFycm93S2V5RGlmZnMiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiQXJyb3dMZWZ0IiwiQXJyb3dSaWdodCIsImJ1aWx0aW5Ob2RlVHlwZXMiLCJpbnB1dCIsImRlZmF1bHQiLCJvdXRwdXQiLCJncm91cCIsImdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMiLCJoYW5kbGVCb3VuZHMiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2VsZWN0b3IkZiIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9uS2V5RG93biIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRhYkluZGV4Iiwid2luIiwic2VsZWN0b3IkZSIsIkZsb3dSZW5kZXJlckNvbXBvbmVudCIsInNlbGVjdGlvbktleUNvZGUiLCJwYW5BY3RpdmF0aW9uS2V5Q29kZSIsIl9wYW5PblNjcm9sbCIsIl9wYW5PbkRyYWciLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIl9zZWxlY3Rpb25PbkRyYWciLCJGbG93UmVuZGVyZXIiLCJzZWxlY3RvciRkIiwib25seVJlbmRlclZpc2libGUiLCJ1c2VWaXNpYmxlTm9kZUlkcyIsIm5vZGVJZHMiLCJzZWxlY3RvciRjIiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1cGRhdGVzIiwiZW50cnkiLCJnZXRBdHRyaWJ1dGUiLCJub2RlRWxlbWVudCIsImZvcmNlIiwiZGlzY29ubmVjdCIsInVzZU5vZGVPYnNlcnZlciIsIm5vZGVUeXBlIiwiaGFzRGltZW5zaW9ucyIsIm9ic2VydmVkTm9kZSIsInByZXZTb3VyY2VQb3NpdGlvbiIsInByZXZUYXJnZXRQb3NpdGlvbiIsInByZXZUeXBlIiwiaXNJbml0aWFsaXplZCIsImhpZGRlbiIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJOb2RlV3JhcHBlciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsIm5vZGVUeXBlcyIsImlzUGFyZW50IiwicGFyZW50TG9va3VwIiwiTm9kZUNvbXBvbmVudCIsImlzRHJhZ2dhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJvbkZvY3VzIiwiYXV0b1Bhbk9uTm9kZUZvY3VzIiwid2l0aGluVmlld3BvcnQiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwicG9pbnRlckV2ZW50cyIsInZpc2liaWxpdHkiLCJyb2xlIiwiYXJpYVJvbGUiLCJhcmlhTGFiZWwiLCJkb21BdHRyaWJ1dGVzIiwicG9zaXRpb25BYnNvbHV0ZVgiLCJwb3NpdGlvbkFic29sdXRlWSIsImRlbGV0YWJsZSIsInNlbGVjdG9yJGIiLCJOb2RlUmVuZGVyZXJDb21wb25lbnQiLCJvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzIiwib25Ob2RlQ2xpY2siLCJvbk5vZGVNb3VzZUVudGVyIiwib25Ob2RlTW91c2VNb3ZlIiwib25Ob2RlTW91c2VMZWF2ZSIsIm9uTm9kZUNvbnRleHRNZW51Iiwib25Ob2RlRG91YmxlQ2xpY2siLCJOb2RlUmVuZGVyZXIiLCJ1c2VWaXNpYmxlRWRnZUlkcyIsImVkZ2VJZHMiLCJ2aXNpYmxlRWRnZUlkcyIsInNvdXJjZU5vZGUiLCJ0YXJnZXROb2RlIiwiQXJyb3dTeW1ib2wiLCJjb2xvciIsInN0cm9rZVdpZHRoIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsImZpbGwiLCJzdHJva2VMaW5lam9pbiIsInBvaW50cyIsIkFycm93Q2xvc2VkU3ltYm9sIiwiTWFya2VyU3ltYm9scyIsIkFycm93IiwiQXJyb3dDbG9zZWQiLCJ1c2VNYXJrZXJTeW1ib2wiLCJzeW1ib2wiLCJzeW1ib2xFeGlzdHMiLCJNYXJrZXIiLCJtYXJrZXJVbml0cyIsIm9yaWVudCIsIlN5bWJvbCIsIm1hcmtlcldpZHRoIiwibWFya2VySGVpZ2h0Iiwidmlld0JveCIsInJlZlgiLCJyZWZZIiwiTWFya2VyRGVmaW5pdGlvbnMiLCJkZWZhdWx0Q29sb3IiLCJtYXJrZXJzIiwiZGVmYXVsdE1hcmtlclN0YXJ0IiwibWFya2VyU3RhcnQiLCJkZWZhdWx0TWFya2VyRW5kIiwibWFya2VyRW5kIiwibWFya2VyIiwiTWFya2VyRGVmaW5pdGlvbnMkMSIsIkVkZ2VUZXh0Q29tcG9uZW50IiwibGFiZWxTdHlsZSIsImxhYmVsU2hvd0JnIiwibGFiZWxCZ1N0eWxlIiwibGFiZWxCZ1BhZGRpbmciLCJsYWJlbEJnQm9yZGVyUmFkaXVzIiwiZWRnZVRleHRCYm94Iiwic2V0RWRnZVRleHRCYm94IiwiZWRnZVRleHRDbGFzc2VzIiwiZWRnZVRleHRSZWYiLCJ0ZXh0QmJveCIsImdldEJCb3giLCJyeCIsInJ5IiwiZHkiLCJFZGdlVGV4dCIsIkJhc2VFZGdlIiwicGF0aCIsImxhYmVsWCIsImxhYmVsWSIsImludGVyYWN0aW9uV2lkdGgiLCJkIiwic3Ryb2tlT3BhY2l0eSIsImdldENvbnRyb2wiLCJwb3MiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIkxlZnQiLCJSaWdodCIsImdldFNpbXBsZUJlemllclBhdGgiLCJzb3VyY2VYIiwic291cmNlWSIsInRhcmdldFgiLCJ0YXJnZXRZIiwic291cmNlQ29udHJvbFgiLCJzb3VyY2VDb250cm9sWSIsInRhcmdldENvbnRyb2xYIiwidGFyZ2V0Q29udHJvbFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImNyZWF0ZVNpbXBsZUJlemllckVkZ2UiLCJfaWQiLCJpc0ludGVybmFsIiwiU2ltcGxlQmV6aWVyRWRnZSIsIlNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCIsImNyZWF0ZVNtb290aFN0ZXBFZGdlIiwicGF0aE9wdGlvbnMiLCJib3JkZXJSYWRpdXMiLCJvZmZzZXQiLCJzdGVwUG9zaXRpb24iLCJTbW9vdGhTdGVwRWRnZSIsIlNtb290aFN0ZXBFZGdlSW50ZXJuYWwiLCJjcmVhdGVTdGVwRWRnZSIsIlN0ZXBFZGdlIiwiU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0cmFpZ2h0RWRnZSIsIlN0cmFpZ2h0RWRnZSIsIlN0cmFpZ2h0RWRnZUludGVybmFsIiwiY3JlYXRlQmV6aWVyRWRnZSIsImN1cnZhdHVyZSIsIkJlemllckVkZ2UiLCJCZXppZXJFZGdlSW50ZXJuYWwiLCJidWlsdGluRWRnZVR5cGVzIiwic3RyYWlnaHQiLCJzdGVwIiwic21vb3Roc3RlcCIsInNpbXBsZWJlemllciIsIm51bGxQb3NpdGlvbiIsInNoaWZ0WCIsInNoaWZ0Iiwic2hpZnRZIiwiRWRnZVVwZGF0ZXJDbGFzc05hbWUiLCJFZGdlQW5jaG9yIiwiY2VudGVyWCIsImNlbnRlclkiLCJyYWRpdXMiLCJvbk1vdXNlT3V0IiwiY3giLCJjeSIsInIiLCJFZGdlVXBkYXRlQW5jaG9ycyIsImlzUmVjb25uZWN0YWJsZSIsInJlY29ubmVjdFJhZGl1cyIsIm9uUmVjb25uZWN0Iiwib25SZWNvbm5lY3RTdGFydCIsIm9uUmVjb25uZWN0RW5kIiwic2V0UmVjb25uZWN0aW5nIiwic2V0VXBkYXRlSG92ZXIiLCJoYW5kbGVFZGdlVXBkYXRlciIsIm9wcG9zaXRlSGFuZGxlIiwiX29uUmVjb25uZWN0RW5kIiwiZXZ0Iiwib25Db25uZWN0RWRnZSIsIl9vbkNvbm5lY3RTdGFydCIsIl9ldmVudCIsImVkZ2VVcGRhdGVyVHlwZSIsIm9uUmVjb25uZWN0U291cmNlTW91c2VEb3duIiwidGFyZ2V0SGFuZGxlIiwib25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24iLCJzb3VyY2VIYW5kbGUiLCJvblJlY29ubmVjdE1vdXNlRW50ZXIiLCJvblJlY29ubmVjdE1vdXNlT3V0IiwiRWRnZVdyYXBwZXIiLCJlZGdlc0ZvY3VzYWJsZSIsImVkZ2VzUmVjb25uZWN0YWJsZSIsImVkZ2VUeXBlcyIsImVkZ2VUeXBlIiwiRWRnZUNvbXBvbmVudCIsInJlY29ubmVjdGFibGUiLCJlZGdlUmVmIiwidXBkYXRlSG92ZXIiLCJyZWNvbm5lY3RpbmciLCJlZGdlUG9zaXRpb24iLCJlbGV2YXRlT25TZWxlY3QiLCJlbGV2YXRlRWRnZXNPblNlbGVjdCIsIm1hcmtlclN0YXJ0VXJsIiwibWFya2VyRW5kVXJsIiwib25FZGdlQ2xpY2siLCJhZGRTZWxlY3RlZEVkZ2VzIiwib25FZGdlRG91YmxlQ2xpY2siLCJvbkVkZ2VDb250ZXh0TWVudSIsIm9uRWRnZU1vdXNlRW50ZXIiLCJvbkVkZ2VNb3VzZU1vdmUiLCJvbkVkZ2VNb3VzZUxlYXZlIiwiYW5pbWF0ZWQiLCJpbmFjdGl2ZSIsInVwZGF0aW5nIiwic291cmNlSGFuZGxlSWQiLCJ0YXJnZXRIYW5kbGVJZCIsInNlbGVjdG9yJGEiLCJFZGdlUmVuZGVyZXJDb21wb25lbnQiLCJkZWZhdWx0TWFya2VyQ29sb3IiLCJFZGdlUmVuZGVyZXIiLCJzZWxlY3RvciQ5IiwiVmlld3BvcnQiLCJ1c2VPbkluaXRIYW5kbGVyIiwib25Jbml0IiwicmZJbnN0YW5jZSIsInNldFRpbWVvdXQiLCJzZWxlY3RvciQ4Iiwic3luY1ZpZXdwb3J0IiwidXNlVmlld3BvcnRTeW5jIiwic3RvcmVTZWxlY3RvciQxIiwidG8iLCJnZXRTZWxlY3RvciIsImNvbm5lY3Rpb25TZWxlY3RvciIsImNvbWJpbmVkU2VsZWN0b3IiLCJ1c2VDb25uZWN0aW9uIiwic2VsZWN0b3IkNyIsIkNvbm5lY3Rpb25MaW5lV3JhcHBlciIsImNvbXBvbmVudCIsInJlbmRlckNvbm5lY3Rpb24iLCJDb25uZWN0aW9uTGluZSIsIkN1c3RvbUNvbXBvbmVudCIsIkJlemllciIsImZyb21Ob2RlIiwiZnJvbVBvc2l0aW9uIiwidG9Ob2RlIiwiY29ubmVjdGlvbkxpbmVUeXBlIiwiY29ubmVjdGlvbkxpbmVTdHlsZSIsImZyb21YIiwiZnJvbVkiLCJ0b1giLCJ0b1kiLCJjb25uZWN0aW9uU3RhdHVzIiwicGF0aFBhcmFtcyIsIlNpbXBsZUJlemllciIsIlN0ZXAiLCJTbW9vdGhTdGVwIiwiZW1wdHlUeXBlcyIsInVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmciLCJub2RlT3JFZGdlVHlwZXMiLCJ0eXBlc1JlZiIsInByb2Nlc3MiLCJ1c2VkS2V5cyIsInVzZVN0eWxlc0xvYWRlZFdhcm5pbmciLCJjaGVja2VkIiwicGFuZSIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRDb21wdXRlZFN0eWxlIiwiR3JhcGhWaWV3Q29tcG9uZW50IiwiY29ubmVjdGlvbkxpbmVDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIiwiR3JhcGhWaWV3IiwiZ2V0SW5pdGlhbFN0YXRlIiwic3RvcmVFZGdlcyIsInN0b3JlTm9kZXMiLCJzdG9yZU5vZGVPcmlnaW4iLCJzdG9yZU5vZGVFeHRlbnQiLCJub2Rlc0luaXRpYWxpemVkIiwiZWxldmF0ZU5vZGVzT25TZWxlY3QiLCJhdXRvUGFuT25Ob2RlRHJhZyIsImRlYnVnIiwiY3JlYXRlU3RvcmUiLCJyZXNvbHZlRml0VmlldyIsImNoZWNrRXF1YWxpdHkiLCJ1cGRhdGVkSW50ZXJuYWxzIiwiY29uc29sZSIsImxvZyIsIm5vZGVEcmFnSXRlbXMiLCJwYXJlbnRFeHBhbmRDaGlsZHJlbiIsImRyYWdJdGVtIiwiZXhwYW5kUGFyZW50IiwibWF4IiwicmVjdCIsInBhcmVudEV4cGFuZENoYW5nZXMiLCJ1cGRhdGVkTm9kZXMiLCJ1cGRhdGVkRWRnZXMiLCJjaGFuZ2VkRWRnZXMiLCJub2Rlc1RvVW5zZWxlY3QiLCJlZGdlc1RvVW5zZWxlY3QiLCJzZXRTY2FsZUV4dGVudCIsImNsaWNrRGlzdGFuY2UiLCJzZXRDbGlja0Rpc3RhbmNlIiwibmV4dE5vZGVFeHRlbnQiLCJkZWx0YSIsIm5leHRab29tIiwiaXMiLCJSZWFjdEZsb3dQcm92aWRlciIsImluaXRpYWxOb2RlcyIsImluaXRpYWxFZGdlcyIsImluaXRpYWxNaW5ab29tIiwiaW5pdGlhbE1heFpvb20iLCJpbml0aWFsRml0Vmlld09wdGlvbnMiLCJXcmFwcGVyIiwiaXNXcmFwcGVkIiwid3JhcHBlclN0eWxlIiwiUmVhY3RGbG93Iiwib25Ob2RlRHJhZ1N0YXJ0Iiwib25Ob2RlRHJhZyIsIm9uTm9kZURyYWdTdG9wIiwib25TZWxlY3Rpb25EcmFnU3RhcnQiLCJvblNlbGVjdGlvbkRyYWciLCJvblNlbGVjdGlvbkRyYWdTdG9wIiwiZGVmYXVsdFZpZXdwb3J0JDEiLCJhdHRyaWJ1dGlvblBvc2l0aW9uIiwib25TY3JvbGwiLCJjb2xvck1vZGVDbGFzc05hbWUiLCJ3cmFwcGVyT25TY3JvbGwiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwic2VsZWN0b3IkNiIsIkVkZ2VMYWJlbFJlbmRlcmVyIiwiZWRnZUxhYmVsUmVuZGVyZXIiLCJzZWxlY3RvciQ1IiwiVmlld3BvcnRQb3J0YWwiLCJ2aWV3UG9ydGFsRGl2IiwidXNlVXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUlkcyIsInVwZGF0ZUlkIiwidHJpZ2dlckZpdFZpZXciLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJ1c2VOb2Rlc1N0YXRlIiwibmRzIiwidXNlRWRnZXNTdGF0ZSIsImVkcyIsInVzZU9uVmlld3BvcnRDaGFuZ2UiLCJvblN0YXJ0Iiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJuZXh0SGFuZGxlcnMiLCJzZWxlY3RvciQ0IiwiaW5jbHVkZUhpZGRlbk5vZGVzIiwidXNlTm9kZXNJbml0aWFsaXplZCIsImluaXRpYWxpemVkIiwidXNlSGFuZGxlQ29ubmVjdGlvbnMiLCJvbkRpc2Nvbm5lY3QiLCJ3YXJuIiwiX25vZGVJZCIsImN1cnJlbnROb2RlSWQiLCJwcmV2Q29ubmVjdGlvbnMiLCJfY29ubmVjdGlvbnMiLCJlcnJvcjAxNCIsInVzZU5vZGVDb25uZWN0aW9ucyIsInVzZU5vZGVzRGF0YSIsIm5vZGVzRGF0YSIsImlzQXJyYXlPZklkcyIsIl9ub2RlSWRzIiwidXNlSW50ZXJuYWxOb2RlIiwiTGluZVBhdHRlcm4iLCJsaW5lV2lkdGgiLCJ2YXJpYW50IiwiRG90UGF0dGVybiIsIkJhY2tncm91bmRWYXJpYW50IiwiZGVmYXVsdFNpemUiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsInNlbGVjdG9yJDMiLCJwYXR0ZXJuSWQiLCJCYWNrZ3JvdW5kQ29tcG9uZW50IiwiZ2FwIiwiYmdDb2xvciIsInBhdHRlcm5DbGFzc05hbWUiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJvZmZzZXRYWSIsInBhdHRlcm5EaW1lbnNpb25zIiwic2NhbGVkT2Zmc2V0IiwiX3BhdHRlcm5JZCIsInBhdHRlcm5Vbml0cyIsInBhdHRlcm5UcmFuc2Zvcm0iLCJCYWNrZ3JvdW5kIiwiUGx1c0ljb24iLCJ4bWxucyIsIk1pbnVzSWNvbiIsIkZpdFZpZXdJY29uIiwiTG9ja0ljb24iLCJVbmxvY2tJY29uIiwiQ29udHJvbEJ1dHRvbiIsInNlbGVjdG9yJDIiLCJpc0ludGVyYWN0aXZlIiwibWluWm9vbVJlYWNoZWQiLCJtYXhab29tUmVhY2hlZCIsIkNvbnRyb2xzQ29tcG9uZW50Iiwic2hvd1pvb20iLCJzaG93Rml0VmlldyIsInNob3dJbnRlcmFjdGl2ZSIsIm9uWm9vbUluIiwib25ab29tT3V0Iiwib25GaXRWaWV3Iiwib25JbnRlcmFjdGl2ZUNoYW5nZSIsIm9yaWVudGF0aW9uIiwib25ab29tSW5IYW5kbGVyIiwib25ab29tT3V0SGFuZGxlciIsIm9uRml0Vmlld0hhbmRsZXIiLCJvblRvZ2dsZUludGVyYWN0aXZpdHkiLCJvcmllbnRhdGlvbkNsYXNzIiwidGl0bGUiLCJDb250cm9scyIsIk1pbmlNYXBOb2RlQ29tcG9uZW50Iiwic3Ryb2tlQ29sb3IiLCJzaGFwZVJlbmRlcmluZyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJNaW5pTWFwTm9kZSIsInNlbGVjdG9yTm9kZUlkcyIsImdldEF0dHJGdW5jdGlvbiIsImZ1bmMiLCJGdW5jdGlvbiIsIk1pbmlNYXBOb2RlcyIsIm5vZGVTdHJva2VDb2xvciIsIm5vZGVDb2xvciIsIm5vZGVDbGFzc05hbWUiLCJub2RlQm9yZGVyUmFkaXVzIiwibm9kZVN0cm9rZVdpZHRoIiwibm9kZUNvbXBvbmVudCIsIm5vZGVDb2xvckZ1bmMiLCJub2RlU3Ryb2tlQ29sb3JGdW5jIiwibm9kZUNsYXNzTmFtZUZ1bmMiLCJjaHJvbWUiLCJOb2RlQ29tcG9uZW50V3JhcHBlciIsIk5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIiLCJNaW5pTWFwTm9kZXMkMSIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRIZWlnaHQiLCJmaWx0ZXJIaWRkZW4iLCJzZWxlY3RvciQxIiwidmlld0JCIiwiYm91bmRpbmdSZWN0IiwiZmxvd1dpZHRoIiwiZmxvd0hlaWdodCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcENvbXBvbmVudCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBhbm5hYmxlIiwiem9vbWFibGUiLCJpbnZlcnNlUGFuIiwiem9vbVN0ZXAiLCJvZmZzZXRTY2FsZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJsYWJlbGxlZEJ5Iiwidmlld1NjYWxlUmVmIiwibWluaW1hcEluc3RhbmNlIiwiZ2V0Vmlld1NjYWxlIiwib25TdmdDbGljayIsInBvaW50ZXIiLCJvblN2Z05vZGVDbGljayIsIl9hcmlhTGFiZWwiLCJmaWxsUnVsZSIsIk1pbmlNYXAiLCJzY2FsZVNlbGVjdG9yIiwiY2FsY3VsYXRlU2NhbGUiLCJkZWZhdWx0UG9zaXRpb25zIiwiTGluZSIsIlJlc2l6ZUNvbnRyb2wiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibWF4SGVpZ2h0Iiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplRGlyZWN0aW9uIiwiYXV0b1NjYWxlIiwic2hvdWxkUmVzaXplIiwib25SZXNpemVTdGFydCIsIm9uUmVzaXplIiwib25SZXNpemVFbmQiLCJjb250ZXh0Tm9kZUlkIiwicmVzaXplQ29udHJvbFJlZiIsImlzSGFuZGxlQ29udHJvbCIsInNjYWxlIiwicmVzaXplciIsImNvbnRyb2xQb3NpdGlvbiIsInBhbmVEb21Ob2RlIiwiY2hpbGRDaGFuZ2VzIiwib3JpZ2luIiwiY2hpbGQiLCJwb3NpdGlvbkNoYW5nZSIsImRpbWVuc2lvbkNoYW5nZSIsImNoaWxkQ2hhbmdlIiwiYm91bmRhcmllcyIsInBvc2l0aW9uQ2xhc3NOYW1lcyIsIk5vZGVSZXNpemVDb250cm9sIiwiTm9kZVJlc2l6ZXIiLCJpc1Zpc2libGUiLCJoYW5kbGVDbGFzc05hbWUiLCJoYW5kbGVTdHlsZSIsImxpbmVDbGFzc05hbWUiLCJsaW5lU3R5bGUiLCJOb2RlVG9vbGJhclBvcnRhbCIsIndyYXBwZXJSZWYiLCJub2RlRXF1YWxpdHlGbiIsIm5vZGVzRXF1YWxpdHlGbiIsInN0b3JlU2VsZWN0b3IiLCJzZWxlY3RlZE5vZGVzQ291bnQiLCJOb2RlVG9vbGJhciIsImFsaWduIiwiaW50ZXJuYWxOb2RlcyIsIm5vZGVzQXJyYXkiLCJhY2MiLCJ0cmltIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ shallow),\n/* harmony export */   shallow: () => (/* binding */ shallow$1)\n/* harmony export */ });\nfunction shallow$1(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar shallow = (objA, objB) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.\"\n    );\n  }\n  return shallow$1(objA, objB);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vc2hhbGxvdy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsiL2hvbWUva25vd21hZGljL3JlcG8gR2l0aHViL3Byb21wdGxlYXJuX2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9zaGFsbG93Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzaGFsbG93JDEob2JqQSwgb2JqQikge1xuICBpZiAoT2JqZWN0LmlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqQSBpbnN0YW5jZW9mIE1hcCAmJiBvYmpCIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgaWYgKG9iakEuc2l6ZSAhPT0gb2JqQi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqQSkge1xuICAgICAgaWYgKCFPYmplY3QuaXModmFsdWUsIG9iakIuZ2V0KGtleSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9iakEgaW5zdGFuY2VvZiBTZXQgJiYgb2JqQiBpbnN0YW5jZW9mIFNldCkge1xuICAgIGlmIChvYmpBLnNpemUgIT09IG9iakIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqQSkge1xuICAgICAgaWYgKCFvYmpCLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmpCKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXlBIG9mIGtleXNBKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5QSkgfHwgIU9iamVjdC5pcyhvYmpBW2tleUFdLCBvYmpCW2tleUFdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHNoYWxsb3cgPSAob2JqQSwgb2JqQikgPT4ge1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBEZWZhdWx0IGV4cG9ydCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdydgLlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvdyQxKG9iakEsIG9iakIpO1xufTtcblxuZXhwb3J0IHsgc2hhbGxvdyBhcyBkZWZhdWx0LCBzaGFsbG93JDEgYXMgc2hhbGxvdyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createWithEqualityFn: () => (/* binding */ createWithEqualityFn),\n/* harmony export */   useStoreWithEqualityFn: () => (/* binding */ useStoreWithEqualityFn)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/vanilla */ \"(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs\");\n\n\n\n\nconst { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_0__;\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__;\nconst identity = (arg) => arg;\nfunction useStoreWithEqualityFn(api, selector = identity, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn) => {\n  const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__.createStore)(createState);\n  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);\n  Object.assign(useBoundStoreWithEqualityFn, api);\n  return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdHJhZGl0aW9uYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlDO0FBQ3VEO0FBQzFDOztBQUU5QyxRQUFRLGdCQUFnQixFQUFFLGtDQUFZO0FBQ3RDLFFBQVEsbUNBQW1DLEVBQUUsMEVBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RCIsInNvdXJjZXMiOlsiL2hvbWUva25vd21hZGljL3JlcG8gR2l0aHViL3Byb21wdGxlYXJuX2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS90cmFkaXRpb25hbC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0RXhwb3J0cyBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzIGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYSc7XG5cbmNvbnN0IHsgdXNlRGVidWdWYWx1ZSB9ID0gUmVhY3RFeHBvcnRzO1xuY29uc3QgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9ID0gdXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzO1xuY29uc3QgaWRlbnRpdHkgPSAoYXJnKSA9PiBhcmc7XG5mdW5jdGlvbiB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuKGFwaSwgc2VsZWN0b3IgPSBpZGVudGl0eSwgZXF1YWxpdHlGbikge1xuICBjb25zdCBzbGljZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIGFwaS5zdWJzY3JpYmUsXG4gICAgYXBpLmdldFN0YXRlLFxuICAgIGFwaS5nZXRTZXJ2ZXJTdGF0ZSB8fCBhcGkuZ2V0SW5pdGlhbFN0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIGVxdWFsaXR5Rm5cbiAgKTtcbiAgdXNlRGVidWdWYWx1ZShzbGljZSk7XG4gIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGNyZWF0ZVdpdGhFcXVhbGl0eUZuSW1wbCA9IChjcmVhdGVTdGF0ZSwgZGVmYXVsdEVxdWFsaXR5Rm4pID0+IHtcbiAgY29uc3QgYXBpID0gY3JlYXRlU3RvcmUoY3JlYXRlU3RhdGUpO1xuICBjb25zdCB1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm4gPSAoc2VsZWN0b3IsIGVxdWFsaXR5Rm4gPSBkZWZhdWx0RXF1YWxpdHlGbikgPT4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihhcGksIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgT2JqZWN0LmFzc2lnbih1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm4sIGFwaSk7XG4gIHJldHVybiB1c2VCb3VuZFN0b3JlV2l0aEVxdWFsaXR5Rm47XG59O1xuY29uc3QgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gPSAoY3JlYXRlU3RhdGUsIGRlZmF1bHRFcXVhbGl0eUZuKSA9PiBjcmVhdGVTdGF0ZSA/IGNyZWF0ZVdpdGhFcXVhbGl0eUZuSW1wbChjcmVhdGVTdGF0ZSwgZGVmYXVsdEVxdWFsaXR5Rm4pIDogY3JlYXRlV2l0aEVxdWFsaXR5Rm5JbXBsO1xuXG5leHBvcnQgeyBjcmVhdGVXaXRoRXF1YWxpdHlGbiwgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   \"default\": () => (/* binding */ vanilla)\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if (( false ? 0 : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFlLEdBQUcsQ0FBb0I7QUFDN0M7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFMkMiLCJzb3VyY2VzIjpbIi9ob21lL2tub3dtYWRpYy9yZXBvIEdpdGh1Yi9wcm9tcHRsZWFybl9mcm9udGVuZC9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3JlYXRlU3RvcmVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKCFPYmplY3QuaXMobmV4dFN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gKHJlcGxhY2UgIT0gbnVsbCA/IHJlcGxhY2UgOiB0eXBlb2YgbmV4dFN0YXRlICE9PSBcIm9iamVjdFwiIHx8IG5leHRTdGF0ZSA9PT0gbnVsbCkgPyBuZXh0U3RhdGUgOiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoc3RhdGUsIHByZXZpb3VzU3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFN0YXRlID0gKCkgPT4gc3RhdGU7XG4gIGNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGluaXRpYWxTdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gKGxpc3RlbmVyKSA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9O1xuICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIltERVBSRUNBVEVEXSBUaGUgYGRlc3Ryb3lgIG1ldGhvZCB3aWxsIGJlIHVuc3VwcG9ydGVkIGluIGEgZnV0dXJlIHZlcnNpb24uIEluc3RlYWQgdXNlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHN1YnNjcmliZS4gRXZlcnl0aGluZyB3aWxsIGJlIGdhcmJhZ2UtY29sbGVjdGVkIGlmIHN0b3JlIGlzIGdhcmJhZ2UtY29sbGVjdGVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfTtcbiAgY29uc3QgYXBpID0geyBzZXRTdGF0ZSwgZ2V0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgc3Vic2NyaWJlLCBkZXN0cm95IH07XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHN0YXRlID0gY3JlYXRlU3RhdGUoc2V0U3RhdGUsIGdldFN0YXRlLCBhcGkpO1xuICByZXR1cm4gYXBpO1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKGNyZWF0ZVN0YXRlKSA9PiBjcmVhdGVTdGF0ZSA/IGNyZWF0ZVN0b3JlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVTdG9yZUltcGw7XG52YXIgdmFuaWxsYSA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBEZWZhdWx0IGV4cG9ydCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBpbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYScuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgdmFuaWxsYSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   defaultAriaLabelConfig: () => (/* binding */ defaultAriaLabelConfig),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   mergeAriaLabelConfig: () => (/* binding */ mergeAriaLabelConfig),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/zoom.js\");\n\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n    'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n    // Control elements\n    'controls.ariaLabel': 'Control Panel',\n    'controls.zoomIn.ariaLabel': 'Zoom In',\n    'controls.zoomOut.ariaLabel': 'Zoom Out',\n    'controls.fitView.ariaLabel': 'Fit View',\n    'controls.interactive.ariaLabel': 'Toggle Interactivity',\n    // Mini map\n    'minimap.ariaLabel': 'Mini Map',\n    // Handle\n    'handle.ariaLabel': 'Handle',\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate,\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return { ...defaultAriaLabelConfig, ...(partial || {}) };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false, }) {\n    if (zIndex !== undefined) {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? 1000 : 0;\n    const nodeZ = Math.max(sourceNode.parentId ? sourceNode.internals.z : 0, targetNode.parentId ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === 'x') {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? (sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition);\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        }\n        else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? (sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n        stepPosition,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    let nodesInitialized = nodes.length > 0;\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({ dragItems, snapGrid, x, y, }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y,\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid\n                ? calculateSnapOffset({\n                    dragItems,\n                    snapGrid,\n                    x,\n                    y,\n                })\n                : null;\n            for (const [id, dragItem] of dragItems) {\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */\n                if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset\n                        ? {\n                            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                            y: Math.round(nextPosition.y + multiDragSnapOffset.y),\n                        }\n                        : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            dragEvent = event.sourceEvent;\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n                const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, { nodeId, handleId, handleType });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!resizeDirection || resizeDirection === 'horizontal') ? width : prevValues.width;\n                change.height =\n                    isHeightChange && (!resizeDirection || resizeDirection === 'vertical') ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2dCO0FBQ2E7QUFDRTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQiw0QkFBNEIsVUFBVSxxQkFBcUIsRUFBRSxPQUFPLEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJnRCIsInNvdXJjZXMiOlsiL2hvbWUva25vd21hZGljL3JlcG8gR2l0aHViL3Byb21wdGxlYXJuX2Zyb250ZW5kL25vZGVfbW9kdWxlcy9AeHlmbG93L3N5c3RlbS9kaXN0L2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkcmFnIH0gZnJvbSAnZDMtZHJhZyc7XG5pbXBvcnQgeyBzZWxlY3QsIHBvaW50ZXIgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5LCB6b29tVHJhbnNmb3JtIH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZVpvb20sIGludGVycG9sYXRlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKGhhbmRsZVR5cGUsIHsgaWQsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH0pID0+IGBDb3VsZG4ndCBjcmVhdGUgZWRnZSBmb3IgJHtoYW5kbGVUeXBlfSBoYW5kbGUgaWQ6IFwiJHtoYW5kbGVUeXBlID09PSAnc291cmNlJyA/IHNvdXJjZUhhbmRsZSA6IHRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtpZH0uYCxcbiAgICBlcnJvcjAxMDogKCkgPT4gJ0hhbmRsZTogTm8gbm9kZSBpZCBmb3VuZC4gTWFrZSBzdXJlIHRvIG9ubHkgdXNlIGEgSGFuZGxlIGluc2lkZSBhIGN1c3RvbSBOb2RlLicsXG4gICAgZXJyb3IwMTE6IChlZGdlVHlwZSkgPT4gYEVkZ2UgdHlwZSBcIiR7ZWRnZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMTI6IChpZCkgPT4gYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3QsIGl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBub2RlIGlzIGRlbGV0ZWQgYmVmb3JlIHRoZSBcIm9uTm9kZUNsaWNrXCIgaGFuZGxlciBpcyBjYWxsZWQuYCxcbiAgICBlcnJvcjAxMzogKGxpYiA9ICdyZWFjdCcpID0+IGBJdCBzZWVtcyB0aGF0IHlvdSBoYXZlbid0IGxvYWRlZCB0aGUgc3R5bGVzLiBQbGVhc2UgaW1wb3J0ICdAeHlmbG93LyR7bGlifS9kaXN0L3N0eWxlLmNzcycgb3IgYmFzZS5jc3MgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgaXMgd29ya2luZyBwcm9wZXJseS5gLFxuICAgIGVycm9yMDE0OiAoKSA9PiAndXNlTm9kZUNvbm5lY3Rpb25zOiBObyBub2RlIElEIGZvdW5kLiBDYWxsIHVzZU5vZGVDb25uZWN0aW9ucyBpbnNpZGUgYSBjdXN0b20gTm9kZSBvciBwcm92aWRlIGEgbm9kZSBJRC4nLFxuICAgIGVycm9yMDE1OiAoKSA9PiAnSXQgc2VlbXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBkcmFnIGEgbm9kZSB0aGF0IGlzIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHVzZSBvbk5vZGVzQ2hhbmdlIGFzIGV4cGxhaW5lZCBpbiB0aGUgZG9jcy4nLFxufTtcbmNvbnN0IGluZmluaXRlRXh0ZW50ID0gW1xuICAgIFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXG4gICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSxcbl07XG5jb25zdCBlbGVtZW50U2VsZWN0aW9uS2V5cyA9IFsnRW50ZXInLCAnICcsICdFc2NhcGUnXTtcbmNvbnN0IGRlZmF1bHRBcmlhTGFiZWxDb25maWcgPSB7XG4gICAgJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnOiAnUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGEgbm9kZS4gUHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBhbmQgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgICdub2RlLmExMXlEZXNjcmlwdGlvbi5rZXlib2FyZERpc2FibGVkJzogJ1ByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhIG5vZGUuIFlvdSBjYW4gdGhlbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgbm9kZSBhcm91bmQuIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAnbm9kZS5hMTF5RGVzY3JpcHRpb24uYXJpYUxpdmVNZXNzYWdlJzogKHsgZGlyZWN0aW9uLCB4LCB5IH0pID0+IGBNb3ZlZCBzZWxlY3RlZCBub2RlICR7ZGlyZWN0aW9ufS4gTmV3IHBvc2l0aW9uLCB4OiAke3h9LCB5OiAke3l9YCxcbiAgICAnZWRnZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCc6ICdQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYW4gZWRnZS4gWW91IGNhbiB0aGVuIHByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgb3IgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgIC8vIENvbnRyb2wgZWxlbWVudHNcbiAgICAnY29udHJvbHMuYXJpYUxhYmVsJzogJ0NvbnRyb2wgUGFuZWwnLFxuICAgICdjb250cm9scy56b29tSW4uYXJpYUxhYmVsJzogJ1pvb20gSW4nLFxuICAgICdjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCc6ICdab29tIE91dCcsXG4gICAgJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJzogJ0ZpdCBWaWV3JyxcbiAgICAnY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJzogJ1RvZ2dsZSBJbnRlcmFjdGl2aXR5JyxcbiAgICAvLyBNaW5pIG1hcFxuICAgICdtaW5pbWFwLmFyaWFMYWJlbCc6ICdNaW5pIE1hcCcsXG4gICAgLy8gSGFuZGxlXG4gICAgJ2hhbmRsZS5hcmlhTGFiZWwnOiAnSGFuZGxlJyxcbn07XG5cbi8qKlxuICogVGhlIGBDb25uZWN0aW9uTW9kZWAgaXMgdXNlZCB0byBzZXQgdGhlIG1vZGUgb2YgY29ubmVjdGlvbiBiZXR3ZWVuIG5vZGVzLlxuICogVGhlIGBTdHJpY3RgIG1vZGUgaXMgdGhlIGRlZmF1bHQgb25lIGFuZCBvbmx5IGFsbG93cyBzb3VyY2UgdG8gdGFyZ2V0IGVkZ2VzLlxuICogYExvb3NlYCBtb2RlIGFsbG93cyBzb3VyY2UgdG8gc291cmNlIGFuZCB0YXJnZXQgdG8gdGFyZ2V0IGVkZ2VzIGFzIHdlbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgQ29ubmVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25Nb2RlKSB7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJTdHJpY3RcIl0gPSBcInN0cmljdFwiO1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiTG9vc2VcIl0gPSBcImxvb3NlXCI7XG59KShDb25uZWN0aW9uTW9kZSB8fCAoQ29ubmVjdGlvbk1vZGUgPSB7fSkpO1xuLyoqXG4gKiBUaGlzIGVudW0gaXMgdXNlZCB0byBzZXQgdGhlIGRpZmZlcmVudCBtb2RlcyBvZiBwYW5uaW5nIHRoZSB2aWV3cG9ydCB3aGVuIHRoZVxuICogdXNlciBzY3JvbGxzLiBUaGUgYEZyZWVgIG1vZGUgYWxsb3dzIHRoZSB1c2VyIHRvIHBhbiBpbiBhbnkgZGlyZWN0aW9uIGJ5IHNjcm9sbGluZ1xuICogd2l0aCBhIGRldmljZSBsaWtlIGEgdHJhY2twYWQuIFRoZSBgVmVydGljYWxgIGFuZCBgSG9yaXpvbnRhbGAgbW9kZXMgcmVzdHJpY3RcbiAqIHNjcm9sbCBwYW5uaW5nIHRvIG9ubHkgdGhlIHZlcnRpY2FsIG9yIGhvcml6b250YWwgYXhpcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBhbk9uU2Nyb2xsTW9kZTtcbihmdW5jdGlvbiAoUGFuT25TY3JvbGxNb2RlKSB7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiRnJlZVwiXSA9IFwiZnJlZVwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIlZlcnRpY2FsXCJdID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkhvcml6b250YWxcIl0gPSBcImhvcml6b250YWxcIjtcbn0pKFBhbk9uU2Nyb2xsTW9kZSB8fCAoUGFuT25TY3JvbGxNb2RlID0ge30pKTtcbnZhciBTZWxlY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25Nb2RlKSB7XG4gICAgU2VsZWN0aW9uTW9kZVtcIlBhcnRpYWxcIl0gPSBcInBhcnRpYWxcIjtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiRnVsbFwiXSA9IFwiZnVsbFwiO1xufSkoU2VsZWN0aW9uTW9kZSB8fCAoU2VsZWN0aW9uTW9kZSA9IHt9KSk7XG5jb25zdCBpbml0aWFsQ29ubmVjdGlvbiA9IHtcbiAgICBpblByb2dyZXNzOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBudWxsLFxuICAgIGZyb206IG51bGwsXG4gICAgZnJvbUhhbmRsZTogbnVsbCxcbiAgICBmcm9tUG9zaXRpb246IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG86IG51bGwsXG4gICAgdG9IYW5kbGU6IG51bGwsXG4gICAgdG9Qb3NpdGlvbjogbnVsbCxcbiAgICB0b05vZGU6IG51bGwsXG59O1xuXG4vKipcbiAqIElmIHlvdSBzZXQgdGhlIGBjb25uZWN0aW9uTGluZVR5cGVgIHByb3Agb24geW91ciBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93I2Nvbm5lY3Rpb24tY29ubmVjdGlvbkxpbmVUeXBlKVxuICpjb21wb25lbnQsIGl0IHdpbGwgZGljdGF0ZSB0aGUgc3R5bGUgb2YgY29ubmVjdGlvbiBsaW5lIHJlbmRlcmVkIHdoZW4gY3JlYXRpbmdcbiAqbmV3IGVkZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UgY2hvb3NlIHRvIHJlbmRlciBhIGN1c3RvbSBjb25uZWN0aW9uIGxpbmUgY29tcG9uZW50LCB0aGlzIHZhbHVlIHdpbGwgYmVcbiAqcGFzc2VkIHRvIHlvdXIgY29tcG9uZW50IGFzIHBhcnQgb2YgaXRzIFtgQ29ubmVjdGlvbkxpbmVDb21wb25lbnRQcm9wc2BdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2Nvbm5lY3Rpb24tbGluZS1jb21wb25lbnQtcHJvcHMpLlxuICovXG52YXIgQ29ubmVjdGlvbkxpbmVUeXBlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTGluZVR5cGUpIHtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJCZXppZXJcIl0gPSBcImRlZmF1bHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdHJhaWdodFwiXSA9IFwic3RyYWlnaHRcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTdGVwXCJdID0gXCJzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU21vb3RoU3RlcFwiXSA9IFwic21vb3Roc3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNpbXBsZUJlemllclwiXSA9IFwic2ltcGxlYmV6aWVyXCI7XG59KShDb25uZWN0aW9uTGluZVR5cGUgfHwgKENvbm5lY3Rpb25MaW5lVHlwZSA9IHt9KSk7XG4vKipcbiAqIEVkZ2VzIG1heSBvcHRpb25hbGx5IGhhdmUgYSBtYXJrZXIgb24gZWl0aGVyIGVuZC4gVGhlIE1hcmtlclR5cGUgdHlwZSBlbnVtZXJhdGVzXG4gKiB0aGUgb3B0aW9ucyBhdmFpbGFibGUgdG8geW91IHdoZW4gY29uZmlndXJpbmcgYSBnaXZlbiBtYXJrZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgTWFya2VyVHlwZTtcbihmdW5jdGlvbiAoTWFya2VyVHlwZSkge1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd1wiXSA9IFwiYXJyb3dcIjtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dDbG9zZWRcIl0gPSBcImFycm93Y2xvc2VkXCI7XG59KShNYXJrZXJUeXBlIHx8IChNYXJrZXJUeXBlID0ge30pKTtcblxuLyoqXG4gKiBXaGlsZSBbYFBhbmVsUG9zaXRpb25gXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9wYW5lbC1wb3NpdGlvbikgY2FuIGJlIHVzZWQgdG8gcGxhY2UgYVxuICogY29tcG9uZW50IGluIHRoZSBjb3JuZXJzIG9mIGEgY29udGFpbmVyLCB0aGUgYFBvc2l0aW9uYCBlbnVtIGlzIGxlc3MgcHJlY2lzZSBhbmQgdXNlZFxuICogcHJpbWFyaWx5IGluIHJlbGF0aW9uIHRvIGVkZ2VzIGFuZCBoYW5kbGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChQb3NpdGlvbikge1xuICAgIFBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIFBvc2l0aW9uW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgICBQb3NpdGlvbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIFBvc2l0aW9uW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG5jb25zdCBvcHBvc2l0ZVBvc2l0aW9uID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogUG9zaXRpb24uUmlnaHQsXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogUG9zaXRpb24uTGVmdCxcbiAgICBbUG9zaXRpb24uVG9wXTogUG9zaXRpb24uQm90dG9tLFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiBQb3NpdGlvbi5Ub3AsXG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYSB8fCAhYiB8fCBhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYS5zaXplICYmICFiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXZSBjYWxsIHRoZSBjYWxsYmFjayBmb3IgYWxsIGNvbm5lY3Rpb25zIGluIGEgdGhhdCBhcmUgbm90IGluIGJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShhLCBiLCBjYikge1xuICAgIGlmICghY2IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaWZmID0gW107XG4gICAgYS5mb3JFYWNoKChjb25uZWN0aW9uLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFiPy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlmZi5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRpZmYubGVuZ3RoKSB7XG4gICAgICAgIGNiKGRpZmYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCkge1xuICAgIHJldHVybiBpc1ZhbGlkID09PSBudWxsID8gbnVsbCA6IGlzVmFsaWQgPyAndmFsaWQnIDogJ2ludmFsaWQnO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhIE5vZGVcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIE5vZGVcbiAqL1xuY29uc3QgaXNOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3Bvc2l0aW9uJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbmNvbnN0IGlzSW50ZXJuYWxOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ2ludGVybmFscycgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF90YXJnZXRfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSBzb3VyY2UgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldE91dGdvZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3Qgb3V0Z29lcnMgPSBnZXRPdXRnb2VycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE91dGdvZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IG91dGdvZXJJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS5zb3VyY2UgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIG91dGdvZXJJZHMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IG91dGdvZXJJZHMuaGFzKG4uaWQpKTtcbn07XG4vKipcbiAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIHRlbGwgeW91IHdoYXQgbm9kZXMsIGlmIGFueSwgYXJlIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gbm9kZVxuICogYXMgdGhlIF9zb3VyY2VfIG9mIGFuIGVkZ2UuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb20uXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzLlxuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVkZ2VzIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldEluY29tZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3QgaW5jb21lcnMgPSBnZXRJbmNvbWVycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldEluY29tZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluY29tZXJzSWRzID0gbmV3IFNldCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UudGFyZ2V0ID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICBpbmNvbWVyc0lkcy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gaW5jb21lcnNJZHMuaGFzKG4uaWQpKTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgY29uc3Qgb2Zmc2V0WCA9IHdpZHRoICogb3JpZ2luWzBdO1xuICAgIGNvbnN0IG9mZnNldFkgPSBoZWlnaHQgKiBvcmlnaW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54IC0gb2Zmc2V0WCxcbiAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55IC0gb2Zmc2V0WSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIHRoZSBnaXZlbiBub2RlcyBpbiBhbiBhcnJheS4gVGhpcyBjYW5cbiAqIGJlIHVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGggW2BnZXRWaWV3cG9ydEZvckJvdW5kc2BdKC9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzKVxuICogdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBVc2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBnZXRWaWV3cG9ydEZvckJvdW5kc30gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBmb3IuXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggZW5jbG9zaW5nIGFsbCBub2Rlcy5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGNhbGxlZCBgZ2V0UmVjdE9mTm9kZXNgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldE5vZGVzQm91bmRzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7XG4gKiAgICBpZDogJ2EnLFxuICogICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICogICAgZGF0YTogeyBsYWJlbDogJ2EnIH0sXG4gKiAgICB3aWR0aDogNTAsXG4gKiAgICBoZWlnaHQ6IDI1LFxuICogIH0sXG4gKiAge1xuICogICAgaWQ6ICdiJyxcbiAqICAgIHBvc2l0aW9uOiB7IHg6IDEwMCwgeTogMTAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYicgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGJvdW5kcyA9IGdldE5vZGVzQm91bmRzKG5vZGVzKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBwYXJhbXMgPSB7IG5vZGVPcmlnaW46IFswLCAwXSB9KSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgYGdldE5vZGVzQm91bmRzYCBmcm9tIGB1c2VSZWFjdEZsb3dgL2B1c2VTdmVsdGVGbG93YCBob29rIHRvIGVuc3VyZSBjb3JyZWN0IHZhbHVlcyBmb3Igc3ViIGZsb3dzLiBJZiBub3QgcG9zc2libGUsIHlvdSBoYXZlIHRvIHByb3ZpZGUgYSBub2RlTG9va3VwIHRvIHN1cHBvcnQgc3ViIGZsb3dzLicpO1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgYm94ID0gbm9kZXMucmVkdWNlKChjdXJyQm94LCBub2RlT3JJZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0lkID0gdHlwZW9mIG5vZGVPcklkID09PSAnc3RyaW5nJztcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gIXBhcmFtcy5ub2RlTG9va3VwICYmICFpc0lkID8gbm9kZU9ySWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBpc0lkXG4gICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgOiAhaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGVPcklkKVxuICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZC5pZClcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlT3JJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlQm94ID0gY3VycmVudE5vZGUgPyBub2RlVG9Cb3goY3VycmVudE5vZGUsIHBhcmFtcy5ub2RlT3JpZ2luKSA6IHsgeDogMCwgeTogMCwgeDI6IDAsIHkyOiAwIH07XG4gICAgICAgIHJldHVybiBnZXRCb3VuZHNPZkJveGVzKGN1cnJCb3gsIG5vZGVCb3gpO1xuICAgIH0sIHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG4vKipcbiAqIERldGVybWluZXMgYSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXlcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzID0gKG5vZGVMb29rdXAsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgaWYgKG5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGxldCBib3ggPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAocGFyYW1zLmZpbHRlciA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5maWx0ZXIobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlVG9Cb3gobm9kZSk7XG4gICAgICAgICAgICBib3ggPSBnZXRCb3VuZHNPZkJveGVzKGJveCwgbm9kZUJveCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm94VG9SZWN0KGJveCk7XG59O1xuY29uc3QgZ2V0Tm9kZXNJbnNpZGUgPSAobm9kZXMsIHJlY3QsIFt0eCwgdHksIHRTY2FsZV0gPSBbMCwgMCwgMV0sIHBhcnRpYWxseSA9IGZhbHNlLCBcbi8vIHNldCBleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIGlmIHlvdSB3YW50IHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIG5vZGVzIFwic2VsZWN0YWJsZVwiIGF0dHJpYnV0ZVxuZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgcGFuZVJlY3QgPSB7XG4gICAgICAgIC4uLnBvaW50VG9SZW5kZXJlclBvaW50KHJlY3QsIFt0eCwgdHksIHRTY2FsZV0pLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7IG1lYXN1cmVkLCBzZWxlY3RhYmxlID0gdHJ1ZSwgaGlkZGVuID0gZmFsc2UgfSA9IG5vZGU7XG4gICAgICAgIGlmICgoZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyAmJiAhc2VsZWN0YWJsZSkgfHwgaGlkZGVuKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVkLndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbnVsbDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBudWxsO1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVUb1JlY3Qobm9kZSkpO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoID8/IDApICogKGhlaWdodCA/PyAwKTtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBmb3JjZUluaXRpYWxSZW5kZXIgPSAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBmb3JjZUluaXRpYWxSZW5kZXIgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZU5vZGVzO1xufTtcbi8qKlxuICogVGhpcyB1dGlsaXR5IGZpbHRlcnMgYW4gYXJyYXkgb2YgZWRnZXMsIGtlZXBpbmcgb25seSB0aG9zZSB3aGVyZSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0YXJnZXRcbiAqIG5vZGUgaXMgcHJlc2VudCBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGNvbm5lY3RlZCBlZGdlcyBmb3IuXG4gKiBAcGFyYW0gZWRnZXMgLSBBbGwgZWRnZXMuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBlZGdlcyB0aGF0IGNvbm5lY3QgYW55IG9mIHRoZSBnaXZlbiBub2RlcyB3aXRoIGVhY2ggb3RoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldENvbm5lY3RlZEVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7IGlkOiAnYScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSB9LFxuICogIHsgaWQ6ICdiJywgcG9zaXRpb246IHsgeDogMTAwLCB5OiAwIH0gfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGVkZ2VzID0gW1xuICogIHsgaWQ6ICdhLT5jJywgc291cmNlOiAnYScsIHRhcmdldDogJ2MnIH0sXG4gKiAgeyBpZDogJ2MtPmQnLCBzb3VyY2U6ICdjJywgdGFyZ2V0OiAnZCcgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZXMsIGVkZ2VzKTtcbiAqIC8vID0+IFt7IGlkOiAnYS0+YycsIHNvdXJjZTogJ2EnLCB0YXJnZXQ6ICdjJyB9XVxuICpgYGBcbiAqL1xuY29uc3QgZ2V0Q29ubmVjdGVkRWRnZXMgPSAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQoKTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIG5vZGVJZHMuYWRkKG5vZGUuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IG5vZGVJZHMuaGFzKGVkZ2Uuc291cmNlKSB8fCBub2RlSWRzLmhhcyhlZGdlLnRhcmdldCkpO1xufTtcbmZ1bmN0aW9uIGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZml0Vmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9wdGlvbk5vZGVJZHMgPSBvcHRpb25zPy5ub2RlcyA/IG5ldyBTZXQob3B0aW9ucy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKSA6IG51bGw7XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IG4ubWVhc3VyZWQud2lkdGggJiYgbi5tZWFzdXJlZC5oZWlnaHQgJiYgKG9wdGlvbnM/LmluY2x1ZGVIaWRkZW5Ob2RlcyB8fCAhbi5oaWRkZW4pO1xuICAgICAgICBpZiAoaXNWaXNpYmxlICYmICghb3B0aW9uTm9kZUlkcyB8fCBvcHRpb25Ob2RlSWRzLmhhcyhuLmlkKSkpIHtcbiAgICAgICAgICAgIGZpdFZpZXdOb2Rlcy5zZXQobi5pZCwgbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZml0Vmlld05vZGVzO1xufVxuYXN5bmMgZnVuY3Rpb24gZml0Vmlld3BvcnQoeyBub2Rlcywgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgbWluWm9vbSwgbWF4Wm9vbSB9LCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXNUb0ZpdCA9IGdldEZpdFZpZXdOb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlc1RvRml0KTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucz8ubWluWm9vbSA/PyBtaW5ab29tLCBvcHRpb25zPy5tYXhab29tID8/IG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiBhIG5vZGUsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG5vZGUncyBleHRlbnQsIHBhcmVudCBub2RlLCBhbmQgb3JpZ2luLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHsgbm9kZUlkLCBuZXh0UG9zaXRpb24sIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0sIG5vZGVFeHRlbnQsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRJZCA/IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgOiB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGxldCBleHRlbnQgPSBub2RlLmV4dGVudCB8fCBub2RlRXh0ZW50O1xuICAgIGlmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgJiYgIW5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnROb2RlLm1lYXN1cmVkLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SGVpZ2h0ID0gcGFyZW50Tm9kZS5tZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFyZW50V2lkdGggJiYgcGFyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Tm9kZSAmJiBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpKSB7XG4gICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgZXh0ZW50LCBub2RlLm1lYXN1cmVkKVxuICAgICAgICA6IG5leHRQb3NpdGlvbjtcbiAgICBpZiAobm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxNSddKCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54IC0gcGFyZW50WCArIChub2RlLm1lYXN1cmVkLndpZHRoID8/IDApICogb3JpZ2luWzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55IC0gcGFyZW50WSArIChub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXSxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXNzIGluIG5vZGVzICYgZWRnZXMgdG8gZGVsZXRlLCBnZXQgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcyB0aGF0IGFjdHVhbGx5IGNhbiBiZSBkZWxldGVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYXJhbS5ub2Rlc1RvUmVtb3ZlIC0gVGhlIG5vZGVzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLmVkZ2VzVG9SZW1vdmUgLSBUaGUgZWRnZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXMgLSBBbGwgbm9kZXNcbiAqIEBwYXJhbSBwYXJhbS5lZGdlcyAtIEFsbCBlZGdlc1xuICogQHBhcmFtIHBhcmFtLm9uQmVmb3JlRGVsZXRlIC0gQ2FsbGJhY2sgdG8gY2hlY2sgd2hpY2ggbm9kZXMgYW5kIGVkZ2VzIGNhbiBiZSBkZWxldGVkXG4gKiBAcmV0dXJucyBub2Rlczogbm9kZXMgdGhhdCBjYW4gYmUgZGVsZXRlZCwgZWRnZXM6IGVkZ2VzIHRoYXQgY2FuIGJlIGRlbGV0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudHNUb1JlbW92ZSh7IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXNUb1JlbW92ZSA9IFtdLCBub2RlcywgZWRnZXMsIG9uQmVmb3JlRGVsZXRlLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQobm9kZXNUb1JlbW92ZS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICBjb25zdCBtYXRjaGluZ05vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLmRlbGV0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBub2RlSWRzLmhhcyhub2RlLmlkKTtcbiAgICAgICAgY29uc3QgcGFyZW50SGl0ID0gIWlzSW5jbHVkZWQgJiYgbm9kZS5wYXJlbnRJZCAmJiBtYXRjaGluZ05vZGVzLmZpbmQoKG4pID0+IG4uaWQgPT09IG5vZGUucGFyZW50SWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCB8fCBwYXJlbnRIaXQpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGdlSWRzID0gbmV3IFNldChlZGdlc1RvUmVtb3ZlLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLmRlbGV0YWJsZSAhPT0gZmFsc2UpO1xuICAgIGNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobWF0Y2hpbmdOb2RlcywgZGVsZXRhYmxlRWRnZXMpO1xuICAgIGNvbnN0IG1hdGNoaW5nRWRnZXMgPSBjb25uZWN0ZWRFZGdlcztcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZGVsZXRhYmxlRWRnZXMpIHtcbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IGVkZ2VJZHMuaGFzKGVkZ2UuaWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCAmJiAhbWF0Y2hpbmdFZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBlZGdlLmlkKSkge1xuICAgICAgICAgICAgbWF0Y2hpbmdFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb25CZWZvcmVEZWxldGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgICAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9uQmVmb3JlRGVsZXRlUmVzdWx0ID0gYXdhaXQgb25CZWZvcmVEZWxldGUoe1xuICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA/IHsgZWRnZXM6IG1hdGNoaW5nRWRnZXMsIG5vZGVzOiBtYXRjaGluZ05vZGVzIH0gOiB7IGVkZ2VzOiBbXSwgbm9kZXM6IFtdIH07XG4gICAgfVxuICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdDtcbn1cblxuY29uc3QgY2xhbXAgPSAodmFsLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG5jb25zdCBjbGFtcFBvc2l0aW9uID0gKHBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH0sIGV4dGVudCwgZGltZW5zaW9ucykgPT4gKHtcbiAgICB4OiBjbGFtcChwb3NpdGlvbi54LCBleHRlbnRbMF1bMF0sIGV4dGVudFsxXVswXSAtIChkaW1lbnNpb25zPy53aWR0aCA/PyAwKSksXG4gICAgeTogY2xhbXAocG9zaXRpb24ueSwgZXh0ZW50WzBdWzFdLCBleHRlbnRbMV1bMV0gLSAoZGltZW5zaW9ucz8uaGVpZ2h0ID8/IDApKSxcbn0pO1xuZnVuY3Rpb24gY2xhbXBQb3NpdGlvblRvUGFyZW50KGNoaWxkUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50KSB7XG4gICAgY29uc3QgeyB3aWR0aDogcGFyZW50V2lkdGgsIGhlaWdodDogcGFyZW50SGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIHJldHVybiBjbGFtcFBvc2l0aW9uKGNoaWxkUG9zaXRpb24sIFtcbiAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICBdLCBjaGlsZERpbWVuc2lvbnMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXNcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZhbHVlIC0gT25lIGRpbWVuc2lvbmFsIHBvaXRpb24gb2YgdGhlIG1vdXNlICh4IG9yIHkpXG4gKiBAcGFyYW0gbWluIC0gTWluaW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcGFyYW0gbWF4IC0gTWF4aW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcmV0dXJucyAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB0aGF0IHJlcHJlc2VudHMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmdcbiAqL1xuY29uc3QgY2FsY0F1dG9QYW5WZWxvY2l0eSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWluKSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIC1jbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1heCksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGNhbGNBdXRvUGFuID0gKHBvcywgYm91bmRzLCBzcGVlZCA9IDE1LCBkaXN0YW5jZSA9IDQwKSA9PiB7XG4gICAgY29uc3QgeE1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueCwgZGlzdGFuY2UsIGJvdW5kcy53aWR0aCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIGNvbnN0IHlNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLnksIGRpc3RhbmNlLCBib3VuZHMuaGVpZ2h0IC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgcmV0dXJuIFt4TW92ZW1lbnQsIHlNb3ZlbWVudF07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZCb3hlcyA9IChib3gxLCBib3gyKSA9PiAoe1xuICAgIHg6IE1hdGgubWluKGJveDEueCwgYm94Mi54KSxcbiAgICB5OiBNYXRoLm1pbihib3gxLnksIGJveDIueSksXG4gICAgeDI6IE1hdGgubWF4KGJveDEueDIsIGJveDIueDIpLFxuICAgIHkyOiBNYXRoLm1heChib3gxLnkyLCBib3gyLnkyKSxcbn0pO1xuY29uc3QgcmVjdFRvQm94ID0gKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0LFxufSk7XG5jb25zdCBib3hUb1JlY3QgPSAoeyB4LCB5LCB4MiwgeTIgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHgyIC0geCxcbiAgICBoZWlnaHQ6IHkyIC0geSxcbn0pO1xuY29uc3Qgbm9kZVRvUmVjdCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufTtcbmNvbnN0IG5vZGVUb0JveCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4MjogeCArIChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDApLFxuICAgICAgICB5MjogeSArIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDApLFxuICAgIH07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZSZWN0cyA9IChyZWN0MSwgcmVjdDIpID0+IGJveFRvUmVjdChnZXRCb3VuZHNPZkJveGVzKHJlY3RUb0JveChyZWN0MSksIHJlY3RUb0JveChyZWN0MikpKTtcbmNvbnN0IGdldE92ZXJsYXBwaW5nQXJlYSA9IChyZWN0QSwgcmVjdEIpID0+IHtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnggKyByZWN0QS53aWR0aCwgcmVjdEIueCArIHJlY3RCLndpZHRoKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnkgKyByZWN0QS5oZWlnaHQsIHJlY3RCLnkgKyByZWN0Qi5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSkpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGlzUmVjdE9iamVjdCA9IChvYmopID0+IGlzTnVtZXJpYyhvYmoud2lkdGgpICYmIGlzTnVtZXJpYyhvYmouaGVpZ2h0KSAmJiBpc051bWVyaWMob2JqLngpICYmIGlzTnVtZXJpYyhvYmoueSk7XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgaXNOdW1lcmljID0gKG4pID0+ICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKTtcbi8vIHVzZWQgZm9yIGExMXkga2V5IGJvYXJkIGNvbnRyb2xzIGZvciBub2RlcyBhbmQgZWRnZXNcbmNvbnN0IGRldldhcm4gPSAoaWQsIG1lc3NhZ2UpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbUmVhY3QgRmxvd106ICR7bWVzc2FnZX0gSGVscDogaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2Vycm9yIyR7aWR9YCk7XG4gICAgfVxufTtcbmNvbnN0IHNuYXBQb3NpdGlvbiA9IChwb3NpdGlvbiwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKSxcbiAgICAgICAgeTogc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnkgLyBzbmFwR3JpZFsxXSksXG4gICAgfTtcbn07XG5jb25zdCBwb2ludFRvUmVuZGVyZXJQb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSwgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICB4OiAoeCAtIHR4KSAvIHRTY2FsZSxcbiAgICAgICAgeTogKHkgLSB0eSkgLyB0U2NhbGUsXG4gICAgfTtcbiAgICByZXR1cm4gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb3NpdGlvbiwgc25hcEdyaWQpIDogcG9zaXRpb247XG59O1xuY29uc3QgcmVuZGVyZXJQb2ludFRvUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICogdFNjYWxlICsgdHgsXG4gICAgICAgIHk6IHkgKiB0U2NhbGUgKyB0eSxcbiAgICB9O1xufTtcbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIHBhZGRpbmcgdmFsdWUgdG8gYSBudW1iZXJcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0gdmlld3BvcnQgLSBXaWR0aCBvciBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIHZpZXdwb3J0KSB7XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodmlld3BvcnQgLSB2aWV3cG9ydCAvICgxICsgcGFkZGluZykpICogMC41KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyAmJiBwYWRkaW5nLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdWYWx1ZSA9IHBhcnNlRmxvYXQocGFkZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhZGRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHBhZGRpbmdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyAmJiBwYWRkaW5nLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ZhbHVlID0gcGFyc2VGbG9hdChwYWRkaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFkZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iodmlld3BvcnQgKiBwYWRkaW5nVmFsdWUgKiAwLjAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBbUmVhY3QgRmxvd10gVGhlIHBhZGRpbmcgdmFsdWUgXCIke3BhZGRpbmd9XCIgaXMgaW52YWxpZC4gUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb3IgYSBzdHJpbmcgd2l0aCBhIHZhbGlkIHVuaXQgKHB4IG9yICUpLmApO1xuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIHBhZGRpbmdzIHRvIGFuIG9iamVjdCB3aXRoIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgeCBhbmQgeSBwYWRkaW5nc1xuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBwYWRkaW5ncyBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWRkaW5ncyhwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSBwYXJzZVBhZGRpbmcocGFkZGluZywgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSBwYXJzZVBhZGRpbmcocGFkZGluZywgd2lkdGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBwYWRkaW5nWSxcbiAgICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nWCxcbiAgICAgICAgICAgIGJvdHRvbTogcGFkZGluZ1ksXG4gICAgICAgICAgICBsZWZ0OiBwYWRkaW5nWCxcbiAgICAgICAgICAgIHg6IHBhZGRpbmdYICogMixcbiAgICAgICAgICAgIHk6IHBhZGRpbmdZICogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCB0b3AgPSBwYXJzZVBhZGRpbmcocGFkZGluZy50b3AgPz8gcGFkZGluZy55ID8/IDAsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLmJvdHRvbSA/PyBwYWRkaW5nLnkgPz8gMCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLmxlZnQgPz8gcGFkZGluZy54ID8/IDAsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZVBhZGRpbmcocGFkZGluZy5yaWdodCA/PyBwYWRkaW5nLnggPz8gMCwgd2lkdGgpO1xuICAgICAgICByZXR1cm4geyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHg6IGxlZnQgKyByaWdodCwgeTogdG9wICsgYm90dG9tIH07XG4gICAgfVxuICAgIHJldHVybiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgeDogMCwgeTogMCB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgcGFkZGluZ3MgaWYgdGhlIG5ldyB2aWV3cG9ydCBpcyBhcHBsaWVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBib3VuZHMgLSBCb3VuZHMgdG8gZml0IGluc2lkZSB2aWV3cG9ydFxuICogQHBhcmFtIHggLSBYIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHkgLSBZIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIG1pbmltdW0gcGFkZGluZyByZXF1aXJlZCB0byBmaXQgdGhlIGJvdW5kcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFwcGxpZWRQYWRkaW5ncyhib3VuZHMsIHgsIHksIHpvb20sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7IHg6IGxlZnQsIHk6IHRvcCB9ID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoYm91bmRzLCBbeCwgeSwgem9vbV0pO1xuICAgIGNvbnN0IHsgeDogYm91bmRSaWdodCwgeTogYm91bmRCb3R0b20gfSA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KHsgeDogYm91bmRzLnggKyBib3VuZHMud2lkdGgsIHk6IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCB9LCBbeCwgeSwgem9vbV0pO1xuICAgIGNvbnN0IHJpZ2h0ID0gd2lkdGggLSBib3VuZFJpZ2h0O1xuICAgIGNvbnN0IGJvdHRvbSA9IGhlaWdodCAtIGJvdW5kQm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IE1hdGguZmxvb3IobGVmdCksXG4gICAgICAgIHRvcDogTWF0aC5mbG9vcih0b3ApLFxuICAgICAgICByaWdodDogTWF0aC5mbG9vcihyaWdodCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5mbG9vcihib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgYSB2aWV3cG9ydCB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2l0aCBwYWRkaW5nLlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgWW91IGNhbiBkZXRlcm1pbmUgYm91bmRzIG9mIG5vZGVzIHdpdGgge0BsaW5rIGdldE5vZGVzQm91bmRzfSBhbmQge0BsaW5rIGdldEJvdW5kc09mUmVjdHN9XG4gKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGZpdCBpbnNpZGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gaGVpZ2h0ICAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gbWluWm9vbSAtIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0LlxuICogQHBhcmFtIG1heFpvb20gLSBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydC5cbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyBhcm91bmQgdGhlIGJvdW5kcy5cbiAqIEByZXR1cm5zIEEgdHJhbnNmb3JtZWQge0BsaW5rIFZpZXdwb3J0fSB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2hpY2ggeW91IGNhbiBwYXNzIHRvIGUuZy4ge0BsaW5rIHNldFZpZXdwb3J0fS5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKFxuICogeyB4OiAwLCB5OiAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH0sXG4gKiAxMjAwLCA4MDAsIDAuNSwgMik7XG4gKi9cbmNvbnN0IGdldFZpZXdwb3J0Rm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZykgPT4ge1xuICAgIC8vIEZpcnN0IHdlIHJlc29sdmUgYWxsIHRoZSBwYWRkaW5ncyB0byBhY3R1YWwgcGl4ZWwgdmFsdWVzXG4gICAgY29uc3QgcCA9IHBhcnNlUGFkZGluZ3MocGFkZGluZywgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgeFpvb20gPSAod2lkdGggLSBwLngpIC8gYm91bmRzLndpZHRoO1xuICAgIGNvbnN0IHlab29tID0gKGhlaWdodCAtIHAueSkgLyBib3VuZHMuaGVpZ2h0O1xuICAgIC8vIFdlIGNhbGN1bGF0ZSB0aGUgbmV3IHgsIHksIHpvb20gZm9yIGEgY2VudGVyZWQgdmlld1xuICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih4Wm9vbSwgeVpvb20pO1xuICAgIGNvbnN0IGNsYW1wZWRab29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWCA9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMjtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJZID0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCB4ID0gd2lkdGggLyAyIC0gYm91bmRzQ2VudGVyWCAqIGNsYW1wZWRab29tO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLyAyIC0gYm91bmRzQ2VudGVyWSAqIGNsYW1wZWRab29tO1xuICAgIC8vIFRoZW4gd2UgY2FsY3VsYXRlIHRoZSBtaW5pbXVtIHBhZGRpbmcsIHRvIHJlc3BlY3QgYXN5bW1ldHJpYyBwYWRkaW5nc1xuICAgIGNvbnN0IG5ld1BhZGRpbmcgPSBjYWxjdWxhdGVBcHBsaWVkUGFkZGluZ3MoYm91bmRzLCB4LCB5LCBjbGFtcGVkWm9vbSwgd2lkdGgsIGhlaWdodCk7XG4gICAgLy8gV2Ugb25seSB3YW50IHRvIGhhdmUgYW4gb2Zmc2V0IGlmIHRoZSBuZXdQYWRkaW5nIGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVxdWlyZWQgcGFkZGluZ1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4obmV3UGFkZGluZy5sZWZ0IC0gcC5sZWZ0LCAwKSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihuZXdQYWRkaW5nLnRvcCAtIHAudG9wLCAwKSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKG5ld1BhZGRpbmcucmlnaHQgLSBwLnJpZ2h0LCAwKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihuZXdQYWRkaW5nLmJvdHRvbSAtIHAuYm90dG9tLCAwKSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBvZmZzZXQubGVmdCArIG9mZnNldC5yaWdodCxcbiAgICAgICAgeTogeSAtIG9mZnNldC50b3AgKyBvZmZzZXQuYm90dG9tLFxuICAgICAgICB6b29tOiBjbGFtcGVkWm9vbSxcbiAgICB9O1xufTtcbmNvbnN0IGlzTWFjT3MgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5kZXhPZignTWFjJykgPj0gMDtcbmZ1bmN0aW9uIGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gZXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgZXh0ZW50ICE9PSBudWxsICYmIGV4dGVudCAhPT0gJ3BhcmVudCc7XG59XG5mdW5jdGlvbiBnZXROb2RlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0KSAhPT0gdW5kZWZpbmVkKTtcbn1cbi8qKlxuICogQ29udmVydCBjaGlsZCBwb3NpdGlvbiB0byBhYm9zbHV0ZSBwb3NpdGlvblxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcGFyYW0gcGFyZW50SWRcbiAqIEBwYXJhbSBub2RlTG9va3VwXG4gKiBAcGFyYW0gbm9kZU9yaWdpblxuICogQHJldHVybnMgYW4gaW50ZXJuYWwgbm9kZSB3aXRoIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihwb3NpdGlvbiwgZGltZW5zaW9ucyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBwYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiB8fCBub2RlT3JpZ2luO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnggKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggLSAoZGltZW5zaW9ucy53aWR0aCA/PyAwKSAqIG9yaWdpblswXTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS55ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IC0gKGRpbWVuc2lvbnMuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25BYnNvbHV0ZTtcbn1cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgUHJvbWlzZS53aXRoUmVzb2x2ZXJzIHVudGlsIHdlIGNhbiB1c2UgaXQgaW4gYWxsIGJyb3dzZXJzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuZnVuY3Rpb24gbWVyZ2VBcmlhTGFiZWxDb25maWcocGFydGlhbCkge1xuICAgIHJldHVybiB7IC4uLmRlZmF1bHRBcmlhTGFiZWxDb25maWcsIC4uLihwYXJ0aWFsIHx8IHt9KSB9O1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQsIHsgc25hcEdyaWQgPSBbMCwgMF0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgdHJhbnNmb3JtLCBjb250YWluZXJCb3VuZHMgfSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgcG9pbnRlclBvcyA9IHBvaW50VG9SZW5kZXJlclBvaW50KHsgeDogeCAtIChjb250YWluZXJCb3VuZHM/LmxlZnQgPz8gMCksIHk6IHkgLSAoY29udGFpbmVyQm91bmRzPy50b3AgPz8gMCkgfSwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCB7IHg6IHhTbmFwcGVkLCB5OiB5U25hcHBlZCB9ID0gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb2ludGVyUG9zLCBzbmFwR3JpZCkgOiBwb2ludGVyUG9zO1xuICAgIC8vIHdlIG5lZWQgdGhlIHNuYXBwZWQgcG9zaXRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBza2lwIHVubmVjZXNzYXJ5IGRyYWcgZXZlbnRzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeFNuYXBwZWQsXG4gICAgICAgIHlTbmFwcGVkLFxuICAgICAgICAuLi5wb2ludGVyUG9zLFxuICAgIH07XG59XG5jb25zdCBnZXREaW1lbnNpb25zID0gKG5vZGUpID0+ICh7XG4gICAgd2lkdGg6IG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCxcbn0pO1xuY29uc3QgZ2V0SG9zdEZvckVsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudD8uZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBpbnB1dFRhZ3MgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuZnVuY3Rpb24gaXNJbnB1dERPTU5vZGUoZXZlbnQpIHtcbiAgICAvLyB1c2luZyBjb21wb3NlZCBwYXRoIGZvciBoYW5kbGluZyBzaGFkb3cgZG9tXG4gICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXQ/Lm5vZGVUeXBlICE9PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNJbnB1dCA9IGlucHV0VGFncy5pbmNsdWRlcyh0YXJnZXQubm9kZU5hbWUpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIC8vIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgZm9jdXNlZCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZGVsZXRpb24gb3IgbW92ZW1lbnQgb2Ygbm9kZXNcbiAgICByZXR1cm4gaXNJbnB1dCB8fCAhIXRhcmdldC5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZSA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2UgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2UgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG4vKlxuICogVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbiAqIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbiAqIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuICovXG5jb25zdCBnZXRIYW5kbGVCb3VuZHMgPSAodHlwZSwgbm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGVJZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXMgPSBub2RlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0eXBlfWApO1xuICAgIGlmICghaGFuZGxlcyB8fCAhaGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZXMpLm1hcCgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgcG9zaXRpb246IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlcG9zJyksXG4gICAgICAgICAgICB4OiAoaGFuZGxlQm91bmRzLmxlZnQgLSBub2RlQm91bmRzLmxlZnQpIC8gem9vbSxcbiAgICAgICAgICAgIHk6IChoYW5kbGVCb3VuZHMudG9wIC0gbm9kZUJvdW5kcy50b3ApIC8gem9vbSxcbiAgICAgICAgICAgIC4uLmdldERpbWVuc2lvbnMoaGFuZGxlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8qXG4gICAgICogY3ViaWMgYmV6aWVyIHQ9MC41IG1pZCBwb2ludCwgbm90IHRoZSBhY3R1YWwgbWlkIHBvaW50LCBidXQgZWFzeSB0byBjYWxjdWxhdGVcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzUxNjEwMS9ob3ctdG8tZmluZC1kaXN0YW5jZS1taWQtcG9pbnQtb2YtYmV6aWVyLWN1cnZlXG4gICAgICovXG4gICAgY29uc3QgY2VudGVyWCA9IHNvdXJjZVggKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0WCAqIDAuMTI1O1xuICAgIGNvbnN0IGNlbnRlclkgPSBzb3VyY2VZICogMC4xMjUgKyBzb3VyY2VDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFkgKiAwLjM3NSArIHRhcmdldFkgKiAwLjEyNTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5hYnMoY2VudGVyWCAtIHNvdXJjZVgpO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmFicyhjZW50ZXJZIC0gc291cmNlWSk7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoZGlzdGFuY2UsIGN1cnZhdHVyZSkge1xuICAgIGlmIChkaXN0YW5jZSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBkaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZhdHVyZSAqIDI1ICogTWF0aC5zcXJ0KC1kaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7IHBvcywgeDEsIHkxLCB4MiwgeTIsIGMgfSkge1xuICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgxIC0geDIsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MiAtIHgxLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MSAtIHkyLCBjKV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkyIC0geTEsIGMpXTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBgZ2V0QmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgYmV6aWVyIGVkZ2VcbiAqYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICp9KTtcbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvXG4gKndvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGN1cnZhdHVyZSA9IDAuMjUsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuXG4vLyB0aGlzIGlzIHVzZWQgZm9yIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaW1wbGUgc21vb3Roc3RlcCBlZGdlcyAoTFRSLCBSVEwsIEJUVCwgVFRCKVxuZnVuY3Rpb24gZ2V0RWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCB4T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WCAtIHNvdXJjZVgpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJYID0gdGFyZ2V0WCA8IHNvdXJjZVggPyB0YXJnZXRYICsgeE9mZnNldCA6IHRhcmdldFggLSB4T2Zmc2V0O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRZIC0gc291cmNlWSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSB0YXJnZXRZIDwgc291cmNlWSA/IHRhcmdldFkgKyB5T2Zmc2V0IDogdGFyZ2V0WSAtIHlPZmZzZXQ7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCB4T2Zmc2V0LCB5T2Zmc2V0XTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgei1pbmRleCBmb3IgYW4gZWRnZSBiYXNlZCBvbiB0aGUgbm9kZSBpdCBjb25uZWN0cyBhbmQgd2hldGhlciBpdCBpcyBzZWxlY3RlZC5cbiAqIEJ5IGRlZmF1bHQsIGVkZ2VzIGFyZSByZW5kZXJlZCBiZWxvdyBub2Rlcy4gVGhpcyBiZWhhdmlvdXIgaXMgZGlmZmVyZW50IGZvciBlZGdlcyB0aGF0IGFyZVxuICogY29ubmVjdGVkIHRvIG5vZGVzIHdpdGggYSBwYXJlbnQsIGFzIHRoZXkgYXJlIHJlbmRlcmVkIGFib3ZlIHRoZSBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgc2VsZWN0ZWQgPSBmYWxzZSwgekluZGV4LCBlbGV2YXRlT25TZWxlY3QgPSBmYWxzZSwgfSkge1xuICAgIGlmICh6SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gekluZGV4O1xuICAgIH1cbiAgICBjb25zdCBlZGdlWiA9IGVsZXZhdGVPblNlbGVjdCAmJiBzZWxlY3RlZCA/IDEwMDAgOiAwO1xuICAgIGNvbnN0IG5vZGVaID0gTWF0aC5tYXgoc291cmNlTm9kZS5wYXJlbnRJZCA/IHNvdXJjZU5vZGUuaW50ZXJuYWxzLnogOiAwLCB0YXJnZXROb2RlLnBhcmVudElkID8gdGFyZ2V0Tm9kZS5pbnRlcm5hbHMueiA6IDApO1xuICAgIHJldHVybiBlZGdlWiArIG5vZGVaO1xufVxuZnVuY3Rpb24gaXNFZGdlVmlzaWJsZSh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgZWRnZUJveCA9IGdldEJvdW5kc09mQm94ZXMobm9kZVRvQm94KHNvdXJjZU5vZGUpLCBub2RlVG9Cb3godGFyZ2V0Tm9kZSkpO1xuICAgIGlmIChlZGdlQm94LnggPT09IGVkZ2VCb3gueDIpIHtcbiAgICAgICAgZWRnZUJveC54MiArPSAxO1xuICAgIH1cbiAgICBpZiAoZWRnZUJveC55ID09PSBlZGdlQm94LnkyKSB7XG4gICAgICAgIGVkZ2VCb3gueTIgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld1JlY3QgPSB7XG4gICAgICAgIHg6IC10cmFuc2Zvcm1bMF0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC10cmFuc2Zvcm1bMV0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiB3aWR0aCAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyB0cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0T3ZlcmxhcHBpbmdBcmVhKHZpZXdSZWN0LCBib3hUb1JlY3QoZWRnZUJveCkpID4gMDtcbn1cbmNvbnN0IGdldEVkZ2VJZCA9ICh7IHNvdXJjZSwgc291cmNlSGFuZGxlLCB0YXJnZXQsIHRhcmdldEhhbmRsZSB9KSA9PiBgeHktZWRnZV9fJHtzb3VyY2V9JHtzb3VyY2VIYW5kbGUgfHwgJyd9LSR7dGFyZ2V0fSR7dGFyZ2V0SGFuZGxlIHx8ICcnfWA7XG5jb25zdCBjb25uZWN0aW9uRXhpc3RzID0gKGVkZ2UsIGVkZ2VzKSA9PiB7XG4gICAgcmV0dXJuIGVkZ2VzLnNvbWUoKGVsKSA9PiBlbC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmXG4gICAgICAgIGVsLnRhcmdldCA9PT0gZWRnZS50YXJnZXQgJiZcbiAgICAgICAgKGVsLnNvdXJjZUhhbmRsZSA9PT0gZWRnZS5zb3VyY2VIYW5kbGUgfHwgKCFlbC5zb3VyY2VIYW5kbGUgJiYgIWVkZ2Uuc291cmNlSGFuZGxlKSkgJiZcbiAgICAgICAgKGVsLnRhcmdldEhhbmRsZSA9PT0gZWRnZS50YXJnZXRIYW5kbGUgfHwgKCFlbC50YXJnZXRIYW5kbGUgJiYgIWVkZ2UudGFyZ2V0SGFuZGxlKSkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IEVkZ2UgdG8gYW4gYXJyYXkgb2YgZWRnZXMuIEl0IGFsc28gcGVyZm9ybXMgc29tZSB2YWxpZGF0aW9uIHRvIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgYWRkIGFuIGludmFsaWQgZWRnZSBvciBkdXBsaWNhdGUgYW4gZXhpc3Rpbmcgb25lLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGVkZ2VQYXJhbXMgLSBFaXRoZXIgYW4gYEVkZ2VgIG9yIGEgYENvbm5lY3Rpb25gIHlvdSB3YW50IHRvIGFkZC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIGVkZ2VzIHdpdGggdGhlIG5ldyBlZGdlIGFkZGVkLlxuICpcbiAqIEByZW1hcmtzIElmIGFuIGVkZ2Ugd2l0aCB0aGUgc2FtZSBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgYWxyZWFkeSBleGlzdHMgKGFuZCB0aGUgc2FtZVxuICpgdGFyZ2V0SGFuZGxlYCBhbmQgYHNvdXJjZUhhbmRsZWAgaWYgdGhvc2UgYXJlIHNldCksIHRoZW4gdGhpcyB1dGlsIHdvbid0IGFkZFxuICphIG5ldyBlZGdlIGV2ZW4gaWYgdGhlIGBpZGAgcHJvcGVydHkgaXMgZGlmZmVyZW50LlxuICpcbiAqL1xuY29uc3QgYWRkRWRnZSA9IChlZGdlUGFyYW1zLCBlZGdlcykgPT4ge1xuICAgIGlmICghZWRnZVBhcmFtcy5zb3VyY2UgfHwgIWVkZ2VQYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgbGV0IGVkZ2U7XG4gICAgaWYgKGlzRWRnZUJhc2UoZWRnZVBhcmFtcykpIHtcbiAgICAgICAgZWRnZSA9IHsgLi4uZWRnZVBhcmFtcyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRnZSA9IHtcbiAgICAgICAgICAgIC4uLmVkZ2VQYXJhbXMsXG4gICAgICAgICAgICBpZDogZ2V0RWRnZUlkKGVkZ2VQYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbkV4aXN0cyhlZGdlLCBlZGdlcykpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2VIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2Uuc291cmNlSGFuZGxlO1xuICAgIH1cbiAgICBpZiAoZWRnZS50YXJnZXRIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2UudGFyZ2V0SGFuZGxlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXMuY29uY2F0KGVkZ2UpO1xufTtcbi8qKlxuICogQSBoYW5keSB1dGlsaXR5IHRvIHVwZGF0ZSBhbiBleGlzdGluZyBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKSB3aXRoIG5ldyBwcm9wZXJ0aWVzLlxuICpUaGlzIHNlYXJjaGVzIHlvdXIgZWRnZSBhcnJheSBmb3IgYW4gZWRnZSB3aXRoIGEgbWF0Y2hpbmcgYGlkYCBhbmQgdXBkYXRlcyBpdHNcbiAqcHJvcGVydGllcyB3aXRoIHRoZSBjb25uZWN0aW9uIHlvdSBwcm92aWRlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9sZEVkZ2UgLSBUaGUgZWRnZSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gKiBAcGFyYW0gbmV3Q29ubmVjdGlvbiAtIFRoZSBuZXcgY29ubmVjdGlvbiB5b3Ugd2FudCB0byB1cGRhdGUgdGhlIGVkZ2Ugd2l0aC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGVkZ2VzIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICpjb25zdCBvblJlY29ubmVjdCA9IHVzZUNhbGxiYWNrKFxuICogIChvbGRFZGdlOiBFZGdlLCBuZXdDb25uZWN0aW9uOiBDb25uZWN0aW9uKSA9PiBzZXRFZGdlcygoZWxzKSA9PiByZWNvbm5lY3RFZGdlKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVscykpLFtdKTtcbiAqYGBgXG4gKi9cbmNvbnN0IHJlY29ubmVjdEVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZS5pZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzdHJhaWdodCBsaW5lIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtgTSAke3NvdXJjZVh9LCR7c291cmNlWX1MICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuY29uc3QgaGFuZGxlRGlyZWN0aW9ucyA9IHtcbiAgICBbUG9zaXRpb24uTGVmdF06IHsgeDogLTEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiB7IHg6IDEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uVG9wXTogeyB4OiAwLCB5OiAtMSB9LFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiB7IHg6IDAsIHk6IDEgfSxcbn07XG5jb25zdCBnZXREaXJlY3Rpb24gPSAoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIH0pID0+IHtcbiAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQgfHwgc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UueCA8IHRhcmdldC54ID8geyB4OiAxLCB5OiAwIH0gOiB7IHg6IC0xLCB5OiAwIH07XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UueSA8IHRhcmdldC55ID8geyB4OiAwLCB5OiAxIH0gOiB7IHg6IDAsIHk6IC0xIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KE1hdGgucG93KGIueCAtIGEueCwgMikgKyBNYXRoLnBvdyhiLnkgLSBhLnksIDIpKTtcbi8qXG4gKiBXaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGFuIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nIGJlaGF2aW91clxuICogSXQncyBub3QgYXMgZ29vZCBhcyBhIHJlYWwgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcsIGJ1dCBpdCdzIGZhc3RlciBhbmQgZ29vZCBlbm91Z2ggYXMgYSBkZWZhdWx0IGZvciBzdGVwIGFuZCBzbW9vdGggc3RlcCBlZGdlc1xuICovXG5mdW5jdGlvbiBnZXRQb2ludHMoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjZW50ZXIsIG9mZnNldCwgc3RlcFBvc2l0aW9uLCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbLCAsIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbCwgc28gc3RlcFBvc2l0aW9uIGFmZmVjdHMgWCBjb29yZGluYXRlXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgKHRhcmdldEdhcHBlZC54IC0gc291cmNlR2FwcGVkLngpICogc3RlcFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyB0YXJnZXRHYXBwZWQueSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgdmVydGljYWwsIHNvIHN0ZXBQb3NpdGlvbiBhZmZlY3RzIFkgY29vcmRpbmF0ZSAgXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgdGFyZ2V0R2FwcGVkLngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyAodGFyZ2V0R2FwcGVkLnkgLSBzb3VyY2VHYXBwZWQueSkgKiBzdGVwUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIC0tLT5cbiAgICAgICAgICogICAgfFxuICAgICAgICAgKiA+LS0tXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiBzb3VyY2VHYXBwZWQueSB9LFxuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiB0YXJnZXRHYXBwZWQueSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqICAtLS1cbiAgICAgICAgICogIHxcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogc291cmNlR2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyB2ZXJ0aWNhbFNwbGl0IDogaG9yaXpvbnRhbFNwbGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IGhvcml6b250YWxTcGxpdCA6IHZlcnRpY2FsU3BsaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNvdXJjZVRhcmdldCBtZWFucyB3ZSB0YWtlIHggZnJvbSBzb3VyY2UgYW5kIHkgZnJvbSB0YXJnZXQsIHRhcmdldFNvdXJjZSBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgY29uc3Qgc291cmNlVGFyZ2V0ID0gW3sgeDogc291cmNlR2FwcGVkLngsIHk6IHRhcmdldEdhcHBlZC55IH1dO1xuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBbeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogc291cmNlR2FwcGVkLnkgfV07XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlcyBlZGdlcyB3aXRoIHNhbWUgaGFuZGxlIHBvc2l0aW9uc1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnggPT09IGN1cnJEaXIgPyB0YXJnZXRTb3VyY2UgOiBzb3VyY2VUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueSA9PT0gY3VyckRpciA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoc291cmNlW2RpckFjY2Vzc29yXSAtIHRhcmdldFtkaXJBY2Nlc3Nvcl0pO1xuICAgICAgICAgICAgLy8gaWYgYW4gZWRnZSBnb2VzIGZyb20gcmlnaHQgdG8gcmlnaHQgZm9yIGV4YW1wbGUgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikgYW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZS54IGFuZCB0YXJnZXQueCBpcyBsZXNzIHRoYW4gdGhlIG9mZnNldCwgdGhlIGFkZGVkIHBvaW50IGFuZCB0aGUgZ2FwcGVkIHNvdXJjZS90YXJnZXQgd2lsbCBvdmVybGFwLiBUaGlzIGxlYWRzIHRvIGEgd2VpcmQgZWRnZSBwYXRoLiBUbyBhdm9pZCB0aGlzIHdlIGFkZCBhIGdhcE9mZnNldCB0byB0aGUgc291cmNlL3RhcmdldFxuICAgICAgICAgICAgaWYgKGRpZmYgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwT2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0IC0gMSwgb2Zmc2V0IC0gZGlmZik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlR2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9IChzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JdID4gc291cmNlW2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiB0YXJnZXRbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgYXJlIGNvbmRpdGlvbnMgZm9yIGhhbmRsaW5nIG1peGVkIGhhbmRsZSBwb3NpdGlvbnMgbGlrZSBSaWdodCAtPiBCb3R0b20gZm9yIGV4YW1wbGVcbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uICE9PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlyQWNjZXNzb3JPcHBvc2l0ZSA9IGRpckFjY2Vzc29yID09PSAneCcgPyAneScgOiAneCc7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWVEaXIgPSBzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSB0YXJnZXREaXJbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VHdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPiB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPCB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBmbGlwU291cmNlVGFyZ2V0ID0gKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pKSkgfHxcbiAgICAgICAgICAgICAgICAoc291cmNlRGlyW2RpckFjY2Vzc29yXSAhPT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykpKTtcbiAgICAgICAgICAgIGlmIChmbGlwU291cmNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VHYXBQb2ludCA9IHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCB0YXJnZXRHYXBQb2ludCA9IHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCBtYXhYRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpKTtcbiAgICAgICAgY29uc3QgbWF4WURpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueSAtIHBvaW50c1swXS55KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueSAtIHBvaW50c1swXS55KSk7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcGxhY2UgdGhlIGxhYmVsIG9uIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG1heFhEaXN0YW5jZSA+PSBtYXhZRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNlbnRlclggPSAoc291cmNlR2FwUG9pbnQueCArIHRhcmdldEdhcFBvaW50LngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBwb2ludHNbMF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbnRlclggPSBwb2ludHNbMF0ueDtcbiAgICAgICAgICAgIGNlbnRlclkgPSAoc291cmNlR2FwUG9pbnQueSArIHRhcmdldEdhcFBvaW50LnkpIC8gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXRoUG9pbnRzID0gW1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9LFxuICAgICAgICAuLi5wb2ludHMsXG4gICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9LFxuICAgICAgICB0YXJnZXQsXG4gICAgXTtcbiAgICByZXR1cm4gW3BhdGhQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV07XG59XG5mdW5jdGlvbiBnZXRCZW5kKGEsIGIsIGMsIHNpemUpIHtcbiAgICBjb25zdCBiZW5kU2l6ZSA9IE1hdGgubWluKGRpc3RhbmNlKGEsIGIpIC8gMiwgZGlzdGFuY2UoYiwgYykgLyAyLCBzaXplKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGI7XG4gICAgLy8gbm8gYmVuZFxuICAgIGlmICgoYS54ID09PSB4ICYmIHggPT09IGMueCkgfHwgKGEueSA9PT0geSAmJiB5ID09PSBjLnkpKSB7XG4gICAgICAgIHJldHVybiBgTCR7eH0gJHt5fWA7XG4gICAgfVxuICAgIC8vIGZpcnN0IHNlZ21lbnQgaXMgaG9yaXpvbnRhbFxuICAgIGlmIChhLnkgPT09IHkpIHtcbiAgICAgICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIGBMICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fVEgJHt4fSwke3l9ICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfWA7XG4gICAgfVxuICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAxIDogLTE7XG4gICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IC0xIDogMTtcbiAgICByZXR1cm4gYEwgJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9USAke3h9LCR7eX0gJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9YDtcbn1cbi8qKlxuICogVGhlIGBnZXRTbW9vdGhTdGVwUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc3RlcHBlZCBwYXRoXG4gKiBiZXR3ZWVuIHR3byBub2Rlcy4gVGhlIGBib3JkZXJSYWRpdXNgIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGNob29zZSBob3cgcm91bmRlZFxuICogdGhlIGNvcm5lcnMgb2YgdGhvc2Ugc3RlcHMgYXJlLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICogIH0pO1xuICogYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoU3RlcFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGJvcmRlclJhZGl1cyA9IDUsIGNlbnRlclgsIGNlbnRlclksIG9mZnNldCA9IDIwLCBzdGVwUG9zaXRpb24gPSAwLjUsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgc3RlcFBvc2l0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvKlxuICAgICAqIHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3BcbiAgICAgKiB3ZSBzZXQgdGhlIHggYW55IHkgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgYmFzZWQgb24gdGhlIG5vZGVzIHBvc2l0aW9uXG4gICAgICovXG4gICAgbGV0IHBvcyA9IFtcbiAgICAgICAgKG5vZGVSZWN0LnggKyBub2RlUmVjdC53aWR0aCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCxcbiAgICAgICAgbm9kZVJlY3QueSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55IC0gb2Zmc2V0LFxuICAgIF07XG4gICAgLy8gYW5kIHRoYW4gc2hpZnQgaXQgYmFzZWQgb24gdGhlIGFsaWdubWVudC4gVGhlIHNoaWZ0IHZhbHVlcyBhcmUgaW4gJS5cbiAgICBsZXQgc2hpZnQgPSBbLTEwMCAqIGFsaWdubWVudE9mZnNldCwgLTEwMF07XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGgpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQgKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc2hpZnQgPSBbMCwgLTEwMCAqIGFsaWdubWVudE9mZnNldF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICBwb3NbMV0gPSAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSArIG9mZnNldDtcbiAgICAgICAgICAgIHNoaWZ0WzFdID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbm9kZVJlY3QueCAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54IC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWy0xMDAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgdHJhbnNsYXRlKCR7c2hpZnRbMF19JSwgJHtzaGlmdFsxXX0lKWA7XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5vZGVPcmlnaW46IFswLCAwXSxcbiAgICBub2RlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICBkZWZhdWx0czoge30sXG59O1xuY29uc3QgYWRvcHRVc2VyTm9kZXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICBjaGVja0VxdWFsaXR5OiB0cnVlLFxufTtcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhiYXNlLCBpbmNvbWluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluY29taW5nKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHR5cGVjYXN0IGlzIHNhZmUgaGVyZSwgYmVjYXVzZSB3ZSBjaGVjayBmb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGluY29taW5nW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxvb2t1cC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyhub2RlKSk7XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gY2xhbXBlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gbWVyZ2VPYmplY3RzKGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGxldCBub2Rlc0luaXRpYWxpemVkID0gbm9kZXMubGVuZ3RoID4gMDtcbiAgICBjb25zdCB0bXBMb29rdXAgPSBuZXcgTWFwKG5vZGVMb29rdXApO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBfb3B0aW9ucz8uZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBub2RlTG9va3VwLmNsZWFyKCk7XG4gICAgcGFyZW50TG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB1c2VyTm9kZSBvZiBub2Rlcykge1xuICAgICAgICBsZXQgaW50ZXJuYWxOb2RlID0gdG1wTG9va3VwLmdldCh1c2VyTm9kZS5pZCk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5jaGVja0VxdWFsaXR5ICYmIHVzZXJOb2RlID09PSBpbnRlcm5hbE5vZGU/LmludGVybmFscy51c2VyTm9kZSkge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHVzZXJOb2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudCh1c2VyTm9kZS5leHRlbnQpID8gdXNlck5vZGUuZXh0ZW50IDogX29wdGlvbnMubm9kZUV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBleHRlbnQsIGdldE5vZGVEaW1lbnNpb25zKHVzZXJOb2RlKSk7XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX29wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4udXNlck5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHVzZXJOb2RlLm1lYXN1cmVkPy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB1c2VyTm9kZS5tZWFzdXJlZD8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGNsYW1wZWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlciByZS1pbml0aWFsaXplcyB0aGUgbm9kZSBvciByZW1vdmVzIGBtZWFzdXJlZGAgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgcmVzZXQgdGhlIGhhbmRsZUJvdW5kcyBzbyB0aGF0IHRoZSBub2RlIGdldHMgcmUtbWVhc3VyZWRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiAhdXNlck5vZGUubWVhc3VyZWQgPyB1bmRlZmluZWQgOiBpbnRlcm5hbE5vZGU/LmludGVybmFscy5oYW5kbGVCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIHo6IGNhbGN1bGF0ZVoodXNlck5vZGUsIHNlbGVjdGVkTm9kZVopLFxuICAgICAgICAgICAgICAgICAgICB1c2VyTm9kZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaW50ZXJuYWxOb2RlLm1lYXN1cmVkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxOb2RlLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyTm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKGludGVybmFsTm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXNJbml0aWFsaXplZDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudExvb2t1cChub2RlLCBwYXJlbnRMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gcGFyZW50TG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoY2hpbGROb2Rlcykge1xuICAgICAgICBjaGlsZE5vZGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudExvb2t1cC5zZXQobm9kZS5wYXJlbnRJZCwgbmV3IE1hcChbW25vZGUuaWQsIG5vZGVdXSkpO1xuICAgIH1cbn1cbi8qKlxuICogVXBkYXRlcyBwb3NpdGlvbkFic29sdXRlIGFuZCB6SW5kZXggb2YgYSBjaGlsZCBub2RlIGFuZCB0aGUgcGFyZW50TG9va3VwLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZE5vZGUobm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGV2YXRlTm9kZXNPblNlbGVjdCwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCB9ID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQYXJlbnQgbm9kZSAke3BhcmVudElkfSBub3QgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgbm9kZXMgYXJlIGluIGZyb250IG9mIHRoZWlyIGNoaWxkIG5vZGVzIGluIHRoZSBub2RlcyBhcnJheS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBjb25zdCB7IHgsIHksIHogfSA9IGNhbGN1bGF0ZUNoaWxkWFlaKG5vZGUsIHBhcmVudE5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHNlbGVjdGVkTm9kZVopO1xuICAgIGNvbnN0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0geCAhPT0gcG9zaXRpb25BYnNvbHV0ZS54IHx8IHkgIT09IHBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBpZiAocG9zaXRpb25DaGFuZ2VkIHx8IHogIT09IG5vZGUuaW50ZXJuYWxzLnopIHtcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB0byBtYXJrIHRoZSBub2RlIGFzIHVwZGF0ZWRcbiAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IHBvc2l0aW9uQ2hhbmdlZCA/IHsgeCwgeSB9IDogcG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICB6LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlWihub2RlLCBzZWxlY3RlZE5vZGVaKSB7XG4gICAgcmV0dXJuIChpc051bWVyaWMobm9kZS56SW5kZXgpID8gbm9kZS56SW5kZXggOiAwKSArIChub2RlLnNlbGVjdGVkID8gc2VsZWN0ZWROb2RlWiA6IDApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hpbGRYWVooY2hpbGROb2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaKSB7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIGNvbnN0IGNoaWxkRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKGNoaWxkTm9kZSk7XG4gICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihjaGlsZE5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGlzQ29vcmRpbmF0ZUV4dGVudChjaGlsZE5vZGUuZXh0ZW50KVxuICAgICAgICA/IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBjaGlsZE5vZGUuZXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpXG4gICAgICAgIDogcG9zaXRpb25XaXRoT3JpZ2luO1xuICAgIGxldCBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbih7IHg6IHBhcmVudFggKyBjbGFtcGVkUG9zaXRpb24ueCwgeTogcGFyZW50WSArIGNsYW1wZWRQb3NpdGlvbi55IH0sIG5vZGVFeHRlbnQsIGNoaWxkRGltZW5zaW9ucyk7XG4gICAgaWYgKGNoaWxkTm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoYWJzb2x1dGVQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnROb2RlKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRaID0gY2FsY3VsYXRlWihjaGlsZE5vZGUsIHNlbGVjdGVkTm9kZVopO1xuICAgIGNvbnN0IHBhcmVudFogPSBwYXJlbnROb2RlLmludGVybmFscy56ID8/IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYWJzb2x1dGVQb3NpdGlvbi54LFxuICAgICAgICB5OiBhYnNvbHV0ZVBvc2l0aW9uLnksXG4gICAgICAgIHo6IHBhcmVudFogPj0gY2hpbGRaID8gcGFyZW50WiArIDEgOiBjaGlsZFosXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUV4cGFuZFBhcmVudChjaGlsZHJlbiwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luID0gWzAsIDBdKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHBhcmVudEV4cGFuc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBleHBhbmRlZCByZWN0YW5nbGUgdGhlIGNoaWxkIG5vZGVzIHdvdWxkIHRha2UgZm9yIGVhY2ggcGFyZW50XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlTG9va3VwLmdldChjaGlsZC5wYXJlbnRJZCk7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50RXhwYW5zaW9ucy5nZXQoY2hpbGQucGFyZW50SWQpPy5leHBhbmRlZFJlY3QgPz8gbm9kZVRvUmVjdChwYXJlbnQpO1xuICAgICAgICBjb25zdCBleHBhbmRlZFJlY3QgPSBnZXRCb3VuZHNPZlJlY3RzKHBhcmVudFJlY3QsIGNoaWxkLnJlY3QpO1xuICAgICAgICBwYXJlbnRFeHBhbnNpb25zLnNldChjaGlsZC5wYXJlbnRJZCwgeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmVudEV4cGFuc2lvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5mb3JFYWNoKCh7IGV4cGFuZGVkUmVjdCwgcGFyZW50IH0sIHBhcmVudElkKSA9PiB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHBvc2l0aW9uICYgZGltZW5zaW9ucyBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBwYXJlbnQub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaG93IG11Y2ggdGhlIHBhcmVudCBleHBhbmRzIGluIHdpZHRoIGFuZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgeENoYW5nZSA9IGV4cGFuZGVkUmVjdC54IDwgcG9zaXRpb25BYnNvbHV0ZS54ID8gTWF0aC5yb3VuZChNYXRoLmFicyhwb3NpdGlvbkFic29sdXRlLnggLSBleHBhbmRlZFJlY3QueCkpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IHlDaGFuZ2UgPSBleHBhbmRlZFJlY3QueSA8IHBvc2l0aW9uQWJzb2x1dGUueSA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS55IC0gZXhwYW5kZWRSZWN0LnkpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KGRpbWVuc2lvbnMud2lkdGgsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LndpZHRoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heChkaW1lbnNpb25zLmhlaWdodCwgTWF0aC5yb3VuZChleHBhbmRlZFJlY3QuaGVpZ2h0KSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aENoYW5nZSA9IChuZXdXaWR0aCAtIGRpbWVuc2lvbnMud2lkdGgpICogb3JpZ2luWzBdO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0Q2hhbmdlID0gKG5ld0hlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0KSAqIG9yaWdpblsxXTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIHBhcmVudCBub2RlIGlmIHRoZSBvcmlnaW4gaXMgbm90IFswLDBdXG4gICAgICAgICAgICBpZiAoeENoYW5nZSA+IDAgfHwgeUNoYW5nZSA+IDAgfHwgd2lkdGhDaGFuZ2UgfHwgaGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcGFyZW50LnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgd2lkdGhDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwYXJlbnQucG9zaXRpb24ueSAtIHlDaGFuZ2UgKyBoZWlnaHRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBXZSBtb3ZlIGFsbCBjaGlsZCBub2RlcyBpbiB0aGUgb3Bwc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBzbyB0aGUgeCx5IGNoYW5nZXMgb2YgdGhlIHBhcmVudCBkbyBub3QgbW92ZSB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwYXJlbnRMb29rdXAuZ2V0KHBhcmVudElkKT8uZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4uc29tZSgoY2hpbGQpID0+IGNoaWxkLmlkID09PSBjaGlsZE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZE5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGlsZE5vZGUucG9zaXRpb24ueCArIHhDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoaWxkTm9kZS5wb3NpdGlvbi55ICsgeUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcGFyZW50IG5vZGUgaWYgdGhlIG9yaWdpbiBpcyBub3QgWzAsMF1cbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgZXhwYW5kZWRSZWN0LndpZHRoIHx8IGRpbWVuc2lvbnMuaGVpZ2h0IDwgZXhwYW5kZWRSZWN0LmhlaWdodCB8fCB4Q2hhbmdlIHx8IHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoICsgKHhDaGFuZ2UgPyBvcmlnaW5bMF0gKiB4Q2hhbmdlIC0gd2lkdGhDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0ICsgKHlDaGFuZ2UgPyBvcmlnaW5bMV0gKiB5Q2hhbmdlIC0gaGVpZ2h0Q2hhbmdlIDogMCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KSB7XG4gICAgY29uc3Qgdmlld3BvcnROb2RlID0gZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnh5Zmxvd19fdmlld3BvcnQnKTtcbiAgICBsZXQgdXBkYXRlZEludGVybmFscyA9IGZhbHNlO1xuICAgIGlmICghdmlld3BvcnROb2RlKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFtdLCB1cGRhdGVkSW50ZXJuYWxzIH07XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0Tm9kZSk7XG4gICAgY29uc3QgeyBtMjI6IHpvb20gfSA9IG5ldyB3aW5kb3cuRE9NTWF0cml4UmVhZE9ubHkoc3R5bGUudHJhbnNmb3JtKTtcbiAgICAvLyBpbiB0aGlzIGFycmF5IHdlIGNvbGxlY3Qgbm9kZXMsIHRoYXQgbWlnaHQgdHJpZ2dlciBjaGFuZ2VzIChsaWtlIGV4cGFuZGluZyBwYXJlbnQpXG4gICAgY29uc3QgcGFyZW50RXhwYW5kQ2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldCh1cGRhdGUuaWQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVkSW50ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKHVwZGF0ZS5ub2RlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZWQgPSBub2RlLm1lYXN1cmVkLndpZHRoICE9PSBkaW1lbnNpb25zLndpZHRoIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ICE9PSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgY29uc3QgZG9VcGRhdGUgPSAhIShkaW1lbnNpb25zLndpZHRoICYmXG4gICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgKGRpbWVuc2lvbkNoYW5nZWQgfHwgIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyB8fCB1cGRhdGUuZm9yY2UpKTtcbiAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQm91bmRzID0gdXBkYXRlLm5vZGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSA/IG5vZGUuZXh0ZW50IDogbm9kZUV4dGVudDtcbiAgICAgICAgICAgIGxldCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb25Ub1BhcmVudChwb3NpdGlvbkFic29sdXRlLCBkaW1lbnNpb25zLCBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbkFic29sdXRlLCBleHRlbnQsIGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGdldEhhbmRsZUJvdW5kcygnc291cmNlJywgdXBkYXRlLm5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZ2V0SGFuZGxlQm91bmRzKCd0YXJnZXQnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwgbmV3Tm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShuZXdOb2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHsgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEV4cGFuZENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGVUb1JlY3QobmV3Tm9kZSwgbm9kZU9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgfVxuICAgIHJldHVybiB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhbkJ5KHsgZGVsdGEsIHBhblpvb20sIHRyYW5zZm9ybSwgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB9KSB7XG4gICAgaWYgKCFwYW5ab29tIHx8ICghZGVsdGEueCAmJiAhZGVsdGEueSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRWaWV3cG9ydCA9IGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHRyYW5zZm9ybVswXSArIGRlbHRhLngsXG4gICAgICAgIHk6IHRyYW5zZm9ybVsxXSArIGRlbHRhLnksXG4gICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICB9LCBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgdHJhbnNmb3JtQ2hhbmdlZCA9ICEhbmV4dFZpZXdwb3J0ICYmXG4gICAgICAgIChuZXh0Vmlld3BvcnQueCAhPT0gdHJhbnNmb3JtWzBdIHx8IG5leHRWaWV3cG9ydC55ICE9PSB0cmFuc2Zvcm1bMV0gfHwgbmV4dFZpZXdwb3J0LmsgIT09IHRyYW5zZm9ybVsyXSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cmFuc2Zvcm1DaGFuZ2VkKTtcbn1cbi8qKlxuICogdGhpcyBmdW5jdGlvbiBhZGRzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjb25uZWN0aW9uTG9va3VwXG4gKiBhdCB0aGUgZm9sbG93aW5nIGtleXM6IG5vZGVJZC10eXBlLWhhbmRsZUlkLCBub2RlSWQtdHlwZSBhbmQgbm9kZUlkXG4gKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBjb25uZWN0aW9uIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBsb29rdXBcbiAqIEBwYXJhbSBjb25uZWN0aW9uS2V5IGF0IHdoaWNoIGtleSB0aGUgY29ubmVjdGlvbiBzaG91bGQgYmUgYWRkZWRcbiAqIEBwYXJhbSBjb25uZWN0aW9uTG9va3VwIHJlZmVyZW5jZSB0byB0aGUgY29ubmVjdGlvbiBsb29rdXBcbiAqIEBwYXJhbSBub2RlSWQgbm9kZUlkIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gaGFuZGxlSWQgaGFuZGxlSWQgb2YgdGhlIGNvbm5lY2l0b25cbiAqL1xuZnVuY3Rpb24gYWRkQ29ubmVjdGlvblRvTG9va3VwKHR5cGUsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25Mb29rdXAsIG5vZGVJZCwgaGFuZGxlSWQpIHtcbiAgICAvKlxuICAgICAqIFdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgY29ubmVjdGlvbkxvb2t1cCBhdCB0aGUgZm9sbG93aW5nIGtleXNcbiAgICAgKiAxLiBub2RlSWQsIDIuIG5vZGVJZC10eXBlLCAzLiBub2RlSWQtdHlwZS1oYW5kbGVJZFxuICAgICAqIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMsIHdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgZXhpc3RpbmcgbWFwXG4gICAgICovXG4gICAgbGV0IGtleSA9IG5vZGVJZDtcbiAgICBjb25zdCBub2RlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCBub2RlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9YDtcbiAgICBjb25zdCB0eXBlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCB0eXBlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgaWYgKGhhbmRsZUlkKSB7XG4gICAgICAgIGtleSA9IGAke25vZGVJZH0tJHt0eXBlfS0ke2hhbmRsZUlkfWA7XG4gICAgICAgIGNvbnN0IGhhbmRsZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIGhhbmRsZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpIHtcbiAgICBjb25uZWN0aW9uTG9va3VwLmNsZWFyKCk7XG4gICAgZWRnZUxvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCB7IHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUgPSBudWxsLCB0YXJnZXRIYW5kbGUgPSBudWxsIH0gPSBlZGdlO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geyBlZGdlSWQ6IGVkZ2UuaWQsIHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9O1xuICAgICAgICBjb25zdCBzb3VyY2VLZXkgPSBgJHtzb3VyY2VOb2RlfS0ke3NvdXJjZUhhbmRsZX0tLSR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9YDtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gYCR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9LS0ke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfWA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgnc291cmNlJywgY29ubmVjdGlvbiwgdGFyZ2V0S2V5LCBjb25uZWN0aW9uTG9va3VwLCBzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUpO1xuICAgICAgICBhZGRDb25uZWN0aW9uVG9Mb29rdXAoJ3RhcmdldCcsIGNvbm5lY3Rpb24sIHNvdXJjZUtleSwgY29ubmVjdGlvbkxvb2t1cCwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SGFuZGxlKTtcbiAgICAgICAgZWRnZUxvb2t1cC5zZXQoZWRnZS5pZCwgZWRnZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaGFsbG93Tm9kZURhdGEoYSwgYikge1xuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBfYSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdO1xuICAgIGNvbnN0IF9iID0gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBbYl07XG4gICAgaWYgKF9hLmxlbmd0aCAhPT0gX2IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX2FbaV0uaWQgIT09IF9iW2ldLmlkIHx8IF9hW2ldLnR5cGUgIT09IF9iW2ldLnR5cGUgfHwgIU9iamVjdC5pcyhfYVtpXS5kYXRhLCBfYltpXS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1BhcmVudFNlbGVjdGVkKG5vZGUsIG5vZGVMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVMb29rdXApO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3RvciwgZG9tTm9kZSkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXM/LihzZWxlY3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvbU5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnRFbGVtZW50O1xuICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGxvb2tzIGZvciBhbGwgc2VsZWN0ZWQgbm9kZXMgYW5kIGNyZWF0ZWQgYSBOb2RlRHJhZ0l0ZW0gZm9yIGVhY2ggb2YgdGhlbVxuZnVuY3Rpb24gZ2V0RHJhZ0l0ZW1zKG5vZGVMb29rdXAsIG5vZGVzRHJhZ2dhYmxlLCBtb3VzZVBvcywgbm9kZUlkKSB7XG4gICAgY29uc3QgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgIGlmICgobm9kZS5zZWxlY3RlZCB8fCBub2RlLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICAgICAoIW5vZGUucGFyZW50SWQgfHwgIWlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkpICYmXG4gICAgICAgICAgICAobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbnRlcm5hbE5vZGUucG9zaXRpb24gfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZVBvcy55IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudDogaW50ZXJuYWxOb2RlLmV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGludGVybmFsTm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBpbnRlcm5hbE5vZGUub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRQYXJlbnQ6IGludGVybmFsTm9kZS5leHBhbmRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRyYWdJdGVtcztcbn1cbi8qXG4gKiByZXR1cm5zIHR3byBwYXJhbXM6XG4gKiAxLiB0aGUgZHJhZ2dlZCBub2RlIChvciB0aGUgZmlyc3Qgb2YgdGhlIGxpc3QsIGlmIHdlIGFyZSBkcmFnZ2luZyBhIG5vZGUgc2VsZWN0aW9uKVxuICogMi4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZXMgKGZvciBtdWx0aSBzZWxlY3Rpb25zKVxuICovXG5mdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJQYXJhbXMoeyBub2RlSWQsIGRyYWdJdGVtcywgbm9kZUxvb2t1cCwgZHJhZ2dpbmcgPSB0cnVlLCB9KSB7XG4gICAgY29uc3Qgbm9kZXNGcm9tRHJhZ0l0ZW1zID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBkcmFnSXRlbXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZXNGcm9tRHJhZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFtub2Rlc0Zyb21EcmFnSXRlbXNbMF0sIG5vZGVzRnJvbURyYWdJdGVtc107XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgIW5vZGVcbiAgICAgICAgICAgID8gbm9kZXNGcm9tRHJhZ0l0ZW1zWzBdXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkcmFnSXRlbXMuZ2V0KG5vZGVJZCk/LnBvc2l0aW9uIHx8IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMsXG4gICAgXTtcbn1cbi8qKlxuICogSWYgYSBzZWxlY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZCB3ZSB3YW50IHRvIGFwcGx5IHRoZSBzYW1lIHNuYXAgb2Zmc2V0IHRvIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzbmFwIG9mZnNldCBiYXNlZCBvbiB0aGUgZmlyc3Qgbm9kZSBpbiB0aGUgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTbmFwT2Zmc2V0KHsgZHJhZ0l0ZW1zLCBzbmFwR3JpZCwgeCwgeSwgfSkge1xuICAgIGNvbnN0IHJlZkRyYWdJdGVtID0gZHJhZ0l0ZW1zLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBpZiAoIXJlZkRyYWdJdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZQb3MgPSB7XG4gICAgICAgIHg6IHggLSByZWZEcmFnSXRlbS5kaXN0YW5jZS54LFxuICAgICAgICB5OiB5IC0gcmVmRHJhZ0l0ZW0uZGlzdGFuY2UueSxcbiAgICB9O1xuICAgIGNvbnN0IHJlZlBvc1NuYXBwZWQgPSBzbmFwUG9zaXRpb24ocmVmUG9zLCBzbmFwR3JpZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmVmUG9zU25hcHBlZC54IC0gcmVmUG9zLngsXG4gICAgICAgIHk6IHJlZlBvc1NuYXBwZWQueSAtIHJlZlBvcy55LFxuICAgIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBYWURyYWcoeyBvbk5vZGVNb3VzZURvd24sIGdldFN0b3JlSXRlbXMsIG9uRHJhZ1N0YXJ0LCBvbkRyYWcsIG9uRHJhZ1N0b3AsIH0pIHtcbiAgICBsZXQgbGFzdFBvcyA9IHsgeDogbnVsbCwgeTogbnVsbCB9O1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBkcmFnSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG1vdXNlUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICBsZXQgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgZDNTZWxlY3Rpb24gPSBudWxsO1xuICAgIGxldCBhYm9ydERyYWcgPSBmYWxzZTsgLy8gcHJldmVudHMgdW5pbnRlbnRpb25hbCBkcmFnZ2luZyBvbiBtdWx0aXRvdWNoXG4gICAgbGV0IG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgLy8gd2Ugc3RvcmUgdGhlIGxhc3QgZHJhZyBldmVudCB0byBiZSBhYmxlIHRvIHVzZSBpdCBpbiB0aGUgdXBkYXRlIGZ1bmN0aW9uXG4gICAgbGV0IGRyYWdFdmVudCA9IG51bGw7XG4gICAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRvbU5vZGUsIGlzU2VsZWN0YWJsZSwgbm9kZUlkLCBub2RlQ2xpY2tEaXN0YW5jZSA9IDAsIH0pIHtcbiAgICAgICAgZDNTZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHsgeCwgeSB9KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVFeHRlbnQsIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBvbk5vZGVEcmFnLCBvblNlbGVjdGlvbkRyYWcsIG9uRXJyb3IsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBsYXN0UG9zID0geyB4LCB5IH07XG4gICAgICAgICAgICBsZXQgaGFzQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBpc011bHRpRHJhZyA9IGRyYWdJdGVtcy5zaXplID4gMTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzQm94ID0gaXNNdWx0aURyYWcgJiYgbm9kZUV4dGVudCA/IHJlY3RUb0JveChnZXRJbnRlcm5hbE5vZGVzQm91bmRzKGRyYWdJdGVtcykpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpRHJhZ1NuYXBPZmZzZXQgPSBpc011bHRpRHJhZyAmJiBzbmFwVG9HcmlkXG4gICAgICAgICAgICAgICAgPyBjYWxjdWxhdGVTbmFwT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2YgZHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiB0aGUgbm9kZSBpcyBub3QgaW4gdGhlIG5vZGVMb29rdXAgYW55bW9yZSwgaXQgd2FzIHByb2JhYmx5IGRlbGV0ZWQgd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVMb29rdXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHsgeDogeCAtIGRyYWdJdGVtLmRpc3RhbmNlLngsIHk6IHkgLSBkcmFnSXRlbS5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gbXVsdGlEcmFnU25hcE9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueCArIG11bHRpRHJhZ1NuYXBPZmZzZXQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChuZXh0UG9zaXRpb24ueSArIG11bHRpRHJhZ1NuYXBPZmZzZXQueSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNuYXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIHNuYXBHcmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFkanVzdGVkTm9kZUV4dGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlEcmFnICYmIG5vZGVFeHRlbnQgJiYgIWRyYWdJdGVtLmV4dGVudCAmJiBub2Rlc0JveCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IGRyYWdJdGVtLmludGVybmFscztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDEgPSBwb3NpdGlvbkFic29sdXRlLnggLSBub2Rlc0JveC54ICsgbm9kZUV4dGVudFswXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDIgPSBwb3NpdGlvbkFic29sdXRlLnggKyBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCAtIG5vZGVzQm94LngyICsgbm9kZUV4dGVudFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTEgPSBwb3NpdGlvbkFic29sdXRlLnkgLSBub2Rlc0JveC55ICsgbm9kZUV4dGVudFswXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTIgPSBwb3NpdGlvbkFic29sdXRlLnkgKyBkcmFnSXRlbS5tZWFzdXJlZC5oZWlnaHQgLSBub2Rlc0JveC55MiArIG5vZGVFeHRlbnRbMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkTm9kZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MSwgeTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3gyLCB5Ml0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUV4dGVudDogYWRqdXN0ZWROb2RlRXh0ZW50ID8gYWRqdXN0ZWROb2RlRXh0ZW50IDogbm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgZmlyZSBhIGNoYW5nZSBldmVudCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IGRyYWdJdGVtLnBvc2l0aW9uLnggIT09IHBvc2l0aW9uLnggfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueSAhPT0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVQb3NpdGlvbnNDaGFuZ2VkID0gbm9kZVBvc2l0aW9uc0NoYW5nZWQgfHwgaGFzQ2hhbmdlO1xuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKGRyYWdJdGVtcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50ICYmIChvbkRyYWcgfHwgb25Ob2RlRHJhZyB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWcpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZz8uKGRyYWdFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWc/LihkcmFnRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYW5CeSwgYXV0b1BhblNwZWVkLCBhdXRvUGFuT25Ob2RlRHJhZyB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgaWYgKCFhdXRvUGFuT25Ob2RlRHJhZykge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbeE1vdmVtZW50LCB5TW92ZW1lbnRdID0gY2FsY0F1dG9QYW4obW91c2VQb3NpdGlvbiwgY29udGFpbmVyQm91bmRzLCBhdXRvUGFuU3BlZWQpO1xuICAgICAgICAgICAgaWYgKHhNb3ZlbWVudCAhPT0gMCB8fCB5TW92ZW1lbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnggPSAobGFzdFBvcy54ID8/IDApIC0geE1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MueSA9IChsYXN0UG9zLnkgPz8gMCkgLSB5TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0IHBhbkJ5KHsgeDogeE1vdmVtZW50LCB5OiB5TW92ZW1lbnQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZXMobGFzdFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZXNEcmFnZ2FibGUsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIHNlbGVjdE5vZGVzT25EcmFnLCBvbk5vZGVEcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNTZWxlY3RhYmxlKSAmJiAhbXVsdGlTZWxlY3Rpb25BY3RpdmUgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlTG9va3VwLmdldChub2RlSWQpPy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHNlbGVjdGVkIG5vZGVzIHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiBzZWxlY3ROb2Rlc09uRHJhZyAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBvbk5vZGVNb3VzZURvd24/Lihub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgIGRyYWdJdGVtcyA9IGdldERyYWdJdGVtcyhub2RlTG9va3VwLCBub2Rlc0RyYWdnYWJsZSwgcG9pbnRlclBvcywgbm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDAgJiYgKG9uRHJhZ1N0YXJ0IHx8IG9uTm9kZURyYWdTdGFydCB8fCAoIW5vZGVJZCAmJiBvblNlbGVjdGlvbkRyYWdTdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgZHJhZ0l0ZW1zLCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZDNEcmFnSW5zdGFuY2UgPSBkcmFnKClcbiAgICAgICAgICAgIC5jbGlja0Rpc3RhbmNlKG5vZGVDbGlja0Rpc3RhbmNlKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb21Ob2RlLCBub2RlRHJhZ1RocmVzaG9sZCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGFib3J0RHJhZyA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgICAgICAgICAgaWYgKG5vZGVEcmFnVGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBtb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRvUGFuT25Ob2RlRHJhZywgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZURyYWdUaHJlc2hvbGQsIG5vZGVMb29rdXAgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgZHJhZ0V2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgPT09ICd0b3VjaG1vdmUnICYmIGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIGRlbGV0ZXMgYSBub2RlIHdoaWxlIGRyYWdnaW5nLCB3ZSBuZWVkIHRvIGFib3J0IHRoZSBkcmFnIHRvIHByZXZlbnQgZXJyb3JzXG4gICAgICAgICAgICAgICAgKG5vZGVJZCAmJiAhbm9kZUxvb2t1cC5oYXMobm9kZUlkKSkpIHtcbiAgICAgICAgICAgICAgICBhYm9ydERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0RHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXV0b1BhblN0YXJ0ZWQgJiYgYXV0b1Bhbk9uTm9kZURyYWcgJiYgZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwb2ludGVyUG9zLnhTbmFwcGVkIC0gKGxhc3RQb3MueCA/PyAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gcG9pbnRlclBvcy55U25hcHBlZCAtIChsYXN0UG9zLnkgPz8gMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbm9kZURyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIGV2ZW50cyB3aXRob3V0IG1vdmVtZW50XG4gICAgICAgICAgICBpZiAoKGxhc3RQb3MueCAhPT0gcG9pbnRlclBvcy54U25hcHBlZCB8fCBsYXN0UG9zLnkgIT09IHBvaW50ZXJQb3MueVNuYXBwZWQpICYmIGRyYWdJdGVtcyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQgfHwgYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdXBkYXRlTm9kZVBvc2l0aW9ucywgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZ1N0b3AgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVBvc2l0aW9uc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uRHJhZ1N0b3AgfHwgb25Ob2RlRHJhZ1N0b3AgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gIWV2ZW50LmJ1dHRvbiAmJlxuICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgZG9tTm9kZSkpICYmXG4gICAgICAgICAgICAgICAgKCFoYW5kbGVTZWxlY3RvciB8fCBoYXNTZWxlY3Rvcih0YXJnZXQsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNEcmFnZ2FibGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5jYWxsKGQzRHJhZ0luc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNTZWxlY3Rpb24/Lm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggLSBkaXN0YW5jZSxcbiAgICAgICAgeTogcG9zaXRpb24ueSAtIGRpc3RhbmNlLFxuICAgICAgICB3aWR0aDogZGlzdGFuY2UgKiAyLFxuICAgICAgICBoZWlnaHQ6IGRpc3RhbmNlICogMixcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTG9va3VwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChnZXRPdmVybGFwcGluZ0FyZWEocmVjdCwgbm9kZVRvUmVjdChub2RlKSkgPiAwKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbi8qXG4gKiB0aGlzIGRpc3RhbmNlIGlzIHVzZWQgZm9yIHRoZSBhcmVhIGFyb3VuZCB0aGUgdXNlciBwb2ludGVyXG4gKiB3aGlsZSBkb2luZyBhIGNvbm5lY3Rpb24gZm9yIGZpbmRpbmcgdGhlIGNsb3Nlc3Qgbm9kZXNcbiAqL1xuY29uc3QgQURESVRJT05BTF9ESVNUQU5DRSA9IDI1MDtcbmZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUocG9zaXRpb24sIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpIHtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZXMgPSBbXTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjbG9zZU5vZGVzID0gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgY29ubmVjdGlvblJhZGl1cyArIEFERElUSU9OQUxfRElTVEFOQ0UpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbG9zZU5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGFsbEhhbmRsZXMgPSBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGFsbEhhbmRsZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoYW5kbGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZyb21IYW5kbGUgd2Ugc2tpcCBpdFxuICAgICAgICAgICAgaWYgKGZyb21IYW5kbGUubm9kZUlkID09PSBoYW5kbGUubm9kZUlkICYmIGZyb21IYW5kbGUudHlwZSA9PT0gaGFuZGxlLnR5cGUgJiYgZnJvbUhhbmRsZS5pZCA9PT0gaGFuZGxlLmlkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyh5IC0gcG9zaXRpb24ueSwgMikpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gY29ubmVjdGlvblJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcyA9IFt7IC4uLmhhbmRsZSwgeCwgeSB9XTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMucHVzaCh7IC4uLmhhbmRsZSwgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3RIYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIG92ZXJsYXkgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9wcG9zaXRlIGhhbmRsZVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IG9wcG9zaXRlSGFuZGxlVHlwZSA9IGZyb21IYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXMuZmluZCgoaGFuZGxlKSA9PiBoYW5kbGUudHlwZSA9PT0gb3Bwb3NpdGVIYW5kbGVUeXBlKSA/PyBjbG9zZXN0SGFuZGxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB3aXRoQWJzb2x1dGVQb3NpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVzID0gY29ubmVjdGlvbk1vZGUgPT09ICdzdHJpY3QnXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV1cbiAgICAgICAgOiBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgY29uc3QgaGFuZGxlID0gKGhhbmRsZUlkID8gaGFuZGxlcz8uZmluZCgoaCkgPT4gaC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlcz8uWzBdKSA/PyBudWxsO1xuICAgIHJldHVybiBoYW5kbGUgJiYgd2l0aEFic29sdXRlUG9zaXRpb25cbiAgICAgICAgPyB7IC4uLmhhbmRsZSwgLi4uZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBoYW5kbGUucG9zaXRpb24sIHRydWUpIH1cbiAgICAgICAgOiBoYW5kbGU7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvblZhbGlkKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cywgaXNIYW5kbGVWYWxpZCkge1xuICAgIGxldCBpc1ZhbGlkID0gbnVsbDtcbiAgICBpZiAoaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzICYmICFpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5cbmNvbnN0IGFsd2F5c1ZhbGlkID0gKCkgPT4gdHJ1ZTtcbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIHsgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUlkLCBub2RlSWQsIGVkZ2VVcGRhdGVyVHlwZSwgaXNUYXJnZXQsIGRvbU5vZGUsIG5vZGVMb29rdXAsIGxpYiwgYXV0b1Bhbk9uQ29ubmVjdCwgZmxvd0lkLCBwYW5CeSwgY2FuY2VsQ29ubmVjdGlvbiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdCwgb25Db25uZWN0RW5kLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBvblJlY29ubmVjdEVuZCwgdXBkYXRlQ29ubmVjdGlvbiwgZ2V0VHJhbnNmb3JtLCBnZXRGcm9tSGFuZGxlLCBhdXRvUGFuU3BlZWQsIGRyYWdUaHJlc2hvbGQgPSAxLCBoYW5kbGVEb21Ob2RlLCB9KSB7XG4gICAgLy8gd2hlbiB4eWZsb3cgaXMgdXNlZCBpbnNpZGUgYSBzaGFkb3cgcm9vdCB3ZSBjYW4ndCB1c2UgZG9jdW1lbnRcbiAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBjbG9zZXN0SGFuZGxlO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgY29ubmVjdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWNvbnRhaW5lckJvdW5kcyB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyb21IYW5kbGVJbnRlcm5hbCA9IGdldEhhbmRsZShub2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSk7XG4gICAgaWYgKCFmcm9tSGFuZGxlSW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHRIYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIG1vdmluZyB0aGUgbW91c2UgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhcyB3aGlsZSBjb25uZWN0aW5nIHdlIG1vdmUgdGhlIGNhbnZhc1xuICAgIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uQ29ubmVjdCB8fCAhY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3gsIHldID0gY2FsY0F1dG9QYW4ocG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgcGFuQnkoeyB4LCB5IH0pO1xuICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgfVxuICAgIC8vIFN0YXlzIHRoZSBzYW1lIGZvciBhbGwgY29uc2VjdXRpdmUgcG9pbnRlcm1vdmUgZXZlbnRzXG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IHtcbiAgICAgICAgLi4uZnJvbUhhbmRsZUludGVybmFsLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiBmcm9tSGFuZGxlSW50ZXJuYWwucG9zaXRpb24sXG4gICAgfTtcbiAgICBjb25zdCBmcm9tTm9kZUludGVybmFsID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBmcm9tID0gZ2V0SGFuZGxlUG9zaXRpb24oZnJvbU5vZGVJbnRlcm5hbCwgZnJvbUhhbmRsZSwgUG9zaXRpb24uTGVmdCwgdHJ1ZSk7XG4gICAgbGV0IHByZXZpb3VzQ29ubmVjdGlvbiA9IHtcbiAgICAgICAgaW5Qcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgaXNWYWxpZDogbnVsbCxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgZnJvbUhhbmRsZSxcbiAgICAgICAgZnJvbVBvc2l0aW9uOiBmcm9tSGFuZGxlLnBvc2l0aW9uLFxuICAgICAgICBmcm9tTm9kZTogZnJvbU5vZGVJbnRlcm5hbCxcbiAgICAgICAgdG86IHBvc2l0aW9uLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICAgICAgdG9Qb3NpdGlvbjogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgdG9Ob2RlOiBudWxsLFxuICAgIH07XG4gICAgZnVuY3Rpb24gc3RhcnRDb25uZWN0aW9uKCkge1xuICAgICAgICBjb25uZWN0aW9uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24ocHJldmlvdXNDb25uZWN0aW9uKTtcbiAgICAgICAgb25Db25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pO1xuICAgIH1cbiAgICBpZiAoZHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICBzdGFydENvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25TdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHg6IGV2dFgsIHk6IGV2dFkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgZHggPSBldnRYIC0geDtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gZXZ0WSAtIHk7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q29ubmVjdGlvblN0YXJ0ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGRyYWdUaHJlc2hvbGQgKiBkcmFnVGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKCFuZXh0Q29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydENvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdldEZyb21IYW5kbGUoKSB8fCAhZnJvbUhhbmRsZSkge1xuICAgICAgICAgICAgb25Qb2ludGVyVXAoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICBwb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIGNsb3Nlc3RIYW5kbGUgPSBnZXRDbG9zZXN0SGFuZGxlKHBvaW50VG9SZW5kZXJlclBvaW50KHBvc2l0aW9uLCB0cmFuc2Zvcm0sIGZhbHNlLCBbMSwgMV0pLCBjb25uZWN0aW9uUmFkaXVzLCBub2RlTG9va3VwLCBmcm9tSGFuZGxlKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWRIYW5kbGUoZXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZTogY2xvc2VzdEhhbmRsZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogbm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBpc1RhcmdldCA/ICd0YXJnZXQnIDogJ3NvdXJjZScsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRIYW5kbGVEb21Ob2RlID0gcmVzdWx0LmhhbmRsZURvbU5vZGU7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXN1bHQuY29ubmVjdGlvbjtcbiAgICAgICAgaXNWYWxpZCA9IGlzQ29ubmVjdGlvblZhbGlkKCEhY2xvc2VzdEhhbmRsZSwgcmVzdWx0LmlzVmFsaWQpO1xuICAgICAgICBjb25zdCBuZXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgLy8gZnJvbSBzdGF5cyB0aGUgc2FtZVxuICAgICAgICAgICAgLi4ucHJldmlvdXNDb25uZWN0aW9uLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIHRvOiByZXN1bHQudG9IYW5kbGUgJiYgaXNWYWxpZFxuICAgICAgICAgICAgICAgID8gcmVuZGVyZXJQb2ludFRvUG9pbnQoeyB4OiByZXN1bHQudG9IYW5kbGUueCwgeTogcmVzdWx0LnRvSGFuZGxlLnkgfSwgdHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIDogcG9zaXRpb24sXG4gICAgICAgICAgICB0b0hhbmRsZTogcmVzdWx0LnRvSGFuZGxlLFxuICAgICAgICAgICAgdG9Qb3NpdGlvbjogaXNWYWxpZCAmJiByZXN1bHQudG9IYW5kbGUgPyByZXN1bHQudG9IYW5kbGUucG9zaXRpb24gOiBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21IYW5kbGUucG9zaXRpb25dLFxuICAgICAgICAgICAgdG9Ob2RlOiByZXN1bHQudG9IYW5kbGUgPyBub2RlTG9va3VwLmdldChyZXN1bHQudG9IYW5kbGUubm9kZUlkKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbiB1cGRhdGUgd2hlbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAgKiBpcyBzbmFwcGVkIHRvIHRoZSBzYW1lIGhhbmRsZSBhcyBiZWZvcmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1ZhbGlkICYmXG4gICAgICAgICAgICBjbG9zZXN0SGFuZGxlICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS50eXBlID09PSBuZXdDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUubm9kZUlkICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by54ID09PSBuZXdDb25uZWN0aW9uLnRvLnggJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by55ID09PSBuZXdDb25uZWN0aW9uLnRvLnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKG5ld0Nvbm5lY3Rpb24pO1xuICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGlmICgoY2xvc2VzdEhhbmRsZSB8fCByZXN1bHRIYW5kbGVEb21Ob2RlKSAmJiBjb25uZWN0aW9uICYmIGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q/Lihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpdCdzIGltcG9ydGFudCB0byBnZXQgYSBmcmVzaCByZWZlcmVuY2UgZnJvbSB0aGUgc3RvcmUgaGVyZVxuICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gZ2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2Ygb25Db25uZWN0RW5kXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgLi4uY29ubmVjdGlvblN0YXRlIH0gPSBwcmV2aW91c0Nvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBmaW5hbENvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5jb25uZWN0aW9uU3RhdGUsXG4gICAgICAgICAgICAgICAgdG9Qb3NpdGlvbjogcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlID8gcHJldmlvdXNDb25uZWN0aW9uLnRvUG9zaXRpb24gOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uQ29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldmVudCwgZmluYWxDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb24oKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmVzdWx0SGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xuICAgIH1cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbn1cbi8vIGNoZWNrcyBpZiAgYW5kIHJldHVybnMgY29ubmVjdGlvbiBpbiBmb20gb2YgYW4gb2JqZWN0IHsgc291cmNlOiAxMjMsIHRhcmdldDogMzEyIH1cbmZ1bmN0aW9uIGlzVmFsaWRIYW5kbGUoZXZlbnQsIHsgaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgZnJvbU5vZGVJZCwgZnJvbUhhbmRsZUlkLCBmcm9tVHlwZSwgZG9jLCBsaWIsIGZsb3dJZCwgaXNWYWxpZENvbm5lY3Rpb24gPSBhbHdheXNWYWxpZCwgbm9kZUxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZnJvbVR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IGhhbmRsZURvbU5vZGUgPSBoYW5kbGVcbiAgICAgICAgPyBkb2MucXVlcnlTZWxlY3RvcihgLiR7bGlifS1mbG93X19oYW5kbGVbZGF0YS1pZD1cIiR7Zmxvd0lkfS0ke2hhbmRsZT8ubm9kZUlkfS0ke2hhbmRsZT8uaWR9LSR7aGFuZGxlPy50eXBlfVwiXWApXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGhhbmRsZUJlbG93ID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgLypcbiAgICAgKiB3ZSBhbHdheXMgd2FudCB0byBwcmlvcml0aXplIHRoZSBoYW5kbGUgYmVsb3cgdGhlIG1vdXNlIGN1cnNvciBvdmVyIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGhhbmRsZSxcbiAgICAgKiBiZWNhdXNlIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGNlbnRlciBvZiBhbm90aGVyIGhhbmRsZSBpcyBjbG9zZXIgdG8gdGhlIG1vdXNlIHBvaW50ZXIgdGhhbiB0aGUgaGFuZGxlIGJlbG93IHRoZSBjdXJzb3JcbiAgICAgKi9cbiAgICBjb25zdCBoYW5kbGVUb0NoZWNrID0gaGFuZGxlQmVsb3c/LmNsYXNzTGlzdC5jb250YWlucyhgJHtsaWJ9LWZsb3dfX2hhbmRsZWApID8gaGFuZGxlQmVsb3cgOiBoYW5kbGVEb21Ob2RlO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgaGFuZGxlRG9tTm9kZTogaGFuZGxlVG9DaGVjayxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb246IG51bGwsXG4gICAgICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIH07XG4gICAgaWYgKGhhbmRsZVRvQ2hlY2spIHtcbiAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVUb0NoZWNrKTtcbiAgICAgICAgY29uc3QgaGFuZGxlTm9kZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGUgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGUnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGVFbmQgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGVlbmQnKTtcbiAgICAgICAgaWYgKCFoYW5kbGVOb2RlSWQgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogaXNUYXJnZXQgPyBoYW5kbGVOb2RlSWQgOiBmcm9tTm9kZUlkLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBpc1RhcmdldCA/IGhhbmRsZUlkIDogZnJvbUhhbmRsZUlkLFxuICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCA/IGZyb21Ob2RlSWQgOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGlzVGFyZ2V0ID8gZnJvbUhhbmRsZUlkIDogaGFuZGxlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlICYmIGNvbm5lY3RhYmxlRW5kO1xuICAgICAgICAvLyBpbiBzdHJpY3QgbW9kZSB3ZSBkb24ndCBhbGxvdyB0YXJnZXQgdG8gdGFyZ2V0IG9yIHNvdXJjZSB0byBzb3VyY2UgY29ubmVjdGlvbnNcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgIChjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICAgICAgPyAoaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScpIHx8ICghaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3RhcmdldCcpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVOb2RlSWQgIT09IGZyb21Ob2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGVJZCk7XG4gICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gaXNWYWxpZCAmJiBpc1ZhbGlkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgcmVzdWx0LnRvSGFuZGxlID0gZ2V0SGFuZGxlKGhhbmRsZU5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFhZSGFuZGxlID0ge1xuICAgIG9uUG9pbnRlckRvd24sXG4gICAgaXNWYWxpZDogaXNWYWxpZEhhbmRsZSxcbn07XG5cbmZ1bmN0aW9uIFhZTWluaW1hcCh7IGRvbU5vZGUsIHBhblpvb20sIGdldFRyYW5zZm9ybSwgZ2V0Vmlld1NjYWxlIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB6b29tU3RlcCA9IDEsIHBhbm5hYmxlID0gdHJ1ZSwgem9vbWFibGUgPSB0cnVlLCBpbnZlcnNlUGFuID0gZmFsc2UsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgem9vbUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnd2hlZWwnIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPSBldmVudC5zb3VyY2VFdmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAoZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKlxuICAgICAgICAgICAgICAgIHpvb21TdGVwO1xuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0cmFuc2Zvcm1bMl0gKiBNYXRoLnBvdygyLCBwaW5jaERlbHRhICogZmFjdG9yKTtcbiAgICAgICAgICAgIHBhblpvb20uc2NhbGVUbyhuZXh0Wm9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYW5TdGFydCA9IFswLCAwXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFuU3RhcnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgcGFuU3RhcnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3RvdWNobW92ZScpIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFuQ3VycmVudCA9IFtcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRYID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYW5EZWx0YSA9IFtwYW5DdXJyZW50WzBdIC0gcGFuU3RhcnRbMF0sIHBhbkN1cnJlbnRbMV0gLSBwYW5TdGFydFsxXV07XG4gICAgICAgICAgICBwYW5TdGFydCA9IHBhbkN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSBnZXRWaWV3U2NhbGUoKSAqIE1hdGgubWF4KHRyYW5zZm9ybVsyXSwgTWF0aC5sb2codHJhbnNmb3JtWzJdKSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gLSBwYW5EZWx0YVswXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gLSBwYW5EZWx0YVsxXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHpvb21BbmRQYW5IYW5kbGVyID0gem9vbSgpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgcGFuU3RhcnRIYW5kbGVyKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tJywgcGFubmFibGUgPyBwYW5IYW5kbGVyIDogbnVsbClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC5vbignem9vbS53aGVlbCcsIHpvb21hYmxlID8gem9vbUhhbmRsZXIgOiBudWxsKTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoem9vbUFuZFBhbkhhbmRsZXIsIHt9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgcG9pbnRlcixcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCB2aWV3Q2hhbmdlZCA9IChwcmV2Vmlld3BvcnQsIGV2ZW50Vmlld3BvcnQpID0+IHByZXZWaWV3cG9ydC54ICE9PSBldmVudFZpZXdwb3J0LnggfHwgcHJldlZpZXdwb3J0LnkgIT09IGV2ZW50Vmlld3BvcnQueSB8fCBwcmV2Vmlld3BvcnQuem9vbSAhPT0gZXZlbnRWaWV3cG9ydC5rO1xuY29uc3QgdHJhbnNmb3JtVG9WaWV3cG9ydCA9ICh0cmFuc2Zvcm0pID0+ICh7XG4gICAgeDogdHJhbnNmb3JtLngsXG4gICAgeTogdHJhbnNmb3JtLnksXG4gICAgem9vbTogdHJhbnNmb3JtLmssXG59KTtcbmNvbnN0IHZpZXdwb3J0VG9UcmFuc2Zvcm0gPSAoeyB4LCB5LCB6b29tIH0pID0+IHpvb21JZGVudGl0eS50cmFuc2xhdGUoeCwgeSkuc2NhbGUoem9vbSk7XG5jb25zdCBpc1dyYXBwZWRXaXRoQ2xhc3MgPSAoZXZlbnQsIGNsYXNzTmFtZSkgPT4gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoYC4ke2NsYXNzTmFtZX1gKTtcbmNvbnN0IGlzUmlnaHRDbGlja1BhbiA9IChwYW5PbkRyYWcsIHVzZWRCdXR0b24pID0+IHVzZWRCdXR0b24gPT09IDIgJiYgQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygyKTtcbi8vIHRha2VuIGZyb20gZDMtZWFzZTogaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWVhc2UvYmxvYi9tYWluL3NyYy9jdWJpYy5qc1xuY29uc3QgZGVmYXVsdEVhc2UgPSAodCkgPT4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xuY29uc3QgZ2V0RDNUcmFuc2l0aW9uID0gKHNlbGVjdGlvbiwgZHVyYXRpb24gPSAwLCBlYXNlID0gZGVmYXVsdEVhc2UsIG9uRW5kID0gKCkgPT4geyB9KSA9PiB7XG4gICAgY29uc3QgaGFzRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInICYmIGR1cmF0aW9uID4gMDtcbiAgICBpZiAoIWhhc0R1cmF0aW9uKSB7XG4gICAgICAgIG9uRW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNEdXJhdGlvbiA/IHNlbGVjdGlvbi50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmVhc2UoZWFzZSkub24oJ2VuZCcsIG9uRW5kKSA6IHNlbGVjdGlvbjtcbn07XG5jb25zdCB3aGVlbERlbHRhID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZmFjdG9yID0gZXZlbnQuY3RybEtleSAmJiBpc01hY09zKCkgPyAxMCA6IDE7XG4gICAgcmV0dXJuIC1ldmVudC5kZWx0YVkgKiAoZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKiBmYWN0b3I7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBub1doZWVsQ2xhc3NOYW1lLCBkM1NlbGVjdGlvbiwgZDNab29tLCBwYW5PblNjcm9sbE1vZGUsIHBhbk9uU2Nyb2xsU3BlZWQsIHpvb21PblBpbmNoLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tLCBvblBhblpvb21FbmQsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpLmsgfHwgMTtcbiAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICogZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVsdGFOb3JtYWxpemUgPSBldmVudC5kZWx0YU1vZGUgPT09IDEgPyAyMCA6IDE7XG4gICAgICAgIGxldCBkZWx0YVggPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCA/IDAgOiBldmVudC5kZWx0YVggKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLkhvcml6b250YWwgPyAwIDogZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgIC8vIHRoaXMgZW5hYmxlcyB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2l0aCBzaGlmdCArIHNjcm9sbCBvbiB3aW5kb3dzXG4gICAgICAgIGlmICghaXNNYWNPcygpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykpO1xuICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICogd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICogYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmICghem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZykge1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucGFuU2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlWm9vbU9uU2Nyb2xsSGFuZGxlcih7IG5vV2hlZWxDbGFzc05hbWUsIHByZXZlbnRTY3JvbGxpbmcsIGQzWm9vbUhhbmRsZXIgfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGQpIHtcbiAgICAgICAgY29uc3QgaXNXaGVlbCA9IGV2ZW50LnR5cGUgPT09ICd3aGVlbCc7XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gZW5hYmxlIHBpbmNoIHpvb21pbmcgZXZlbiBpZiBwcmV2ZW50U2Nyb2xsaW5nIGlzIHNldCB0byBmYWxzZVxuICAgICAgICBjb25zdCBwcmV2ZW50Wm9vbSA9ICFwcmV2ZW50U2Nyb2xsaW5nICYmIGlzV2hlZWwgJiYgIWV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGNvbnN0IGhhc05vV2hlZWxDbGFzcyA9IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSk7XG4gICAgICAgIC8vIGlmIHVzZXIgaXMgcGluY2ggem9vbWluZyBhYm92ZSBhIG5vd2hlZWwgZWxlbWVudCwgd2UgZG9uJ3Qgd2FudCB0aGUgYnJvd3NlciB0byB6b29tXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGlzV2hlZWwgJiYgaGFzTm9XaGVlbENsYXNzKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50Wm9vbSB8fCBoYXNOb1doZWVsQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGQzWm9vbUhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCwgZCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21TdGFydEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21TdGFydCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaXQgaGVyZSwgYmVjYXVzZSBpdCdzIGFsd2F5cyAwIGluIHRoZSBcInpvb21cIiBldmVudFxuICAgICAgICB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID0gZXZlbnQuc291cmNlRXZlbnQ/LmJ1dHRvbiB8fCAwO1xuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IHRydWU7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8udHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbVN0YXJ0KSB7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIG9uUGFuZUNvbnRleHRNZW51LCBvblRyYW5zZm9ybUNoYW5nZSwgb25QYW5ab29tLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gISEob25QYW5lQ29udGV4dE1lbnUgJiYgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSk7XG4gICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQ/LnN5bmMpIHtcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlKFtldmVudC50cmFuc2Zvcm0ueCwgZXZlbnQudHJhbnNmb3JtLnksIGV2ZW50LnRyYW5zZm9ybS5rXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbSAmJiAhZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudC5zb3VyY2VFdmVudCwgdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbUVuZCwgb25QYW5lQ29udGV4dE1lbnUsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAob25QYW5lQ29udGV4dE1lbnUgJiZcbiAgICAgICAgICAgIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkgJiZcbiAgICAgICAgICAgICF6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uICYmXG4gICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUoZXZlbnQuc291cmNlRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgb25EcmFnZ2luZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIGlmIChvblBhblpvb21FbmQgJiYgdmlld0NoYW5nZWQoem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQsIGV2ZW50LnRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnRpbWVySWQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNldFRpbWVvdXQgZm9yIHBhbk9uU2Nyb2xsIHRvIHN1cHJlc3MgbXVsdGlwbGUgZW5kIGV2ZW50cyBmaXJlZCBkdXJpbmcgc2Nyb2xsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCA/IDE1MCA6IDApO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKHsgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGxpYiwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgem9vbVNjcm9sbCA9IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCB6b29tT25TY3JvbGw7XG4gICAgICAgIGNvbnN0IHBpbmNoWm9vbSA9IHpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDEgJiZcbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmXG4gICAgICAgICAgICAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBgJHtsaWJ9LWZsb3dfX25vZGVgKSB8fCBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fZWRnZWApKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWxsIGludGVyYWN0aW9ucyBhcmUgZGlzYWJsZWQsIHdlIHByZXZlbnQgYWxsIHpvb20gZXZlbnRzXG4gICAgICAgIGlmICghcGFuT25EcmFnICYmICF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhem9vbU9uRG91YmxlQ2xpY2sgJiYgIXpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZHVyaW5nIGEgc2VsZWN0aW9uIHdlIHByZXZlbnQgYWxsIG90aGVyIGludGVyYWN0aW9uc1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3doZWVsIGNsYXNzLCB3ZSBwcmV2ZW50IHpvb21pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3BhbiBjbGFzcywgd2UgcHJldmVudCBwYW5uaW5nXG4gICAgICAgIGlmIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vUGFuQ2xhc3NOYW1lKSAmJlxuICAgICAgICAgICAgKGV2ZW50LnR5cGUgIT09ICd3aGVlbCcgfHwgKHBhbk9uU2Nyb2xsICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5ICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBldmVudC50b3VjaGVzPy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiB5b3UgbWFuYWdlIHRvIHN0YXJ0IHdpdGggMiB0b3VjaGVzLCB3ZSBwcmV2ZW50IG5hdGl2ZSB6b29tXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgIGlmICghem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXBpbmNoWm9vbSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgbm90IG1vdmFibGUsIHdlIHByZXZlbnQgZHJhZ2dpbmcgaXQgd2l0aCBtb3VzZXN0YXJ0IG9yIHRvdWNoc3RhcnRcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBvbmx5IG1vdmFibGUgdXNpbmcgYWxsb3dlZCBjbGlja3NcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiAhcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IHJpZ2h0IGNsaWNrcyBpZiBwYW4gb24gZHJhZyBpcyBzZXQgdG8gcmlnaHQgY2xpY2tcbiAgICAgICAgY29uc3QgYnV0dG9uQWxsb3dlZCA9IChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbikpIHx8ICFldmVudC5idXR0b24gfHwgZXZlbnQuYnV0dG9uIDw9IDE7XG4gICAgICAgIC8vIGRlZmF1bHQgZmlsdGVyIGZvciBkMy16b29tXG4gICAgICAgIHJldHVybiAoIWV2ZW50LmN0cmxLZXkgfHwgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBYWVBhblpvb20oeyBkb21Ob2RlLCBtaW5ab29tLCBtYXhab29tLCBwYW5lQ2xpY2tEaXN0YW5jZSwgdHJhbnNsYXRlRXh0ZW50LCB2aWV3cG9ydCwgb25QYW5ab29tLCBvblBhblpvb21TdGFydCwgb25QYW5ab29tRW5kLCBvbkRyYWdnaW5nQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgem9vbVBhblZhbHVlcyA9IHtcbiAgICAgICAgaXNab29taW5nT3JQYW5uaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlZFJpZ2h0TW91c2VCdXR0b246IGZhbHNlLFxuICAgICAgICBwcmV2Vmlld3BvcnQ6IHsgeDogMCwgeTogMCwgem9vbTogMCB9LFxuICAgICAgICBtb3VzZUJ1dHRvbjogMCxcbiAgICAgICAgdGltZXJJZDogdW5kZWZpbmVkLFxuICAgICAgICBwYW5TY3JvbGxUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIGlzUGFuU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGJib3ggPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGQzWm9vbUluc3RhbmNlID0gem9vbSgpXG4gICAgICAgIC5jbGlja0Rpc3RhbmNlKCFpc051bWVyaWMocGFuZUNsaWNrRGlzdGFuY2UpIHx8IHBhbmVDbGlja0Rpc3RhbmNlIDwgMCA/IDAgOiBwYW5lQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgLnNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSlcbiAgICAgICAgLnRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IGQzU2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpLmNhbGwoZDNab29tSW5zdGFuY2UpO1xuICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICB4OiB2aWV3cG9ydC54LFxuICAgICAgICB5OiB2aWV3cG9ydC55LFxuICAgICAgICB6b29tOiBjbGFtcCh2aWV3cG9ydC56b29tLCBtaW5ab29tLCBtYXhab29tKSxcbiAgICB9LCBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW2Jib3gud2lkdGgsIGJib3guaGVpZ2h0XSxcbiAgICBdLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIGNvbnN0IGQzWm9vbUhhbmRsZXIgPSBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScpO1xuICAgIGNvbnN0IGQzRGJsQ2xpY2tab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJyk7XG4gICAgZDNab29tSW5zdGFuY2Uud2hlZWxEZWx0YSh3aGVlbERlbHRhKTtcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0odHJhbnNmb3JtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LmludGVycG9sYXRlKG9wdGlvbnM/LmludGVycG9sYXRlID09PSAnbGluZWFyJyA/IGludGVycG9sYXRlIDogaW50ZXJwb2xhdGVab29tKS50cmFuc2Zvcm0oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgb3B0aW9ucz8uZWFzZSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgLy8gcHVibGljIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblBhbmVDb250ZXh0TWVudSwgdXNlclNlbGVjdGlvbkFjdGl2ZSwgcGFuT25TY3JvbGwsIHBhbk9uRHJhZywgcGFuT25TY3JvbGxNb2RlLCBwYW5PblNjcm9sbFNwZWVkLCBwcmV2ZW50U2Nyb2xsaW5nLCB6b29tT25QaW5jaCwgem9vbU9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCBsaWIsIG9uVHJhbnNmb3JtQ2hhbmdlLCB9KSB7XG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlICYmICF6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZykge1xuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUGFuT25TY3JvbGwgPSBwYW5PblNjcm9sbCAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkICYmICF1c2VyU2VsZWN0aW9uQWN0aXZlO1xuICAgICAgICBjb25zdCB3aGVlbEhhbmRsZXIgPSBpc1Bhbk9uU2Nyb2xsXG4gICAgICAgICAgICA/IGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGQzU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGQzWm9vbTogZDNab29tSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJywgd2hlZWxIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIHN0YXJ0XG4gICAgICAgICAgICBjb25zdCBzdGFydEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdzdGFydCcsIHN0YXJ0SGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbVxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUhhbmRsZXIgPSBjcmVhdGVQYW5ab29tSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnU6ICEhb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIHBhblpvb21IYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIGVuZFxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUVuZEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdlbmQnLCBwYW5ab29tRW5kSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY3JlYXRlRmlsdGVyKHtcbiAgICAgICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgIH0pO1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2UgY2Fubm90IGFkZCB6b29tT25Eb3VibGVDbGljayB0byB0aGUgZmlsdGVyIGFib3ZlIGJlY2F1c2VcbiAgICAgICAgICogZG91YmxlIHRhcHBpbmcgb24gdG91Y2ggc2NyZWVucyBjaXJjdW12ZW50cyB0aGUgZmlsdGVyIGFuZFxuICAgICAgICAgKiBkYmxjbGljay56b29tIGlzIGZpcmVkIG9uIHRoZSBzZWxlY3Rpb24gZGlyZWN0bHlcbiAgICAgICAgICovXG4gICAgICAgIGlmICh6b29tT25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBkM0RibENsaWNrWm9vbUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHZpZXdwb3J0LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgIGNvbnN0IGNvbnRyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb21JbnN0YW5jZT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBpZiAoY29udHJhaW5lZFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKGNvbnRyYWluZWRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShjb250cmFpbmVkVHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0KHZpZXdwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKG5leHRUcmFuc2Zvcm0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUobmV4dFRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzeW5jVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0uayAhPT0gdmlld3BvcnQuem9vbSB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueCAhPT0gdmlld3BvcnQueCB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueSAhPT0gdmlld3BvcnQueSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zZm9ybShkM1NlbGVjdGlvbiwgbmV4dFRyYW5zZm9ybSwgbnVsbCwgeyBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0KCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBkM1NlbGVjdGlvbiA/IHpvb21UcmFuc2Zvcm0oZDNTZWxlY3Rpb24ubm9kZSgpKSA6IHsgeDogMCwgeTogMCwgazogMSB9O1xuICAgICAgICByZXR1cm4geyB4OiB0cmFuc2Zvcm0ueCwgeTogdHJhbnNmb3JtLnksIHpvb206IHRyYW5zZm9ybS5rIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8oem9vbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkuc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgem9vbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uaW50ZXJwb2xhdGUob3B0aW9ucz8uaW50ZXJwb2xhdGUgPT09ICdsaW5lYXInID8gaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVpvb20pLnNjYWxlQnkoZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgb3B0aW9ucz8uZWFzZSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIGZhY3Rvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0U2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENsaWNrRGlzdGFuY2UoZGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgdmFsaWREaXN0YW5jZSA9ICFpc051bWVyaWMoZGlzdGFuY2UpIHx8IGRpc3RhbmNlIDwgMCA/IDAgOiBkaXN0YW5jZTtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LmNsaWNrRGlzdGFuY2UodmFsaWREaXN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgc2V0Vmlld3BvcnQsXG4gICAgICAgIHNldFZpZXdwb3J0Q29uc3RyYWluZWQsXG4gICAgICAgIGdldFZpZXdwb3J0LFxuICAgICAgICBzY2FsZVRvLFxuICAgICAgICBzY2FsZUJ5LFxuICAgICAgICBzZXRTY2FsZUV4dGVudCxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBzeW5jVmlld3BvcnQsXG4gICAgICAgIHNldENsaWNrRGlzdGFuY2UsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGRldGVybWluZSB0aGUgdmFyaWFudCBvZiB0aGUgcmVzaXplIGNvbnRyb2xcbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZXNpemVDb250cm9sVmFyaWFudDtcbihmdW5jdGlvbiAoUmVzaXplQ29udHJvbFZhcmlhbnQpIHtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkhhbmRsZVwiXSA9IFwiaGFuZGxlXCI7XG59KShSZXNpemVDb250cm9sVmFyaWFudCB8fCAoUmVzaXplQ29udHJvbFZhcmlhbnQgPSB7fSkpO1xuY29uc3QgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TID0gWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcblxuLyoqXG4gKiBHZXQgYWxsIGNvbm5lY3RpbmcgZWRnZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIG5vZGVzXG4gKiBAcGFyYW0gd2lkdGggLSBuZXcgd2lkdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2V2lkdGggLSBwcmV2aW91cyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGhlaWdodCAtIG5ldyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2SGVpZ2h0IC0gcHJldmlvdXMgaGVpZ2h0IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gYWZmZWN0c1ggLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHggYXhpc1xuICogQHBhcmFtIGFmZmVjdHNZIC0gd2hldGhlciB0byBpbnZlcnQgdGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoZSB5IGF4aXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIHR3byBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByZXNpemUgZm9yIGVhY2ggYXhpcywgMCA9IG5vIGNoYW5nZSwgMSA9IGluY3JlYXNlLCAtMSA9IGRlY3JlYXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZURpcmVjdGlvbih7IHdpZHRoLCBwcmV2V2lkdGgsIGhlaWdodCwgcHJldkhlaWdodCwgYWZmZWN0c1gsIGFmZmVjdHNZLCB9KSB7XG4gICAgY29uc3QgZGVsdGFXaWR0aCA9IHdpZHRoIC0gcHJldldpZHRoO1xuICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID0gaGVpZ2h0IC0gcHJldkhlaWdodDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBbZGVsdGFXaWR0aCA+IDAgPyAxIDogZGVsdGFXaWR0aCA8IDAgPyAtMSA6IDAsIGRlbHRhSGVpZ2h0ID4gMCA/IDEgOiBkZWx0YUhlaWdodCA8IDAgPyAtMSA6IDBdO1xuICAgIGlmIChkZWx0YVdpZHRoICYmIGFmZmVjdHNYKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IGRpcmVjdGlvblswXSAqIC0xO1xuICAgIH1cbiAgICBpZiAoZGVsdGFIZWlnaHQgJiYgYWZmZWN0c1kpIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gZGlyZWN0aW9uWzFdICogLTE7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgY29udHJvbCBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIGRyYWdnZWQgdG8gZGltZW5zaW9ucyB0aGF0IGFyZSBiZWluZyByZXNpemVkXG4gKiBAcGFyYW0gY29udHJvbFBvc2l0aW9uIC0gcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgdGhhdCBpcyBiZWluZyBkcmFnZ2VkXG4gKiBAcmV0dXJucyBpc0hvcml6b250YWwsIGlzVmVydGljYWwsIGFmZmVjdHNYLCBhZmZlY3RzWSxcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3JpZ2h0JykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICBjb25zdCBhZmZlY3RzWCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIGNvbnN0IGFmZmVjdHNZID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0hvcml6b250YWwsXG4gICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgIGFmZmVjdHNYLFxuICAgICAgICBhZmZlY3RzWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJFeHRlbnRDbGFtcChsb3dlckV4dGVudCwgbG93ZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBsb3dlckJvdW5kIC0gbG93ZXJFeHRlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VXBwZXJFeHRlbnRDbGFtcCh1cHBlckV4dGVudCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCB1cHBlckV4dGVudCAtIHVwcGVyQm91bmQpO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZUNsYW1wKHNpemUsIG1pblNpemUsIG1heFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWluU2l6ZSAtIHNpemUsIHNpemUgLSBtYXhTaXplKTtcbn1cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyAhYiA6IGI7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgbmV3IHdpZHRoICYgaGVpZ2h0IGFuZCB4ICYgeSBvZiBub2RlIGFmdGVyIHJlc2l6ZSBiYXNlZCBvbiBwb2ludGVyIHBvc2l0aW9uXG4gKiBAZGVzY3JpcHRpb24gLSBCdWNrbGUgdXAsIHRoaXMgaXMgYSBjaHVua3kgb25lLi4uIElmIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgbmV3IGRpbWVuc2lvbnMgb2YgYSBub2RlIGFmdGVyIGEgcmVzaXplLFxuICogeW91IGhhdmUgdG8gYWNjb3VudCBmb3IgYWxsIHBvc3NpYmxlIHJlc3RyaWN0aW9uczogbWluL21heCB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUsIHRoZSBtYXhpbXVtIGV4dGVudCB0aGUgbm9kZSBpcyBhbGxvd2VkXG4gKiB0byBtb3ZlIGluIChpbiB0aGlzIGNhc2U6IHJlc2l6ZSBpbnRvKSBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgbm9kZSwgdGhlIG1pbmltYWwgZXh0ZW50IGRldGVybWluZWQgYnkgY2hpbGQgbm9kZXNcbiAqIHdpdGggZXhwYW5kUGFyZW50IG9yIGV4dGVudDogJ3BhcmVudCcgc2V0IGFuZCBvaCB5ZWFoLCB0aGVzZSB0aGluZ3MgYWxzbyBoYXZlIHRvIHdvcmsgd2l0aCBrZWVwQXNwZWN0UmF0aW8hXG4gKiBUaGUgd2F5IHRoaXMgaXMgZG9uZSBpcyBieSBkZXRlcm1pbmluZyBob3cgbXVjaCBlYWNoIG9mIHRoZXNlIHJlc3RyaWN0aW5nIGFjdHVhbGx5IHJlc3RyaWN0cyB0aGUgcmVzaXplIGFuZCB0aGVuIGFwcGx5aW5nIHRoZVxuICogc3Ryb25nZXN0IHJlc3RyaWN0aW9uLiBCZWNhdXNlIHRoZSByZXNpemUgYWZmZWN0cyB4LCB5IGFuZCB3aWR0aCwgaGVpZ2h0IGFuZCB3aWR0aCwgaGVpZ2h0IG9mIGEgb3Bwb3Npbmcgc2lkZSB3aXRoIGtlZXBBc3BlY3RSYXRpbyxcbiAqIHRoZSByZXNpemUgYW1vdW50IGlzIGFsd2F5cyBrZXB0IGluIGRpc3RYICYgZGlzdFkgYW1vdW50ICh0aGUgZGlzdGFuY2UgaW4gbW91c2UgbW92ZW1lbnQpXG4gKiBJbnN0ZWFkIG9mIGNsYW1waW5nIGVhY2ggdmFsdWUsIHdlIGZpcnN0IGNhbGN1bGF0ZSB0aGUgYmlnZ2VzdCAnY2xhbXAnIChmb3IgdGhlIGxhY2sgb2YgYSBiZXR0ZXIgbmFtZSkgYW5kIHRoZW4gYXBwbHkgaXQgdG8gYWxsIHZhbHVlcy5cbiAqIFRvIGNvbXBsaWNhdGUgdGhpbmdzIG5vZGVPcmlnaW4gaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCBhcyB3ZWxsLiBUaGlzIGlzIGRvbmUgYnkgb2Zmc2V0dGluZyB0aGUgbm9kZXMgYXMgaWYgdGhlaXIgb3JpZ2luIGlzIFswLCAwXSxcbiAqIHRoZW4gY2FsY3VsYXRpbmcgdGhlIHJlc3RyaWN0aW9ucyBhcyB1c3VhbFxuICogQHBhcmFtIHN0YXJ0VmFsdWVzIC0gc3RhcnRpbmcgdmFsdWVzIG9mIHJlc2l6ZVxuICogQHBhcmFtIGNvbnRyb2xEaXJlY3Rpb24gLSBkaW1lbnNpb25zIGFmZmVjdGVkIGJ5IHRoZSByZXNpemVcbiAqIEBwYXJhbSBwb2ludGVyUG9zaXRpb24gLSB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGNvcnJlY3RlZCBmb3Igc25hcHBpbmdcbiAqIEBwYXJhbSBib3VuZGFyaWVzIC0gbWluaW11bSBhbmQgbWF4aW11bSBkaW1lbnNpb25zIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ga2VlcEFzcGVjdFJhdGlvIC0gcHJldmVudCBjaGFuZ2VzIG9mIGFzcHJlY3QgcmF0aW9cbiAqIEByZXR1cm5zIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIG5vZGUgYWZ0ZXIgcmVzaXplXG4gKi9cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIGV4dGVudCwgY2hpbGRFeHRlbnQpIHtcbiAgICBsZXQgeyBhZmZlY3RzWCwgYWZmZWN0c1kgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgeyBpc0hvcml6b250YWwsIGlzVmVydGljYWwgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgaXNEaWFnb25hbCA9IGlzSG9yaXpvbnRhbCAmJiBpc1ZlcnRpY2FsO1xuICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBwb2ludGVyUG9zaXRpb247XG4gICAgY29uc3QgeyBtaW5XaWR0aCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWF4SGVpZ2h0IH0gPSBib3VuZGFyaWVzO1xuICAgIGNvbnN0IHsgeDogc3RhcnRYLCB5OiBzdGFydFksIHdpZHRoOiBzdGFydFdpZHRoLCBoZWlnaHQ6IHN0YXJ0SGVpZ2h0LCBhc3BlY3RSYXRpbyB9ID0gc3RhcnRWYWx1ZXM7XG4gICAgbGV0IGRpc3RYID0gTWF0aC5mbG9vcihpc0hvcml6b250YWwgPyB4U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJYIDogMCk7XG4gICAgbGV0IGRpc3RZID0gTWF0aC5mbG9vcihpc1ZlcnRpY2FsID8geVNuYXBwZWQgLSBzdGFydFZhbHVlcy5wb2ludGVyWSA6IDApO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKTtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRYID0gLW5vZGVPcmlnaW5bMF0gKiBzdGFydFdpZHRoO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFkgPSAtbm9kZU9yaWdpblsxXSAqIHN0YXJ0SGVpZ2h0O1xuICAgIC8vIENoZWNrIGlmIG1heFdpZHRoLCBtaW5XV2lkdGgsIG1heEhlaWdodCwgbWluSGVpZ2h0IGFyZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgbGV0IGNsYW1wWCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCwgbWluV2lkdGgsIG1heFdpZHRoKTtcbiAgICBsZXQgY2xhbXBZID0gZ2V0U2l6ZUNsYW1wKG5ld0hlaWdodCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgIC8vIENoZWNrIGlmIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgICBsZXQgeEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgbGV0IHlFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGlmIChhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgZGlzdFggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA+IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA8IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFkgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3SGVpZ2h0ICsgb3JpZ2luT2Zmc2V0WSwgZXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCwgY2hpbGRFeHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGgsIGNoaWxkRXh0ZW50WzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZmZWN0c1kgJiYgZGlzdFkgPiAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIGRpc3RZLCBjaGlsZEV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQsIGNoaWxkRXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFzcGVjdCByYXRpbyByZXNpemluZyBvZiB0aGUgb3RoZXIgc2lkZSBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWF4IGRpbWVuc2lvbnMgbWlnaHQgYmUgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgYXNwZWN0SGVpZ2h0Q2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3V2lkdGggLyBhc3BlY3RSYXRpbywgbWluSGVpZ2h0LCBtYXhIZWlnaHQpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEhlaWdodENsYW1wKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIChhZmZlY3RzWCA/IGRpc3RYIDogLWRpc3RYKSAvIGFzcGVjdFJhdGlvLCBleHRlbnRbMF1bMV0pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzBdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSB0aGluZyBmb3IgdmVydGljYWwgcmVzaXppbmdcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdFdpZHRoQ2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIG1pbldpZHRoLCBtYXhXaWR0aCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0V2lkdGhDbGFtcCk7XG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWSAmJiAhYWZmZWN0c1ggJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgKGFmZmVjdHNZID8gZGlzdFkgOiAtZGlzdFkpICogYXNwZWN0UmF0aW8gKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3RZID0gZGlzdFkgKyAoZGlzdFkgPCAwID8gY2xhbXBZIDogLWNsYW1wWSk7XG4gICAgZGlzdFggPSBkaXN0WCArIChkaXN0WCA8IDAgPyBjbGFtcFggOiAtY2xhbXBYKTtcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RYIDogZGlzdFgpIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9ICh4b3IoYWZmZWN0c1gsIGFmZmVjdHNZKSA/IC1kaXN0WSA6IGRpc3RZKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gZGlzdFggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBhZmZlY3RzWSA9IGFmZmVjdHNYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdFggPSBkaXN0WSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNYID0gYWZmZWN0c1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeCA9IGFmZmVjdHNYID8gc3RhcnRYICsgZGlzdFggOiBzdGFydFg7XG4gICAgY29uc3QgeSA9IGFmZmVjdHNZID8gc3RhcnRZICsgZGlzdFkgOiBzdGFydFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyAoYWZmZWN0c1ggPyAtZGlzdFggOiBkaXN0WCksXG4gICAgICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyAoYWZmZWN0c1kgPyAtZGlzdFkgOiBkaXN0WSksXG4gICAgICAgIHg6IG5vZGVPcmlnaW5bMF0gKiBkaXN0WCAqICghYWZmZWN0c1ggPyAxIDogLTEpICsgeCxcbiAgICAgICAgeTogbm9kZU9yaWdpblsxXSAqIGRpc3RZICogKCFhZmZlY3RzWSA/IDEgOiAtMSkgKyB5LFxuICAgIH07XG59XG5cbmNvbnN0IGluaXRQcmV2VmFsdWVzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB4OiAwLCB5OiAwIH07XG5jb25zdCBpbml0U3RhcnRWYWx1ZXMgPSB7XG4gICAgLi4uaW5pdFByZXZWYWx1ZXMsXG4gICAgcG9pbnRlclg6IDAsXG4gICAgcG9pbnRlclk6IDAsXG4gICAgYXNwZWN0UmF0aW86IDEsXG59O1xuZnVuY3Rpb24gbm9kZVRvUGFyZW50RXh0ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtub2RlLm1lYXN1cmVkLndpZHRoLCBub2RlLm1lYXN1cmVkLmhlaWdodF0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBwYXJlbnQsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCB4ID0gcGFyZW50LnBvc2l0aW9uLnggKyBjaGlsZC5wb3NpdGlvbi54O1xuICAgIGNvbnN0IHkgPSBwYXJlbnQucG9zaXRpb24ueSArIGNoaWxkLnBvc2l0aW9uLnk7XG4gICAgY29uc3Qgd2lkdGggPSBjaGlsZC5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGNoaWxkLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSBub2RlT3JpZ2luWzBdICogd2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IG5vZGVPcmlnaW5bMV0gKiBoZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW3ggLSBvcmlnaW5PZmZzZXRYLCB5IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgICAgIFt4ICsgd2lkdGggLSBvcmlnaW5PZmZzZXRYLCB5ICsgaGVpZ2h0IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIFhZUmVzaXplcih7IGRvbU5vZGUsIG5vZGVJZCwgZ2V0U3RvcmVJdGVtcywgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgY29udHJvbFBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIHJlc2l6ZURpcmVjdGlvbiwgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCBzaG91bGRSZXNpemUsIH0pIHtcbiAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7IC4uLmluaXRQcmV2VmFsdWVzIH07XG4gICAgICAgIGxldCBzdGFydFZhbHVlcyA9IHsgLi4uaW5pdFN0YXJ0VmFsdWVzIH07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xEaXJlY3Rpb24gPSBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7IC8vIE5lZWRlZCB0byBmaXggZXhwYW5kUGFyZW50XG4gICAgICAgIGxldCBwYXJlbnRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBkcmFnKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgcGFuZURvbU5vZGUgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gcGFuZURvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHhTbmFwcGVkLCB5U25hcHBlZCB9ID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcmV2VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCA/PyAwLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSA/PyAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIC4uLnByZXZWYWx1ZXMsXG4gICAgICAgICAgICAgICAgcG9pbnRlclg6IHhTbmFwcGVkLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJZOiB5U25hcHBlZCxcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogcHJldlZhbHVlcy53aWR0aCAvIHByZXZWYWx1ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnIHx8IG5vZGUuZXhwYW5kUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRFeHRlbnQgPSBwYXJlbnROb2RlICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyA/IG5vZGVUb1BhcmVudEV4dGVudChwYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBDb2xsZWN0IGFsbCBjaGlsZCBub2RlcyB0byBjb3JyZWN0IHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERldGVybWluZSBsYXJnZXN0IG1pbmltYWwgZXh0ZW50IHRoZSBwYXJlbnQgbm9kZSBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0b1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkSWQsIGNoaWxkXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudElkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4uY2hpbGQucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogY2hpbGQuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgY2hpbGQuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBub2RlVG9DaGlsZEV4dGVudChjaGlsZCwgbm9kZSwgY2hpbGQub3JpZ2luID8/IG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1pbihleHRlbnRbMF1bMF0sIGNoaWxkRXh0ZW50WzBdWzBdKSwgTWF0aC5taW4oZXh0ZW50WzBdWzFdLCBjaGlsZEV4dGVudFswXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5tYXgoZXh0ZW50WzFdWzBdLCBjaGlsZEV4dGVudFsxXVswXSksIE1hdGgubWF4KGV4dGVudFsxXVsxXSwgY2hpbGRFeHRlbnRbMV1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBleHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0Py4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4gfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHg6IHByZXZYLCB5OiBwcmV2WSwgd2lkdGg6IHByZXZXaWR0aCwgaGVpZ2h0OiBwcmV2SGVpZ2h0IH0gPSBwcmV2VmFsdWVzO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge307XG4gICAgICAgICAgICBjb25zdCBub2RlT3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gc3RvcmVOb2RlT3JpZ2luO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXREaW1lbnNpb25zQWZ0ZXJSZXNpemUoc3RhcnRWYWx1ZXMsIGNvbnRyb2xEaXJlY3Rpb24sIHBvaW50ZXJQb3NpdGlvbiwgYm91bmRhcmllcywga2VlcEFzcGVjdFJhdGlvLCBub2RlT3JpZ2luLCBwYXJlbnRFeHRlbnQsIGNoaWxkRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzV2lkdGhDaGFuZ2UgPSB3aWR0aCAhPT0gcHJldldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaXNIZWlnaHRDaGFuZ2UgPSBoZWlnaHQgIT09IHByZXZIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBpc1hQb3NDaGFuZ2UgPSB4ICE9PSBwcmV2WCAmJiBpc1dpZHRoQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgaXNZUG9zQ2hhbmdlID0geSAhPT0gcHJldlkgJiYgaXNIZWlnaHRDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWlzWFBvc0NoYW5nZSAmJiAhaXNZUG9zQ2hhbmdlICYmICFpc1dpZHRoQ2hhbmdlICYmICFpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1hQb3NDaGFuZ2UgfHwgaXNZUG9zQ2hhbmdlIHx8IG5vZGVPcmlnaW5bMF0gPT09IDEgfHwgbm9kZU9yaWdpblsxXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS54ID0gaXNYUG9zQ2hhbmdlID8geCA6IHByZXZWYWx1ZXMueDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueSA9IGlzWVBvc0NoYW5nZSA/IHkgOiBwcmV2VmFsdWVzLnk7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0gY2hhbmdlLng7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0gY2hhbmdlLnk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB3aGVuIHRvcC9sZWZ0IGNoYW5nZXMsIGNvcnJlY3QgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgICAqIHNvIHRoYXQgdGhleSBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0geCAtIHByZXZYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0geSAtIHByZXZZO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgbm9kZU9yaWdpblswXSAqICh3aWR0aCAtIHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgbm9kZU9yaWdpblsxXSAqIChoZWlnaHQgLSBwcmV2SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENoYW5nZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2lkdGhDaGFuZ2UgfHwgaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICBpc1dpZHRoQ2hhbmdlICYmICghcmVzaXplRGlyZWN0aW9uIHx8IHJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKSA/IHdpZHRoIDogcHJldlZhbHVlcy53aWR0aDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaGVpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaXNIZWlnaHRDaGFuZ2UgJiYgKCFyZXNpemVEaXJlY3Rpb24gfHwgcmVzaXplRGlyZWN0aW9uID09PSAndmVydGljYWwnKSA/IGhlaWdodCA6IHByZXZWYWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMud2lkdGggPSBjaGFuZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy5oZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGV4cGFuZFBhcmVudCB3aGVuIHJlc2l6aW5nIGZyb20gdG9wL2xlZnRcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gbm9kZU9yaWdpblswXSAqIChjaGFuZ2Uud2lkdGggPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS54ICYmIGNoYW5nZS54IDwgeExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IHhMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueCA9IHN0YXJ0VmFsdWVzLnggLSAoY2hhbmdlLnggLSB4TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5TGltaXQgPSBub2RlT3JpZ2luWzFdICogKGNoYW5nZS5oZWlnaHQgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS55ICYmIGNoYW5nZS55IDwgeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IHlMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueSA9IHN0YXJ0VmFsdWVzLnkgLSAoY2hhbmdlLnkgLSB5TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFJlc2l6ZURpcmVjdGlvbih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZWYWx1ZXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWDogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWTogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHsgLi4ucHJldlZhbHVlcywgZGlyZWN0aW9uIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsUmVzaXplID0gc2hvdWxkUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2UsIGNoaWxkQ2hhbmdlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25SZXNpemVFbmQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgb25FbmQ/Lih7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbChkcmFnSGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHNlbGVjdGlvbi5vbignLmRyYWcnLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBYWURyYWcsIFhZSGFuZGxlLCBYWU1pbmltYXAsIFhZUGFuWm9vbSwgWFlSZXNpemVyLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIGFkZEVkZ2UsIGFkb3B0VXNlck5vZGVzLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBhcmVTZXRzRXF1YWwsIGJveFRvUmVjdCwgY2FsY0F1dG9QYW4sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgY2xhbXAsIGNsYW1wUG9zaXRpb24sIGNsYW1wUG9zaXRpb25Ub1BhcmVudCwgY3JlYXRlTWFya2VySWRzLCBkZWZhdWx0QXJpYUxhYmVsQ29uZmlnLCBkZXZXYXJuLCBlbGVtZW50U2VsZWN0aW9uS2V5cywgZXJyb3JNZXNzYWdlcywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBmaXRWaWV3cG9ydCwgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Qm91bmRzT2ZCb3hlcywgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldENvbm5lY3Rpb25TdGF0dXMsIGdldERpbWVuc2lvbnMsIGdldEVkZ2VDZW50ZXIsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRFdmVudFBvc2l0aW9uLCBnZXRIYW5kbGVCb3VuZHMsIGdldEhhbmRsZVBvc2l0aW9uLCBnZXRIb3N0Rm9yRWxlbWVudCwgZ2V0SW5jb21lcnMsIGdldEludGVybmFsTm9kZXNCb3VuZHMsIGdldE1hcmtlcklkLCBnZXROb2RlRGltZW5zaW9ucywgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiwgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0sIGdldE5vZGVzQm91bmRzLCBnZXROb2Rlc0luc2lkZSwgZ2V0T3V0Z29lcnMsIGdldE92ZXJsYXBwaW5nQXJlYSwgZ2V0UG9pbnRlclBvc2l0aW9uLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRWaWV3cG9ydEZvckJvdW5kcywgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgaGFuZGxlRXhwYW5kUGFyZW50LCBpbmZpbml0ZUV4dGVudCwgaW5pdGlhbENvbm5lY3Rpb24sIGlzQ29vcmRpbmF0ZUV4dGVudCwgaXNFZGdlQmFzZSwgaXNFZGdlVmlzaWJsZSwgaXNJbnB1dERPTU5vZGUsIGlzSW50ZXJuYWxOb2RlQmFzZSwgaXNNYWNPcywgaXNNb3VzZUV2ZW50LCBpc05vZGVCYXNlLCBpc051bWVyaWMsIGlzUmVjdE9iamVjdCwgbWVyZ2VBcmlhTGFiZWxDb25maWcsIG5vZGVIYXNEaW1lbnNpb25zLCBub2RlVG9Cb3gsIG5vZGVUb1JlY3QsIG9wcG9zaXRlUG9zaXRpb24sIHBhbkJ5LCBwb2ludFRvUmVuZGVyZXJQb2ludCwgcmVjb25uZWN0RWRnZSwgcmVjdFRvQm94LCByZW5kZXJlclBvaW50VG9Qb2ludCwgc2hhbGxvd05vZGVEYXRhLCBzbmFwUG9zaXRpb24sIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zLCB1cGRhdGVDb25uZWN0aW9uTG9va3VwLCB1cGRhdGVOb2RlSW50ZXJuYWxzLCB3aXRoUmVzb2x2ZXJzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ })

};
;